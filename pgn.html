<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lichess PGN Analyzer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111c34;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --ok: #22c55e;
      --warn: #facc15;
      --danger: #f87171;
      --panel-border: rgba(148, 163, 184, 0.2);
      --eval-white: #f8fafc;
      --eval-black: #0b1220;
      --eval-border: rgba(148, 163, 184, 0.28);
      --eval-bar-width: clamp(32px, 7.5vw, 56px);
      --material-positive: #4ade80;
      --material-negative: #f87171;
      --input-bg: rgba(15, 23, 42, 0.75);
      --input-border: rgba(148, 163, 184, 0.3);
      --arrow-label-fill: rgba(15, 23, 42, 0.9);
      --arrow-label-stroke: rgba(148, 163, 184, 0.85);
      --arrow-label-text: #f8fafc;
      --shadow: 0 18px 48px rgba(8, 15, 35, 0.55);
      --layout-padding: clamp(16px, 2vw, 28px);
      --header-height: 64px;
      --board-max-height: none;
      --piece-white-filter: none;
      --piece-black-filter: none;
      --sq-light: #6a7483;
      --sq-dark: #1e2a35;
      --eval-score-bg: rgba(15, 23, 42, 0.88);
      --eval-score-text: #f8fafc;
      --eval-score-border: rgba(148, 163, 184, 0.4);
      --move-best-bg: rgba(34, 197, 94, 0.18);
      --move-best-fg: #4ade80;
      --move-excellent-bg: rgba(56, 189, 248, 0.18);
      --move-excellent-fg: #38bdf8;
      --move-great-bg: rgba(245, 158, 11, 0.22);
      --move-great-fg: #fbbf24;
      --move-brilliant-bg: rgba(20, 184, 166, 0.22);
      --move-brilliant-fg: #2dd4bf;
      --sgn-top: #7C3AED;
      --sgn-best: #10B981;
      --sgn-excellent: #3B82F6;
      --sgn-great: #F59E0B;
      --sgn-brilliant: #14B8A6;
      --sgn-muted: #94A3B8;
      --row-radius: 12px;
      --row-pad-y: 10px;
      --row-pad-x: 12px;
      /* Board appearance */
      --board-border: rgba(255, 255, 255, 0.08);
      --board-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
      --board-coord: rgba(248, 250, 252, 0.7);
      --board-radius: 12px;
      --board-texture:
        radial-gradient(120px 80px at 20% 30%, rgba(255, 255, 255, 0.06) 0 60%, transparent 60%),
        radial-gradient(140px 100px at 70% 70%, rgba(255, 255, 255, 0.05) 0 60%, transparent 60%);
      --eval-chart-line: var(--accent);
      --eval-chart-fill-white: rgba(248, 250, 252, 0.16);
      --eval-chart-fill-black: rgba(8, 15, 35, 0.35);
      --eval-chart-axis: rgba(148, 163, 184, 0.32);
      --eval-chart-grid: rgba(148, 163, 184, 0.16);
      --eval-chart-marker-blunder: var(--danger);
      --eval-chart-marker-mistake: var(--warn);
      --eval-chart-marker-inaccuracy: var(--muted);
      --eval-chart-marker-best: var(--move-best-fg);
      --eval-chart-marker-excellent: var(--move-excellent-fg);
      --eval-chart-marker-great: var(--move-great-fg);
      --eval-chart-marker-brilliant: var(--move-brilliant-fg);
    }

    [data-theme="light"] {
      --bg: #f1f5f9;
      --panel: #ffffff;
      --text: #0f172a;
      --muted: #475569;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --ok: #15803d;
      --warn: #b45309;
      --danger: #dc2626;
      --panel-border: rgba(15, 23, 42, 0.08);
      --eval-white: #ffffff;
      --eval-black: #1f2937;
      --eval-border: rgba(148, 163, 184, 0.25);
      --material-positive: #15803d;
      --material-negative: #dc2626;
      --input-bg: #f8fafc;
      --input-border: rgba(15, 23, 42, 0.12);
      --arrow-label-fill: rgba(248, 250, 252, 0.92);
      --arrow-label-stroke: rgba(148, 163, 184, 0.85);
      --arrow-label-text: #0f172a;
      --shadow: 0 12px 32px rgba(15, 23, 42, 0.15);
      --eval-score-bg: rgba(248, 250, 252, 0.9);
      --eval-score-text: #0f172a;
      --eval-score-border: rgba(15, 23, 42, 0.15);
      --move-best-bg: rgba(34, 197, 94, 0.16);
      --move-best-fg: #166534;
      --move-excellent-bg: rgba(37, 99, 235, 0.15);
      --move-excellent-fg: #1d4ed8;
      --move-great-bg: rgba(251, 191, 36, 0.22);
      --move-great-fg: #b45309;
      --move-brilliant-bg: rgba(45, 212, 191, 0.2);
      --move-brilliant-fg: #0f766e;
      --sgn-top: #7C3AED;
      --sgn-best: #10B981;
      --sgn-excellent: #3B82F6;
      --sgn-great: #F59E0B;
      --sgn-brilliant: #14B8A6;
      --sgn-muted: #94A3B8;
      --row-radius: 12px;
      --row-pad-y: 10px;
      --row-pad-x: 12px;
      --board-border: rgba(15, 23, 42, 0.18);
      --board-shadow: 0 6px 20px rgba(8, 15, 35, 0.25);
      --board-coord: rgba(15, 23, 42, 0.55);
      --eval-chart-fill-white: rgba(37, 99, 235, 0.12);
      --eval-chart-fill-black: rgba(15, 23, 42, 0.12);
      --eval-chart-axis: rgba(71, 85, 105, 0.35);
      --eval-chart-grid: rgba(148, 163, 184, 0.22);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: var(--layout-padding);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      color: var(--text);
      background: var(--bg);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    h1 {
      margin: 0 0 20px;
      font-size: 26px;
      letter-spacing: 0.4px;
    }

    a {
      color: var(--accent);
    }

    .app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 18px;
      border-radius: 18px;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      margin-bottom: 22px;
      min-height: var(--header-height);
      position: relative;
      z-index: 2;
    }

    .app-header h1 {
      margin: 0;
    }

    .header-actions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap;
    }

    .header-select {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      position: relative;
    }

    .header-select select.compact {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--panel-border);
      background: var(--panel);
      color: var(--text);
      font-size: 13px;
      flex: 0 0 auto;
      width: auto;
      min-width: 0;
      max-width: 140px;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .header-toggle {
      padding: 8px 14px;
      font-size: 14px;
    }

    .layout {
      display: grid;
      gap: clamp(18px, 2vw, 28px);
      align-items: start;
      grid-template-columns: minmax(0, 1.6fr) minmax(0, 1fr);
      max-width: 1480px;
      margin: 0 auto;
      position: relative;
      width: 100%;
    }

    .workspace-column {
      position: relative;
      min-width: 0;
    }

    .workspace-sticky {
      position: sticky;
      top: calc(var(--layout-padding) + var(--header-height));
      display: flex;
      flex-direction: column;
      gap: clamp(18px, 2vw, 24px);
    }

    .info-column {
      display: flex;
      flex-direction: column;
      gap: 18px;
      min-width: 0;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 18px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .board-card {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .board-shell {
      position: relative;
      width: 100%;
      isolation: isolate;
      border-radius: var(--board-radius);
      box-shadow: var(--board-shadow);
      overflow: hidden;
      border: 1px solid var(--board-border);
      background: var(--panel);
    }

    .board-shell[data-board-style="glass"] {
      --sq-light: #6a7483;
      --sq-dark: #1e2a35;
      --piece-white-filter: brightness(1) saturate(1) contrast(1);
      --piece-black-filter: brightness(1.18) saturate(1.06) contrast(0.92);
    }

    .board-shell[data-board-style="classic"] {
      --sq-light: #f0d9b5;
      --sq-dark: #b58863;
    }

    .board-shell[data-board-style="icy-sea"] {
      --sq-light: #e6f1f6;
      --sq-dark: #5b8397;
    }

    .board-shell[data-board-style="wood"] {
      --sq-light: #ecd7b0;
      --sq-dark: #8e5e3b;
    }

    .board-shell[data-board-style="slate"] {
      --sq-light: #cfd5db;
      --sq-dark: #5d6b79;
    }

    .board-shell[data-board-style="sand"] {
      --sq-light: #f2ead8;
      --sq-dark: #c2a477;
    }

    .board-shell[data-board-style="purple"] {
      --sq-light: #dddbff;
      --sq-dark: #6b5fa7;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: stretch;
    }

    .row+.row {
      margin-top: 12px;
    }

    input[type="text"],
    input[type="number"],
    input[type="password"],
    textarea,
    select {
      flex: 1;
      min-width: 0;
      padding: 10px 12px;
      border: 1px solid var(--input-border);
      border-radius: 10px;
      background: var(--input-bg);
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s ease, background-color 0.2s ease, color 0.2s ease;
    }

    textarea {
      resize: vertical;
      min-height: 140px;
      line-height: 1.45;
    }

    select {
      flex: 0 0 180px;
      cursor: pointer;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="password"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
    }

    button {
      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-strong) 100%);
      border: 1px solid rgba(15, 23, 42, 0.25);
      color: #f8fafc;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 0.12s ease, filter 0.2s ease;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--panel-border);
    }

    button:hover {
      filter: brightness(1.05);
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    button.compact {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 8px;
    }

    .status {
      min-height: 20px;
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .status.error {
      color: var(--danger);
    }

    .status.ok {
      color: var(--ok);
    }

    .explanation-panel {
      margin-top: 14px;
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      padding: 14px 16px;
      background: rgba(148, 163, 184, 0.08);
      display: grid;
      gap: 10px;
    }

    [data-theme="light"] .explanation-panel {
      background: rgba(37, 99, 235, 0.05);
    }

    .explanation-headline {
      font-size: 15px;
      font-weight: 600;
      line-height: 1.4;
    }

    .explanation-details {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }

    .explanation-details ul {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 6px;
    }

    .explanation-details li {
      list-style: disc;
    }

    .explanation-cards {
      display: grid;
      gap: 12px;
    }

    .explanation-cards:empty {
      display: none;
    }

    .explanation-card {
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      padding: 10px 12px;
      background: rgba(148, 163, 184, 0.12);
      display: grid;
      gap: 6px;
    }

    [data-theme="light"] .explanation-card {
      background: rgba(37, 99, 235, 0.09);
    }

    .explanation-card-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
    }

    .explanation-card-headline-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .explanation-card-headline-text {
      flex: 1;
    }

    .explanation-card-headline {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
    }

    .explanation-card button[data-action="show-line"] {
      margin-left: auto;
    }

    .explanation-card button[data-action="show-line"].active {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(56, 189, 248, 0.18);
    }

    .explanation-card-list {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 4px;
      font-size: 13px;
      color: var(--muted);
    }

    .explanation-card-list li {
      list-style: disc;
    }

    .pv-continuation-label {
      font-weight: 600;
      color: var(--muted);
      margin-right: 6px;
    }

    .pv-move-token {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 8px;
      margin: 2px 6px 2px 0;
      background: rgba(148, 163, 184, 0.16);
      background-image: none;
      border: 1px solid var(--panel-border);
      border-radius: 999px;
      color: var(--text);
      font-size: 13px;
      line-height: 1.2;
      cursor: pointer;
      pointer-events: auto;
      box-shadow: none;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, transform 0.12s ease;
    }

    .pv-move-token:hover,
    .pv-move-token:focus-visible,
    .pv-move-token.active {
      background: rgba(56, 189, 248, 0.22);
      border-color: rgba(56, 189, 248, 0.45);
      color: var(--accent);
      outline: none;
    }

    .pv-move-token:focus-visible {
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.35);
    }

    .explanation-actions {
      display: flex;
      justify-content: flex-end;
    }

    .explanation-actions[hidden] {
      display: none;
    }

    .board-area {
      display: grid;
      grid-template-columns: var(--eval-bar-width) minmax(0, 1fr);
      gap: 0;
      align-items: stretch;
      width: 100%;
      position: relative;
      background: var(--panel);
    }

    .board-wrap {
      position: relative;
      width: 100%;
      min-width: 0;
      border-radius: 0;
      overflow: hidden;
      background: transparent;
    }

    #board {
      width: 100%;
      aspect-ratio: 1 / 1;
      max-width: none;
      display: block;
      border-radius: 0;
      overflow: hidden;
      background: none;
    }

    #board .white-1e1d7,
    #board .square.light {
      background: var(--sq-light);
      background-image: var(--board-texture);
      background-blend-mode: overlay;
    }

    #board .black-3c85d,
    #board .square.dark {
      background: var(--sq-dark);
      background-image: var(--board-texture);
      background-blend-mode: overlay;
    }

    #board .notation-322f9 {
      color: var(--board-coord);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.25);
    }

    .board-shell[data-board-style="glass"] #board .white-1e1d7,
    .board-shell[data-board-style="glass"] #board .black-3c85d,
    .board-shell[data-board-style="glass"] #board .square.light,
    .board-shell[data-board-style="glass"] #board .square.dark {
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05), inset 0 0 12px rgba(0, 0, 0, 0.35);
      border-radius: 6px;
    }

    #board img.piece {
      transition: filter 0.25s ease;
    }

    .board-shell[data-board-style="glass"] #board img.piece[data-side="w"] {
      filter: var(--piece-white-filter);
    }

    .board-shell[data-board-style="glass"] #board img.piece[data-side="b"] {
      filter: var(--piece-black-filter);
    }

    .eval-chart-card {
      display: grid;
      gap: 12px;
      padding: 16px;
      border-radius: 14px;
      border: 1px solid var(--panel-border);
      background: rgba(148, 163, 184, 0.08);
    }

    [data-theme="light"] .eval-chart-card {
      background: rgba(37, 99, 235, 0.05);
    }

    .eval-chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .eval-chart-title {
      margin: 0;
      font-size: 13px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      font-weight: 700;
      color: var(--muted);
    }

    .eval-chart-modes {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(148, 163, 184, 0.12);
    }

    [data-theme="light"] .eval-chart-modes {
      background: rgba(37, 99, 235, 0.08);
    }

    .eval-chart-mode {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      padding: 4px 12px;
      border-radius: 999px;
      cursor: pointer;
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    .eval-chart-mode:hover,
    .eval-chart-mode:focus-visible {
      color: var(--text);
      outline: none;
    }

    .eval-chart-mode:focus-visible {
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.35);
    }

    .eval-chart-mode.active {
      background: var(--accent);
      color: #0f172a;
    }

    .eval-chart-canvas {
      position: relative;
      width: 100%;
      height: 180px;
      border-radius: 12px;
      border: 1px solid var(--panel-border);
      background: rgba(8, 15, 35, 0.35);
      overflow: hidden;
    }

    [data-theme="light"] .eval-chart-canvas {
      background: rgba(148, 163, 184, 0.18);
    }

    .eval-chart-canvas canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .eval-chart-tooltip {
      position: absolute;
      display: none;
      min-width: 180px;
      max-width: 240px;
      padding: 10px 12px;
      border-radius: 12px;
      background: var(--eval-score-bg);
      color: var(--eval-score-text);
      border: 1px solid var(--eval-score-border);
      box-shadow: 0 10px 30px rgba(8, 15, 35, 0.45);
      pointer-events: none;
      z-index: 5;
    }

    .eval-chart-tooltip__move {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .eval-chart-tooltip__eval {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .eval-chart-tooltip__delta {
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
    }

    .eval-chart-tooltip__delta.positive {
      color: var(--ok);
    }

    .eval-chart-tooltip__delta.negative {
      color: var(--danger);
    }

    .eval-chart-tooltip__tag {
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
    }

    .eval-chart-empty {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 24px;
      text-align: center;
      font-size: 13px;
      color: var(--muted);
      pointer-events: none;
    }

    #evalColumn {
      height: 100%;
    }

    #evalColumn .eval-vertical {
      height: 100%;
    }

    #arrowLayer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
    }

    .arrow-label-circle {
      fill: var(--arrow-label-fill);
      stroke: var(--arrow-label-stroke);
      stroke-width: 1.5;
    }

    .arrow-label-text {
      fill: var(--arrow-label-text);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: -0.01em;
      dominant-baseline: middle;
    }

    .board-badge-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .board-move-badge {
      position: absolute;
      width: 32px;
      height: 32px;
      display: none;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      box-shadow: none;
      pointer-events: none;
    }

    .board-move-badge-icon {
      width: 32px;
      height: 32px;
      object-fit: contain;
      filter: drop-shadow(0 1px 3px rgba(8, 15, 35, 0.45));
    }

    .board-move-badge-overlay {
      display: none;
    }

    .board-move-badge[data-classification] {
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .eval-column {
      width: var(--eval-bar-width);
      flex: 0 0 var(--eval-bar-width);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: stretch;
      gap: 0;
      height: 100%;
      border-radius: 12px 0 0 12px;
      overflow: hidden;
      background: var(--panel);
    }

    .eval-vertical {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 0;
      background: var(--eval-black);
      border-radius: 0;
      border: 1px solid var(--eval-border);
      overflow: hidden;
      transition: background-color 0.25s ease, border-color 0.25s ease;
    }

    .eval-column[data-orientation="black"] .eval-vertical {
      background: var(--eval-white);
    }

    .eval-fill {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 50%;
      background: var(--eval-white);
      transition: height 0.25s ease, background-color 0.25s ease;
    }

    .eval-column[data-orientation="black"] .eval-fill {
      background: var(--eval-black);
    }

    .eval-marker {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
      box-shadow: 0 0 8px rgba(56, 189, 248, 0.55);
      transition: top 0.25s ease;
      pointer-events: none;
      z-index: 2;
    }

    .eval-score-label {
      position: absolute;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 4px 10px;
      border-radius: 999px;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 12px;
      font-weight: 600;
      background: var(--eval-score-bg);
      color: var(--eval-score-text);
      border: 1px solid var(--eval-score-border);
      box-shadow: 0 6px 18px rgba(8, 15, 35, 0.35);
      pointer-events: none;
      white-space: nowrap;
      transition: top 0.25s ease, background-color 0.25s ease, color 0.25s ease;
      z-index: 3;
    }

    details.collapsible {
      margin-top: 22px;
      margin-bottom: 12px;
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      background: rgba(148, 163, 184, 0.08);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    details.collapsible[open] {
      background: rgba(148, 163, 184, 0.12);
    }

    [data-theme="light"] details.collapsible {
      background: rgba(37, 99, 235, 0.06);
    }

    [data-theme="light"] details.collapsible[open] {
      background: rgba(37, 99, 235, 0.1);
    }

    details.collapsible summary {
      list-style: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 14px 16px;
      font-size: 16px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      color: var(--muted);
    }

    details.collapsible summary::-webkit-details-marker {
      display: none;
    }

    details.collapsible summary::after {
      content: '▸';
      font-size: 14px;
      display: inline-block;
      transition: transform 0.2s ease;
    }

    details.collapsible[open] summary::after {
      transform: rotate(90deg);
    }

    .collapsible-title {
      flex: 1;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .collapsible-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
      text-transform: none;
      font-size: 12px;
      color: var(--muted);
    }

    .collapsible-meta span {
      text-transform: none;
    }

    .collapsible-body {
      padding: 0 0 18px;
      display: grid;
      gap: 14px;
    }

    .material-panel {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 14px;
    }

    .material-card {
      background: rgba(148, 163, 184, 0.12);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
    }

    [data-theme="light"] .material-card {
      background: rgba(37, 99, 235, 0.06);
    }

    .material-player {
      font-size: 13px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .material-score {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 18px;
      font-weight: 600;
      transition: color 0.2s ease;
    }

    .material-score.positive {
      color: var(--material-positive);
    }

    .material-score.negative {
      color: var(--material-negative);
    }

    .material-capture {
      font-size: 12px;
      color: var(--muted);
    }

    .game-load {
      display: grid;
      gap: 12px;
    }

    .game-load-controls {
      display: grid;
      gap: 12px;
    }

    .load-affordances {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: flex-start;
    }

    .chip-button,
    .chip-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(148, 163, 184, 0.14);
      color: var(--text);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    .chip-button.active,
    .chip-pill.active,
    .chip-button:hover,
    .chip-pill:hover {
      background: rgba(56, 189, 248, 0.22);
      border-color: rgba(56, 189, 248, 0.45);
      color: var(--accent);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.25);
    }

    .chip-pill {
      padding: 4px 12px;
      font-size: 12px;
    }

    .board-toolbar {
      width: 100%;
      background: rgba(8, 15, 35, 0.82);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 16px;
      box-shadow: 0 18px 42px rgba(8, 15, 35, 0.55);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    [data-theme="light"] .board-toolbar {
      background: rgba(241, 245, 249, 0.92);
      border-color: rgba(15, 23, 42, 0.12);
      box-shadow: 0 16px 38px rgba(15, 23, 42, 0.25);
    }

    .nav-toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
      padding: 6px 12px;
      min-height: 48px;
      box-sizing: border-box;
      flex-wrap: wrap;
      white-space: normal;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
    }

    .nav-toolbar::-webkit-scrollbar {
      height: 6px;
    }

    .nav-toolbar::-webkit-scrollbar-thumb {
      background: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
    }

    .nav-buttons {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .nav-toolbar button {
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .nav-meta {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      flex: 0 0 auto;
      justify-content: flex-end;
      margin-left: auto;
    }

    .nav-meta-item {
      white-space: nowrap;
    }

    .pill-toggle {
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 600;
      border: 1px solid var(--panel-border);
      background: var(--panel);
      color: var(--text);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }

    .pill-toggle.is-on {
      border-color: rgba(34, 197, 94, 0.4);
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.15) inset;
    }

    .engine-mode-toggle {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .engine-chips {
      display: inline-flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .info-card-body {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .info-card-summary {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
    }

    .sticky-card {
      padding-top: 18px;
    }

    .sticky-card .info-card-summary.sticky-summary {
      position: sticky;
      top: var(--sticky-offset, 0px);
      background: var(--panel);
      margin: calc(-1 * 18px) calc(-1 * 18px) 12px;
      padding: 18px;
      border-radius: 16px 16px 0 0;
      border-bottom: 1px solid var(--panel-border);
      z-index: 5;
    }

    .sticky-card .info-card-summary.sticky-summary:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }

    .sticky-card .info-card-body {
      padding-top: 0;
    }

    #engineSuggestions.info-card,
    #movesPanel.info-card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
    }

    #engineSuggestions .info-card-body,
    #movesPanel .info-card-body {
      background: transparent;
    }

    .summary-scroll {
      overflow-x: visible;
      padding-bottom: 4px;
    }

    .summary-table {
      display: grid;
      gap: 18px;
    }

    .summary-player-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .summary-player-card {
      background: rgba(148, 163, 184, 0.12);
      border-radius: 14px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      min-height: 130px;
    }

    [data-theme="light"] .summary-player-card {
      background: rgba(37, 99, 235, 0.06);
    }

    .summary-player-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
    }

    .summary-player-name {
      font-weight: 600;
      font-size: 16px;
    }

    .summary-player-elo {
      font-size: 13px;
      color: var(--muted);
    }

    .summary-player-metrics {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .summary-player-metric {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .summary-metric-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .summary-metric-value {
      font-size: 22px;
      font-weight: 600;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
    }

    .summary-category-grid {
      display: grid;
      gap: 10px;
    }

    .summary-category-row {
      display: grid;
      grid-template-columns: minmax(160px, 1.4fr) repeat(2, minmax(0, 1fr));
      align-items: center;
      gap: 12px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(148, 163, 184, 0.08);
    }

    .summary-category-row.summary-category-header {
      background: transparent;
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 0 12px;
    }

    .summary-category-row.summary-category-header .summary-category-value {
      font-size: 12px;
      font-weight: 600;
      font-family: inherit;
    }

    .summary-category-label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
      font-size: 14px;
    }

    .summary-category-value {
      text-align: center;
      font-weight: 600;
      font-size: 16px;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
    }

    .summary-icon {
      width: 22px;
      height: 22px;
      object-fit: contain;
    }

    @media (max-width: 768px) {
      .summary-player-metrics {
        grid-template-columns: 1fr;
      }

      .summary-category-row {
        grid-template-columns: minmax(140px, 1fr) repeat(2, minmax(0, 0.8fr));
      }
    }

    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 14px;
    }

    .kv div:nth-child(odd) {
      color: var(--muted);
    }

    .muted {
      color: var(--muted);
    }

    .moves {
      display: grid;
      grid-template-columns: 32px minmax(0, 1fr) minmax(0, 1fr);
      gap: 10px 14px;
      font-size: 14px;
      align-items: start;
    }

    .moves__hdr {
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      align-self: end;
    }

    .moves__no {
      font-weight: 600;
      font-variant-numeric: tabular-nums;
      text-align: right;
      color: var(--muted);
      padding-top: 4px;
    }

    .moves__cell {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 6px;
      border-radius: var(--row-radius);
      padding: var(--row-pad-y) var(--row-pad-x);
      background: rgba(148, 163, 184, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.18);
      color: inherit;
      font: inherit;
      cursor: pointer;
      text-align: left;
      transition: background-color 0.16s ease, border-color 0.16s ease, box-shadow 0.16s ease;
      min-height: 56px;
    }

    .moves__cell:hover,
    .moves__cell:focus-visible {
      outline: none;
      background: rgba(148, 163, 184, 0.14);
      border-color: rgba(56, 189, 248, 0.35);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.18);
    }

    .moves__cell[disabled] {
      background: transparent;
      border: 1px dashed rgba(148, 163, 184, 0.28);
      color: var(--sgn-muted);
      cursor: default;
      align-items: center;
      justify-content: center;
    }

    .moves__cell--active {
      border-color: rgba(56, 189, 248, 0.55);
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.32);
    }

    .moves__label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    .moves__san {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-weight: 600;
    }

    .moves__meta {
      font-size: 12px;
      color: var(--sgn-muted);
      font-variant-numeric: tabular-nums;
    }

    .moves__icon {
      width: 20px;
      height: 20px;
      object-fit: contain;
      filter: drop-shadow(0 1px 2px rgba(8, 15, 35, 0.45));
    }

    .moves__placeholder {
      display: inline-flex;
      width: 100%;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: var(--sgn-muted);
    }

    @media (max-width: 720px) {
      .moves {
        grid-template-columns: 24px 1fr;
      }

      .moves__hdr:nth-child(3) {
        display: none;
      }

      .moves__cell:nth-of-type(3n) {
        grid-column: 2 / -1;
      }

      .moves__cell[disabled] {
        min-height: auto;
      }
    }

    .classification-icon {
      width: 18px;
      height: 18px;
      object-fit: contain;
      filter: drop-shadow(0 0 2px rgba(15, 23, 42, 0.5));
    }

    .pv-list {
      display: grid;
      gap: 10px;
    }

    .suggestion {
      position: relative;
      display: grid;
      grid-template-columns: auto minmax(0, 1fr) auto;
      align-items: center;
      gap: 14px;
      padding: var(--row-pad-y) var(--row-pad-x);
      border-radius: var(--row-radius);
      background: rgba(148, 163, 184, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.18);
      color: inherit;
      font: inherit;
      cursor: pointer;
      text-align: left;
      transition: background-color 0.16s ease, box-shadow 0.16s ease, transform 0.16s ease;
      --suggestion-accent: var(--sgn-muted);
    }

    .suggestion::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      box-shadow: inset 0 0 0 2px var(--suggestion-accent);
      opacity: 0.32;
      pointer-events: none;
      transition: opacity 0.16s ease;
    }

    .suggestion:hover,
    .suggestion:focus-visible {
      outline: none;
      background: rgba(148, 163, 184, 0.14);
    }

    .suggestion:hover::before,
    .suggestion:focus-visible::before {
      opacity: 0.56;
    }

    .suggestion--active {
      background: rgba(148, 163, 184, 0.16);
    }

    .suggestion--active::before {
      opacity: 0.72;
    }

    .suggestion[data-tone="top"] {
      --suggestion-accent: var(--sgn-top);
    }

    .suggestion[data-tone="best"] {
      --suggestion-accent: var(--sgn-best);
    }

    .suggestion[data-tone="excellent"] {
      --suggestion-accent: var(--sgn-excellent);
    }

    .suggestion[data-tone="great"] {
      --suggestion-accent: var(--sgn-great);
    }

    .suggestion[data-tone="brilliant"] {
      --suggestion-accent: var(--sgn-brilliant);
    }

    .suggestion__badge-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border: 1px solid rgba(148, 163, 184, 0.24);
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.10);
      font-weight: 600;
      font-size: 12px;
      color: var(--suggestion-accent);
    }

    .suggestion[data-tone] .suggestion__badge-label {
      border-color: var(--suggestion-accent);
    }

    .suggestion__badge {
      display: flex;
      align-items: center;
      gap: 8px;
      font-variant-numeric: tabular-nums;
    }

    .suggestion__rank {
      font-weight: 700;
      color: var(--sgn-muted);
    }

    .suggestion__icon {
      font-size: 16px;
      line-height: 1;
      color: var(--suggestion-accent);
    }

    .suggestion__text {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .suggestion__move-main {
      font-weight: 600;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .suggestion__meta {
      font-size: 12px;
      color: var(--sgn-muted);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .suggestion__gap {
      font-size: 12px;
      font-variant-numeric: tabular-nums;
      color: var(--sgn-muted);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.24);
    }

    .suggestion:hover .suggestion__move-main,
    .suggestion:focus-visible .suggestion__move-main,
    .suggestion--active .suggestion__move-main {
      font-weight: 700;
    }

    .suggestion-mode-label {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      margin-left: 0;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .mode-toggle {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }

    .mode-toggle-label {
      display: inline-flex;
      align-items: center;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
      padding: 2px 0;
      outline: none;
    }

    .mode-toggle-label.active {
      color: var(--accent);
    }

    .mode-toggle-label:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .mode-toggle-switch {
      position: relative;
      width: 46px;
      height: 24px;
      cursor: pointer;
    }

    .mode-toggle-switch input {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      margin: 0;
      cursor: pointer;
    }

    .mode-toggle-track {
      position: relative;
      display: block;
      width: 100%;
      height: 100%;
      background: rgba(148, 163, 184, 0.35);
      border-radius: 999px;
      transition: background 0.2s ease;
    }

    .mode-toggle-handle {
      position: absolute;
      top: 3px;
      left: 4px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--panel);
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.35);
      transition: transform 0.2s ease;
    }

    .mode-toggle-switch input:checked+.mode-toggle-track {
      background: var(--accent);
    }

    .mode-toggle-switch input:checked+.mode-toggle-track .mode-toggle-handle {
      transform: translateX(20px);
    }

    .mode-toggle-switch input:focus-visible+.mode-toggle-track {
      box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.55);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .mono {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
    }

    @media (max-width: 1199px) {
      .layout {
        grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
        gap: clamp(16px, 2vw, 22px);
      }
    }

    @media (max-width: 1024px) {
      body {
        padding: 16px;
      }
    }

    @media (max-width: 768px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .workspace-sticky {
        position: static;
        gap: 18px;
      }

      .board-shell {
        padding-bottom: 0;
      }

      .eval-vertical {
        width: 18px;
        max-width: none;
        min-height: 0;
      }

      .material-panel {
        grid-template-columns: 1fr;
      }

      .board-toolbar {
        position: sticky;
        inset-inline: 0;
        inset-block-end: 0;
        border-radius: 18px 18px 0 0;
        margin: 12px 0 0;
        box-shadow: 0 -10px 30px rgba(8, 15, 35, 0.45);
        z-index: 5;
      }

      [data-theme="light"] .board-toolbar {
        box-shadow: 0 -10px 28px rgba(15, 23, 42, 0.2);
      }

      .nav-meta {
        width: 100%;
        justify-content: center;
        margin-left: 0;
        flex: 0 0 100%;
        text-align: center;
      }

      .info-column {
        padding-right: 0;
      }
    }

    @media (max-width: 720px) {
      .board-area {
        grid-template-columns: var(--eval-bar-width) minmax(0, 1fr);
      }
    }
  </style>
</head>

<body>
  <header class="app-header">
    <h1>Lichess PGN Analyzer</h1>

    <div class="header-actions">
      <label class="header-select" for="boardStyle" title="Board style">
        <span class="sr-only">Board style</span>
        🎨
        <select id="boardStyle" class="compact">
          <option value="glass">Glass</option>
          <option value="classic">Classic</option>
          <option value="icy-sea">Icy Sea</option>
          <option value="wood">Wood</option>
          <option value="slate">Slate</option>
          <option value="sand">Sand</option>
          <option value="purple">Purple</option>
        </select>
      </label>

      <button id="themeToggle" class="secondary header-toggle" aria-live="polite">
        🌙 Dark
      </button>
    </div>
  </header>
  <main class="layout">
    <div class="workspace-column">
      <div class="workspace-sticky" aria-live="polite">
        <section class="card board-card">
          <div class="board-shell" data-board-style="glass">
            <div class="board-area">
              <div class="eval-column" id="evalColumn" data-orientation="white">
                <div class="eval-vertical">
                  <div class="eval-fill" id="evalFill"></div>
                  <div class="eval-marker" id="evalMarker"></div>
                  <div class="eval-score-label" id="evalScoreLabel" aria-live="polite">0.00</div>
                </div>
              </div>
              <div class="board-wrap">
                <div id="board"></div>
                <svg id="arrowLayer" viewBox="0 0 800 800" preserveAspectRatio="none"></svg>
                <div class="board-badge-layer">
                  <div id="boardMoveBadge" class="board-move-badge" aria-hidden="true">
                    <img id="boardMoveBadgeIcon" class="board-move-badge-icon" alt="" />
                    <img id="boardMoveBadgeOverlay" class="board-move-badge-overlay" alt="" />
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="board-toolbar nav-toolbar" role="toolbar" aria-label="Move navigation">
            <div class="nav-buttons">
              <button id="firstBtn" class="secondary" data-label="⏮ First" data-label-compact="⏮">⏮ First</button>
              <button id="prevBtn" class="secondary" data-label="◀ Prev" data-label-compact="◀">◀ Prev</button>
              <button id="nextBtn" data-label="Next ▶" data-label-compact="▶">Next ▶</button>
              <button id="lastBtn" data-label="Last ⏭" data-label-compact="⏭">Last ⏭</button>
              <button id="flipBtn" class="secondary" data-label="Flip" data-label-compact="Flip">Flip</button>
              <button id="exploreToggle" class="pill-toggle" aria-pressed="false" title="Explore lines freely">
                🧭 Explore: Off
              </button>
              <button id="exploreResetBtn" class="secondary" title="Reset explore branch" data-label="Reset to game"
                data-label-compact="Reset" hidden>Reset to game</button>
              <button id="rejoinBtn" class="secondary" title="Return to the main line" data-label="Rejoin main line"
                data-label-compact="Rejoin" hidden>Rejoin main line</button>
            </div>
            <div class="nav-meta" role="status" aria-live="polite">
              <span id="boardStatus" class="nav-meta-item"></span>
            </div>
          </div>
          <div class="eval-chart-card" id="evalChartCard">
            <div class="eval-chart-header">
              <h3 class="eval-chart-title">Evaluation graph</h3>
              <div class="eval-chart-modes" role="group" aria-label="Evaluation scale">
                <button type="button" class="eval-chart-mode active" data-mode="cp" aria-pressed="true">CP</button>
                <button type="button" class="eval-chart-mode" data-mode="win" aria-pressed="false">Win %</button>
              </div>
            </div>
            <div class="eval-chart-canvas" id="evalChartCanvasWrap">
              <canvas id="evalChart" height="180" role="img" aria-label="Evaluation graph"></canvas>
              <div id="evalChartTooltip" class="eval-chart-tooltip" role="tooltip" aria-hidden="true"></div>
              <div id="evalChartEmpty" class="eval-chart-empty">Evaluation graph appears once analysis is ready.</div>
            </div>
          </div>
          <div class="material-panel">
            <div class="material-card">
              <div class="material-player">White</div>
              <div class="material-score" id="materialWhite">0</div>
              <div class="material-capture" id="materialWhiteCapture">—</div>
            </div>
            <div class="material-card">
              <div class="material-player">Black</div>
              <div class="material-score" id="materialBlack">0</div>
              <div class="material-capture" id="materialBlackCapture">—</div>
            </div>
          </div>
          <div id="navStatus" class="status"></div>
        </section>
      </div>
    </div>
    <div class="info-column" aria-label="Analysis details">
      <details id="engineExplanationCard" class="info-card card collapsible sticky-card" open>
        <summary class="info-card-summary sticky-summary" style="--sticky-offset: 0px;">
          <h2>Engine explanations</h2>
        </summary>
        <div class="info-card-body">
          <div id="explanationBox" class="explanation-panel">
            <div id="explanationSummary" class="explanation-headline">Select a move to see the engine's commentary.
            </div>
            <div id="explanationActions" class="explanation-actions" hidden>
              <button id="clearLineOverlayBtn" type="button" class="secondary compact">Clear shown line</button>
            </div>
            <div id="explanationCards" class="explanation-cards"></div>
            <div id="explanationDetails" class="explanation-details"></div>
          </div>
        </div>
      </details>

      <details id="engineSuggestions" class="info-card card collapsible" open>
        <summary class="info-card-summary sticky-summary" style="--sticky-offset: 74px;">
          <h2>Engine suggestions</h2>
          <span class="collapsible-meta">
            <span id="suggestionModeLabel" class="suggestion-mode-label">Current move</span>
            <span>(eval ± rating change vs best)</span>
          </span>
        </summary>
        <div class="info-card-body">
          <div class="row" style="margin:0; justify-content:flex-end;">
            <div class="mode-toggle" role="group" aria-label="Suggestion mode">
              <span id="suggestionToggleOffLabel" class="mode-toggle-label active" role="button" tabindex="0"
                aria-pressed="true">Current move</span>
              <label class="mode-toggle-switch">
                <input type="checkbox" id="suggestionToggle" role="switch" aria-label="Toggle next move suggestions"
                  aria-checked="false" />
                <span class="mode-toggle-track">
                  <span class="mode-toggle-handle"></span>
                </span>
              </label>
              <span id="suggestionToggleOnLabel" class="mode-toggle-label" role="button" tabindex="0"
                aria-pressed="false">Next move</span>
            </div>
          </div>
          <div class="pv-list" id="pvList"></div>
          <div id="engStatus" class="status"></div>
        </div>
      </details>

      <details id="movesPanel" class="info-card card collapsible">
        <summary class="info-card-summary">
          <h2>Moves</h2>
        </summary>
        <div class="info-card-body">
          <div id="moves" class="moves"></div>
        </div>
      </details>

      <details id="gameInfoPanel" class="info-card card collapsible" open>
        <summary class="info-card-summary">
          <h2>Game info</h2>
        </summary>
        <div class="info-card-body">
          <div class="game-load">
            <div class="load-affordances" id="loadAffordanceGroup" role="group"
              aria-label="Game import and export options">
              <button type="button" class="chip-button active" data-load-action="paste">Paste</button>
              <button type="button" class="chip-button" data-load-action="upload">Upload</button>
              <button type="button" class="chip-button" data-load-action="fen">Import FEN</button>
              <button type="button" class="chip-button" data-load-action="lichess">From URL</button>
              <button type="button" class="chip-button" data-load-action="export">Export</button>
            </div>
            <div class="game-load-controls">
              <input type="file" id="pgnFileInput" accept=".pgn,.PGN,.txt,.fen,.FEN" hidden />
              <div class="row input-controls">
                <select id="inputMode">
                  <option value="pgn">PGN</option>
                  <option value="lichess">Lichess URL / ID</option>
                  <option value="fen">FEN</option>
                </select>
                <button id="loadBtn">Load</button>
              </div>
              <div class="row">
                <textarea id="gameInput" rows="8" placeholder="Paste PGN text" autocomplete="off" spellcheck="false"
                  class="mono"></textarea>
              </div>
              <div class="row">
                <label id="inputHint" class="hint">Paste the full PGN for the game you want to analyze.</label>
              </div>
              <div id="loadStatus" class="status"></div>
            </div>
          </div>
          <div class="kv" id="tagBox">
            <div>White</div>
            <div id="tagWhite">—</div>
            <div>Black</div>
            <div id="tagBlack">—</div>
            <div>Event</div>
            <div id="tagEvent">—</div>
            <div>Site</div>
            <div id="tagSite">—</div>
            <div>Date</div>
            <div id="tagDate">—</div>
            <div>Result</div>
            <div id="tagResult">—</div>
            <div>Opening</div>
            <div id="tagOpening">—</div>
          </div>
        </div>
      </details>

      <details id="moveSummaryPanel" class="info-card card collapsible">
        <summary class="info-card-summary">
          <h2>Move summary</h2>
        </summary>
        <div class="info-card-body">
          <div class="summary-scroll">
            <div id="moveSummaryTable" class="summary-table"></div>
          </div>
        </div>
      </details>
    </div>
  </main>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

  <script type="module">
    import { Chess } from './chess.js';
    import { classifyMoveReadonly, recordMoveClassification, clearMoveClassifications } from './moveClassifier.js';
    (function () {
      const byId = (id) => document.getElementById(id);
      const encoder = new TextEncoder();
      const decoder = new TextDecoder();

      const state = {
        board: null,
        orientation: 'white',
        game: new Chess(),
        verboseHistory: [],
        ply: 0,
        lastEval: null,
        engine: null,
        engineReady: false,
        engineConfigured: false,
        engineVersion: 'unknown',
        initialFen: 'start',
        initialPieceCounts: null,
        source: 'pgn',
        rawInput: '',
        analysisCache: new Map(),
        analysisByFen: new Map(),
        analysisPromises: new Map(),
        analysisStatus: 'idle',
        engineQueue: [],
        currentRequest: null,
        analysisToken: 0,
        suggestionMode: 'played',
        suggestionData: [],
        activeSuggestion: null,
        hoverSuggestion: null,
        explanationMode: 'current',
        enginePaused: false,
        badgeRaf: null,
        headers: {},
        lineOverlay: [],
        ghostPreview: null,
        nodeMap: new Map(),
        rootNodeId: null,
        currentNodeId: null,
        lineSelections: new Map(),
        mainlineSelections: new Map(),
        nodeSeq: 0,
        exploreMode: false,
        evalChartMode: 'cp',
        evalChartPoints: [],
        evalChartLayout: [],
        evalChartDataDirty: true,
        evalChartHoverIndex: null,
        evalChartHoverPosition: null
      };

      const BOARD_STYLES = ['glass', 'classic', 'icy-sea', 'wood', 'slate', 'sand', 'purple'];
      const LEGACY_BOARD_STYLE_MAP = { auto: 'glass', brown: 'wood', green: 'slate' };
      const BOARD_STYLE_STORAGE_KEY = 'boardStyle';
      const EVAL_CHART_MODES = ['cp', 'win'];
      const EVAL_CHART_MODE_STORAGE_KEY = 'evalChartMode';
      const CP_RANGE = 600;
      const WIN_RANGE = 50;
      const CLASSIFICATION_LABELS = {
        brilliant: 'Brilliant move',
        great: 'Great move',
        blunder: 'Blunder',
        mistake: 'Mistake',
        inaccuracy: 'Inaccuracy',
        best: 'Best move',
        excellent: 'Excellent move'
      };
      let boardDecorationRaf = null;
      let evalChartRaf = null;

      function getPlayerDisplayName(color, headersOverride) {
        const headers = headersOverride || state.headers || {};
        const key = color === 'b' ? 'Black' : 'White';
        const raw = headers[key];
        if (typeof raw === 'string') {
          const trimmed = raw.trim();
          if (trimmed && !/^[-–—?]+$/.test(trimmed)) {
            return trimmed;
          }
        }
        return key;
      }

      function updatePlayerNameDisplays() {
        const whiteName = getPlayerDisplayName('w');
        const blackName = getPlayerDisplayName('b');

        const materialCards = document.querySelectorAll('.material-card');
        if (materialCards.length > 0) {
          const whiteLabel = materialCards[0].querySelector('.material-player');
          if (whiteLabel) {
            whiteLabel.textContent = whiteName;
          }
        }
        if (materialCards.length > 1) {
          const blackLabel = materialCards[1].querySelector('.material-player');
          if (blackLabel) {
            blackLabel.textContent = blackName;
          }
        }

        const summaryTable = byId('moveSummaryTable');
        if (summaryTable) {
          const whiteSummaryName = summaryTable.querySelector('.summary-player-card[data-color="w"] .summary-player-name');
          if (whiteSummaryName) {
            whiteSummaryName.textContent = whiteName;
          }
          const blackSummaryName = summaryTable.querySelector('.summary-player-card[data-color="b"] .summary-player-name');
          if (blackSummaryName) {
            blackSummaryName.textContent = blackName;
          }

          const headerCells = summaryTable.querySelectorAll('.summary-category-header .summary-category-value[data-color]');
          headerCells.forEach((cell) => {
            if (cell.dataset.color === 'w') {
              cell.textContent = whiteName;
            } else if (cell.dataset.color === 'b') {
              cell.textContent = blackName;
            }
          });
        }
      }

      const navToolbarManager = {
        buttons: [],
        isCompact: null,
        query: typeof window !== 'undefined' && window.matchMedia
          ? window.matchMedia('(max-width: 640px)')
          : null
      };

      let updateEvalBarHeight = () => { };
      let evalBarObserver = null;

      function updateNavToolbarLabels(force = false) {
        if (!navToolbarManager.buttons.length) return;
        const shouldCompact = navToolbarManager.query
          ? navToolbarManager.query.matches
          : window.innerWidth <= 640;
        if (!force && navToolbarManager.isCompact === shouldCompact) return;
        navToolbarManager.buttons.forEach((button) => {
          if (button.id === 'exploreToggle') {
            return;
          }
          if (!button.dataset.label) {
            button.dataset.label = button.textContent.trim();
          }
          const full = button.dataset.label || '';
          const compact = button.dataset.labelCompact || '';
          const nextLabel = shouldCompact && compact ? compact : full;
          if (nextLabel && button.textContent !== nextLabel) {
            button.textContent = nextLabel;
          } else if (!nextLabel && shouldCompact && full) {
            button.textContent = full;
          }
        });
        navToolbarManager.isCompact = shouldCompact;
      }

      function initNavToolbar() {
        const toolbar = document.querySelector('.nav-toolbar');
        if (!toolbar) return;
        navToolbarManager.buttons = Array.from(toolbar.querySelectorAll('button'));
        navToolbarManager.buttons.forEach((button) => {
          if (!button.dataset.label) {
            button.dataset.label = button.textContent.trim();
          }
        });
        updateNavToolbarLabels(true);
        if (navToolbarManager.query) {
          navToolbarManager.query.addEventListener('change', () => updateNavToolbarLabels(true));
        }
        window.addEventListener('resize', () => updateNavToolbarLabels(true));
      }

      function initEvalBarSync() {
        const boardWrap = document.querySelector('.board-wrap');
        const evalColumn = document.getElementById('evalColumn');
        if (!boardWrap || !evalColumn) return;
        const evalVertical = evalColumn.querySelector('.eval-vertical');
        if (!evalVertical) return;

        const applyHeight = () => {
          const rect = boardWrap.getBoundingClientRect();
          const height = Math.round(rect.height);
          if (height > 0) {
            evalColumn.style.height = `${height}px`;
          } else {
            evalColumn.style.height = '';
          }
          evalVertical.style.height = '100%';
        };

        updateEvalBarHeight = applyHeight;

        if (typeof ResizeObserver !== 'undefined') {
          if (evalBarObserver) {
            evalBarObserver.disconnect();
          }
          evalBarObserver = new ResizeObserver(() => applyHeight());
          evalBarObserver.observe(boardWrap);
        }

        applyHeight();
        requestAnimationFrame(() => applyHeight());
      }

      function syncBoardAndEval() {
        if (typeof updateEvalBarHeight === 'function') {
          updateEvalBarHeight();
          requestAnimationFrame(() => updateEvalBarHeight());
        }
      }

      window.addEventListener('resize', syncBoardAndEval);
      window.addEventListener('orientationchange', syncBoardAndEval);

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', syncBoardAndEval);
      } else {
        syncBoardAndEval();
      }

      requestAnimationFrame(() => {
        syncBoardAndEval();
      });

      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      const pieceNames = {
        p: 'pawn',
        n: 'knight',
        b: 'bishop',
        r: 'rook',
        q: 'queen',
        k: 'king'
      };

      function resetMoveTree() {
        state.nodeMap = new Map();
        state.rootNodeId = null;
        state.currentNodeId = null;
        state.lineSelections = new Map();
        state.mainlineSelections = new Map();
        state.nodeSeq = 0;
        state.verboseHistory = [];
      }

      function nextNodeId() {
        state.nodeSeq = (state.nodeSeq || 0) + 1;
        return `node-${state.nodeSeq}`;
      }

      function getNode(id) {
        if (!id) return null;
        return state.nodeMap.get(id) || null;
      }

      function getRootNode() {
        return getNode(state.rootNodeId);
      }

      function getCurrentNode() {
        return getNode(state.currentNodeId) || getRootNode();
      }

      function getPathToNode(nodeId) {
        const path = [];
        let cursor = getNode(nodeId);
        while (cursor) {
          path.push(cursor);
          if (!cursor.parentId) break;
          cursor = getNode(cursor.parentId);
        }
        return path.reverse();
      }

      function recomputeActiveLine() {
        const root = getRootNode();
        if (!root) {
          state.verboseHistory = [];
          return;
        }
        const visited = new Set([root.id]);
        const sequence = [];
        let cursor = root;
        while (cursor) {
          const nextId = state.lineSelections.get(cursor.id);
          if (!nextId) break;
          if (visited.has(nextId)) break;
          const nextNode = getNode(nextId);
          if (!nextNode) break;
          sequence.push(nextNode);
          visited.add(nextId);
          cursor = nextNode;
        }
        state.verboseHistory = sequence;
      }

      function getNodeIndexInActiveLine(nodeId) {
        if (!nodeId) return -1;
        for (let i = 0; i < state.verboseHistory.length; i++) {
          if (state.verboseHistory[i] && state.verboseHistory[i].id === nodeId) {
            return i;
          }
        }
        return -1;
      }

      function setActivePathToNode(nodeId) {
        const path = getPathToNode(nodeId);
        if (!path.length) return;
        for (let i = 0; i < path.length - 1; i++) {
          const parent = path[i];
          const child = path[i + 1];
          state.lineSelections.set(parent.id, child.id);
        }
        recomputeActiveLine();
      }

      function getMainlineChildId(nodeId) {
        return state.mainlineSelections.get(nodeId) || null;
      }

      function setMainlineChild(parentId, childId) {
        if (!parentId || !childId) return;
        state.mainlineSelections.set(parentId, childId);
      }

      function buildActiveLineFromSelections() {
        recomputeActiveLine();
      }

      function rejoinMainLine() {
        const current = getCurrentNode();
        let cursor = current;
        while (cursor && cursor.parentId) {
          const parent = getNode(cursor.parentId);
          if (!parent) break;
          const mainChild = getMainlineChildId(parent.id);
          if (mainChild && state.lineSelections.get(parent.id) !== mainChild) {
            state.lineSelections.set(parent.id, mainChild);
          }
          cursor = parent;
        }
        recomputeActiveLine();
        const maxPly = state.verboseHistory.length;
        const nextPly = Math.min(state.ply, maxPly);
        goToPly(nextPly);
        renderMoves();
        setSuggestionMode('played', { persist: false });
      }
      const pieceOrder = ['q', 'r', 'b', 'n', 'p'];
      const pieceLabels = { p: 'P', n: 'N', b: 'B', r: 'R', q: 'Q' };
      const inputHints = {
        pgn: 'Paste the full PGN for the game you want to analyze.',
        lichess: 'Paste a public Lichess game URL or ID. For best results run this page from http://localhost/.',
        fen: 'Paste a FEN string to analyze a specific position.'
      };
      const suggestionModeOptions = {
        played: {
          label: 'Current move',
          switchTitle: 'Switch to next move suggestions'
        },
        next: {
          label: 'Next move',
          switchTitle: 'Switch to current move review'
        }
      };
      const SHOW_LINE_CARD_KEYS = new Set(['idea', 'problem', 'solution']);
      const MULTIPV_MAX_CANDIDATES = 5;
      const PV_BEST_MARGIN = 0;
      const PV_KEEP_MARGIN = 0.02;
      const PV_ONLY_ONE_MARGIN = 0.10;
      const EP_GAP_BEST_MAX = PV_BEST_MARGIN;
      const EP_GAP_EXCELLENT_MAX = PV_KEEP_MARGIN;
      const EP_GAP_ONLY_ONE = PV_ONLY_ONE_MARGIN;
      const PV_MATE_SLACK = 1;
      const PV_EPSILON = 0.005;
      const GREAT_PHASE_DELTA = 0.15;
      const GREAT_BAND_LOSS_MAX = 0.35;
      const GREAT_BAND_WIN_MIN = 0.65;
      const GREAT_DECISIVE_MARGIN = 0.05;
      const GREAT_SWING_MIN_DELTA = 0.20;
      const GREAT_ONLY_MOVE_MIN_DELTA = 0.15;
      const DEFAULT_ANALYSIS_DEPTH = 20;
      const DEFAULT_ANALYSIS_MOVETIME = 2000;
      const classificationIconSet = new Set(['best', 'excellent', 'good', 'inaccuracy', 'mistake', 'blunder', 'brilliant', 'great', 'miss', 'book']);
      const enableSpecialPromotions = true;
      const NEAR_BEST_CP = 50;
      const ONLY_MOVE_GAP_CP = 150;
      const ONLY_MOVE_GAP_EP = 0.20;
      const ALREADY_WINNING_CP = 300;
      const NOT_BAD_TOLERANCE_CP = 50;
      const SAC_MIN_LOSS_POINTS = 2;
      const SAC_PIECE_LOSS_THRESHOLD = 3;
      const SAC_TWO_PLY_MIN_NET = 2;
      const BRILLIANT_MATE_SAC_MAX_DEPTH = 6;
      const isMate = (ev) => ev && typeof ev === 'object' && Object.prototype.hasOwnProperty.call(ev, 'mate');
      const mateForUs = (ev) => isMate(ev) && ev.mate > 0;
      const mateForThem = (ev) => isMate(ev) && ev.mate < 0;
      const moveSummaryCategories = [
        { key: 'brilliant', label: 'Brilliant', icon: './move-classifications/brilliant.png' },
        { key: 'great', label: 'Great', icon: './move-classifications/great.png' },
        { key: 'best', label: 'Best', icon: './move-classifications/best.png' },
        { key: 'excellent', label: 'Excellent', icon: './move-classifications/excellent.png' },
        { key: 'good', label: 'Good', icon: './move-classifications/good.png' },
        { key: 'inaccuracy', label: 'Inaccuracy', icon: './move-classifications/inaccuracy.png' },
        { key: 'mistake', label: 'Mistake', icon: './move-classifications/mistake.png' },
        { key: 'blunder', label: 'Blunder', icon: './move-classifications/blunder.png' },
        { key: 'miss', label: 'Miss', icon: './move-classifications/miss.png' }
      ];
      const GREAT_BAND_ORDER = { loss: 0, draw: 1, win: 2 };

      function clampExpectedPoints(ep) {
        if (!Number.isFinite(ep)) return null;
        if (ep <= 0) return 0;
        if (ep >= 1) return 1;
        return ep;
      }

      function getOutcomeBand(ep) {
        const value = clampExpectedPoints(ep);
        if (value == null) return null;
        if (value <= GREAT_BAND_LOSS_MAX) return 'loss';
        if (value >= GREAT_BAND_WIN_MIN) return 'win';
        return 'draw';
      }

      function isDecisiveEp(ep) {
        const value = clampExpectedPoints(ep);
        if (value == null) return false;
        return value <= GREAT_DECISIVE_MARGIN || value >= (1 - GREAT_DECISIVE_MARGIN);
      }

      function createPlayerMetric(labelText, role) {
        const metric = document.createElement('div');
        metric.className = 'summary-player-metric';
        const label = document.createElement('span');
        label.className = 'summary-metric-label';
        label.textContent = labelText;
        metric.appendChild(label);
        const value = document.createElement('span');
        value.className = 'summary-metric-value';
        value.dataset.role = role;
        value.textContent = '—';
        metric.appendChild(value);
        return metric;
      }

      function initMoveSummary() {
        const table = byId('moveSummaryTable');
        if (!table) return;
        table.innerHTML = '';
        const playersContainer = document.createElement('div');
        playersContainer.className = 'summary-player-grid';
        const players = [
          { color: 'w' },
          { color: 'b' }
        ];
        players.forEach((player) => {
          const card = document.createElement('div');
          card.className = 'summary-player-card';
          card.dataset.color = player.color;

          const header = document.createElement('div');
          header.className = 'summary-player-header';
          const playerName = document.createElement('span');
          playerName.className = 'summary-player-name';
          playerName.textContent = getPlayerDisplayName(player.color);
          header.appendChild(playerName);

          const eloLabel = document.createElement('span');
          eloLabel.className = 'summary-player-elo';
          eloLabel.dataset.role = 'elo';
          eloLabel.textContent = 'Elo —';
          header.appendChild(eloLabel);

          card.appendChild(header);

          const metrics = document.createElement('div');
          metrics.className = 'summary-player-metrics';
          metrics.appendChild(createPlayerMetric('Accuracy', 'accuracy'));
          metrics.appendChild(createPlayerMetric('Avg CPL', 'cpLoss'));
          card.appendChild(metrics);

          playersContainer.appendChild(card);
        });
        table.appendChild(playersContainer);

        const categoryGrid = document.createElement('div');
        categoryGrid.className = 'summary-category-grid';

        const headerRow = document.createElement('div');
        headerRow.className = 'summary-category-row summary-category-header';
        const categoryHeader = document.createElement('div');
        categoryHeader.className = 'summary-category-label';
        categoryHeader.textContent = 'Category';
        headerRow.appendChild(categoryHeader);
        ['w', 'b'].forEach((color) => {
          const headerCell = document.createElement('div');
          headerCell.className = 'summary-category-value';
          headerCell.dataset.color = color;
          headerCell.textContent = getPlayerDisplayName(color);
          headerRow.appendChild(headerCell);
        });
        categoryGrid.appendChild(headerRow);

        moveSummaryCategories.forEach((category) => {
          const row = document.createElement('div');
          row.className = 'summary-category-row';
          row.dataset.key = category.key;

          const labelCell = document.createElement('div');
          labelCell.className = 'summary-category-label';
          if (category.icon) {
            const icon = document.createElement('img');
            icon.src = category.icon;
            icon.alt = category.label;
            icon.className = 'summary-icon';
            labelCell.appendChild(icon);
          }
          const label = document.createElement('span');
          label.textContent = category.label;
          labelCell.appendChild(label);
          row.appendChild(labelCell);

          ['w', 'b'].forEach((color) => {
            const valueCell = document.createElement('div');
            valueCell.className = 'summary-category-value';
            valueCell.dataset.color = color;
            valueCell.dataset.key = category.key;
            valueCell.textContent = '—';
            row.appendChild(valueCell);
          });

          categoryGrid.appendChild(row);
        });

        table.appendChild(categoryGrid);
      }

      function createSummaryBucket() {
        const counts = {};
        moveSummaryCategories.forEach((category) => {
          counts[category.key] = 0;
        });
        return {
          counts,
          moves: 0,
          analyzedMoves: 0,
          accuracySum: 0,
          accuracyCount: 0,
          cpLossSum: 0,
          cpLossCount: 0
        };
      }

      function computeCpLoss(bestCp, actualCp, color) {
        if (!Number.isFinite(bestCp) || !Number.isFinite(actualCp)) return null;
        const clamp = (cp) => Math.max(-1000, Math.min(1000, cp));
        const best = clamp(bestCp);
        const actual = clamp(actualCp);
        if (color === 'b') {
          return Math.max(0, actual - best);
        }
        return Math.max(0, best - actual);
      }

      function computeMoveSummary() {
        const summary = {
          w: createSummaryBucket(),
          b: createSummaryBucket()
        };
        state.verboseHistory.forEach((entry) => {
          if (!entry) return;
          const color = entry.color === 'b' ? 'b' : 'w';
          const bucket = summary[color];
          bucket.moves++;
          if (!entry.analysis) return;
          bucket.analyzedMoves++;
          const displayClassification = getMoveDisplayClassification(entry.analysis);
          if (displayClassification && Object.prototype.hasOwnProperty.call(bucket.counts, displayClassification)) {
            bucket.counts[displayClassification] += 1;
          }
          const moveAccuracy = entry.analysis.accuracy;
          if (Number.isFinite(moveAccuracy)) {
            bucket.accuracySum += moveAccuracy;
            bucket.accuracyCount++;
          }
          const cpLoss = entry.analysis.cpLoss;
          if (Number.isFinite(cpLoss)) {
            bucket.cpLossSum += cpLoss;
            bucket.cpLossCount++;
          }
        });
        return summary;
      }

      function updateMoveSummary() {
        const table = byId('moveSummaryTable');
        if (!table) return;
        const summary = computeMoveSummary();
        ['w', 'b'].forEach((color) => {
          const card = table.querySelector(`.summary-player-card[data-color="${color}"]`);
          if (!card) return;
          const bucket = summary[color];
          const hasAnalysis = bucket.analyzedMoves > 0;

          const accuracyEl = card.querySelector('.summary-metric-value[data-role="accuracy"]');
          if (accuracyEl) {
            if (bucket.accuracyCount > 0) {
              const avgAccuracy = bucket.accuracySum / bucket.accuracyCount;
              accuracyEl.textContent = `${avgAccuracy.toFixed(1)}%`;
            } else {
              accuracyEl.textContent = '—';
            }
          }

          const cpLossEl = card.querySelector('.summary-metric-value[data-role="cpLoss"]');
          if (cpLossEl) {
            if (bucket.cpLossCount > 0) {
              const avgCpLoss = bucket.cpLossSum / bucket.cpLossCount;
              const formatted = Math.abs(avgCpLoss) < 1 ? avgCpLoss.toFixed(1) : avgCpLoss.toFixed(0);
              cpLossEl.textContent = formatted;
            } else {
              cpLossEl.textContent = '—';
            }
          }

          moveSummaryCategories.forEach((category) => {
            const cell = table.querySelector(`.summary-category-value[data-color="${color}"][data-key="${category.key}"]`);
            if (!cell) return;
            cell.textContent = hasAnalysis ? (bucket.counts[category.key] || 0) : '—';
          });
        });
        updateEloEstimates(summary);
      }

      function createBaseGame(fen = state.initialFen) {
        if (fen && fen !== 'start') {
          return new Chess(fen);
        }
        return new Chess();
      }

      function effectiveInitialFen() {
        return state.initialFen && state.initialFen !== 'start'
          ? state.initialFen
          : createBaseGame().fen();
      }

      function countPiecesOnBoard(boardMatrix) {
        const counts = {
          w: { p: 0, n: 0, b: 0, r: 0, q: 0, k: 0 },
          b: { p: 0, n: 0, b: 0, r: 0, q: 0, k: 0 }
        };
        for (const row of boardMatrix) {
          for (const piece of row) {
            if (!piece) continue;
            counts[piece.color][piece.type]++;
          }
        }
        return counts;
      }

      function initializePieceCounts() {
        const baseGame = createBaseGame();
        state.initialPieceCounts = countPiecesOnBoard(baseGame.board());
      }

      function decorateBoardSquares() {
        const boardEl = byId('board');
        if (!boardEl) return;
        const squares = boardEl.querySelectorAll('.square-55d63');
        squares.forEach((square) => {
          square.classList.add('square');
          if (square.classList.contains('white-1e1d7')) {
            square.classList.add('light');
            square.classList.remove('dark');
          } else if (square.classList.contains('black-3c85d')) {
            square.classList.add('dark');
            square.classList.remove('light');
          }
        });
      }

      function tagBoardPieces() {
        const boardEl = byId('board');
        if (!boardEl) return;
        const pieces = boardEl.querySelectorAll('img.piece');
        pieces.forEach((img) => {
          if (!img || typeof img.src !== 'string') return;
          const match = img.src.match(/\/([wb])[KQRBNP]\.png$/i);
          if (match && match[1]) {
            img.dataset.side = match[1] === 'b' ? 'b' : 'w';
          } else if (img.dataset.side) {
            delete img.dataset.side;
          }
        });
      }

      function scheduleBoardDecorations() {
        if (boardDecorationRaf != null) return;
        boardDecorationRaf = requestAnimationFrame(() => {
          boardDecorationRaf = null;
          decorateBoardSquares();
          tagBoardPieces();
        });
      }

      function setBoardPosition(fen) {
        if (!state.board) return;
        if (!fen || fen === 'start') {
          state.board.position('start');
        } else {
          state.board.position(fen);
        }
        scheduleBoardBadgeUpdate();
        scheduleBoardDecorations();
      }

      function updateBoardClassificationBadge() {
        const badge = byId('boardMoveBadge');
        const icon = byId('boardMoveBadgeIcon');
        const overlayIcon = byId('boardMoveBadgeOverlay');
        const boardEl = byId('board');
        if (!badge || !icon || !overlayIcon || !boardEl) return;

        badge.style.display = 'none';
        badge.removeAttribute('data-classification');
        badge.removeAttribute('data-overlay');
        icon.removeAttribute('src');
        icon.alt = '';
        overlayIcon.removeAttribute('src');
        overlayIcon.alt = '';
        overlayIcon.style.display = 'none';

        if (state.ply === 0) {
          return;
        }

        const entry = state.verboseHistory[state.ply - 1];
        if (!entry || !entry.analysis || !entry.to) {
          return;
        }

        const chosenClass = getMoveDisplayClassification(entry.analysis);
        if (!chosenClass) {
          return;
        }

        const iconPath = classificationToIcon(chosenClass);
        if (!iconPath) {
          return;
        }

        const squareEl = boardEl.querySelector(`[data-square="${entry.to}"]`);
        if (!squareEl) {
          return;
        }

        const boardRect = boardEl.getBoundingClientRect();
        const squareRect = squareEl.getBoundingClientRect();
        const badgeSize = 32;
        const margin = -12;
        const left = Math.max(0, squareRect.left - boardRect.left + squareRect.width - badgeSize - margin);
        const top = Math.max(0, squareRect.top - boardRect.top + margin);

        const normalizedClass = chosenClass.toLowerCase().replace(/\s+/g, '-');
        badge.style.left = `${left}px`;
        badge.style.top = `${top}px`;
        badge.setAttribute('data-classification', normalizedClass);
        icon.src = iconPath;
        icon.alt = chosenClass;
        const promotionTooltip = entry.analysis && entry.analysis.promotion && entry.analysis.promotion.tooltip
          ? entry.analysis.promotion.tooltip
          : null;
        if (promotionTooltip) {
          badge.title = promotionTooltip;
          icon.title = promotionTooltip;
        } else {
          badge.removeAttribute('title');
          icon.removeAttribute('title');
        }
        badge.removeAttribute('data-overlay');
        badge.style.display = 'flex';
      }

      function scheduleBoardBadgeUpdate() {
        if (state.badgeRaf != null) {
          cancelAnimationFrame(state.badgeRaf);
        }
        state.badgeRaf = requestAnimationFrame(() => {
          state.badgeRaf = null;
          updateBoardClassificationBadge();
        });
      }

      function formatMaterialScore(score) {
        if (score === 0) return '0';
        return score > 0 ? `+${score}` : `${score}`;
      }

      function sumMaterial(counts) {
        return (
          pieceValues.p * counts.p +
          pieceValues.n * counts.n +
          pieceValues.b * counts.b +
          pieceValues.r * counts.r +
          pieceValues.q * counts.q
        );
      }

      function findTopCapture(initialCounts, currentCounts) {
        if (!initialCounts || !currentCounts) return null;
        for (const type of pieceOrder) {
          const missing = (initialCounts[type] || 0) - (currentCounts[type] || 0);
          if (missing > 0) {
            const value = pieceValues[type];
            return `${pieceLabels[type]} (+${value})`;
          }
        }
        return null;
      }

      function updateMaterialDiff() {
        if (!state.game || !state.initialPieceCounts) return;
        const counts = countPiecesOnBoard(state.game.board());
        const whiteTotal = sumMaterial(counts.w);
        const blackTotal = sumMaterial(counts.b);
        const diff = whiteTotal - blackTotal;

        const whiteScoreEl = byId('materialWhite');
        const blackScoreEl = byId('materialBlack');
        if (whiteScoreEl) {
          whiteScoreEl.textContent = formatMaterialScore(diff);
          whiteScoreEl.classList.toggle('positive', diff > 0);
          whiteScoreEl.classList.toggle('negative', diff < 0);
        }
        if (blackScoreEl) {
          const blackScore = -diff;
          blackScoreEl.textContent = formatMaterialScore(blackScore);
          blackScoreEl.classList.toggle('positive', blackScore > 0);
          blackScoreEl.classList.toggle('negative', blackScore < 0);
        }

        const whiteCaptureEl = byId('materialWhiteCapture');
        const blackCaptureEl = byId('materialBlackCapture');
        if (whiteCaptureEl) {
          const capture = findTopCapture(state.initialPieceCounts.b, counts.b);
          whiteCaptureEl.textContent = capture ? `Top capture: ${capture}` : '—';
        }
        if (blackCaptureEl) {
          const capture = findTopCapture(state.initialPieceCounts.w, counts.w);
          blackCaptureEl.textContent = capture ? `Top capture: ${capture}` : '—';
        }
      }

      function encodeStateValue(value) {
        try {
          const bytes = encoder.encode(value);
          let binary = '';
          bytes.forEach((b) => { binary += String.fromCharCode(b); });
          return btoa(binary);
        } catch (err) {
          console.error('Failed to encode state', err);
          return '';
        }
      }

      function decodeStateValue(value) {
        try {
          const binary = atob(value);
          const bytes = Uint8Array.from(binary, (c) => c.charCodeAt(0));
          return decoder.decode(bytes);
        } catch (err) {
          console.error('Failed to decode state', err);
          return '';
        }
      }

      function updateUrlState() {
        const url = new URL(window.location);
        if (state.source) {
          url.searchParams.set('source', state.source);
        } else {
          url.searchParams.delete('source');
        }

        if (state.rawInput) {
          const encoded = encodeStateValue(state.rawInput);
          if (encoded) {
            url.searchParams.set('data', encoded);
          }
        } else {
          url.searchParams.delete('data');
        }

        if (state.ply > 0) {
          url.searchParams.set('ply', String(state.ply));
        } else {
          url.searchParams.delete('ply');
        }

        url.searchParams.delete('game');
        window.history.replaceState({}, '', url);
      }

      function setInputMode(mode) {
        const select = byId('inputMode');
        if (select && select.value !== mode) {
          select.value = mode;
        }
        updateInputModeUI(mode);
        updateLoadAffordanceState(mode);
      }

      function updateLoadAffordanceState(mode) {
        const group = byId('loadAffordanceGroup');
        if (!group) return;
        const buttons = group.querySelectorAll('button[data-load-action]');
        buttons.forEach((btn) => btn.classList.remove('active'));
        const normalized = mode === 'fen' ? 'fen' : mode === 'lichess' ? 'lichess' : 'paste';
        const target = group.querySelector(`button[data-load-action="${normalized}"]`);
        if (target) {
          target.classList.add('active');
        }
      }

      function updateInputModeUI(mode) {
        const input = byId('gameInput');
        const hint = byId('inputHint');
        if (!input) return;

        if (mode === 'lichess') {
          input.placeholder = 'https://lichess.org/abcdefg';
          input.rows = 2;
          input.classList.remove('mono');
        } else if (mode === 'fen') {
          input.placeholder = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
          input.rows = 3;
          input.classList.add('mono');
        } else {
          input.placeholder = 'Paste PGN text';
          input.rows = 8;
          input.classList.add('mono');
        }

        input.spellcheck = false;
        input.autocomplete = 'off';

        if (hint) {
          hint.textContent = inputHints[mode] || '';
        }
      }

      function persistPanelState(id, open) {
        if (typeof localStorage === 'undefined') return;
        try {
          localStorage.setItem(`panel:${id}`, open ? 'open' : 'closed');
        } catch (err) {
          // ignore storage failures
        }
      }

      function restorePanelState(id, defaultOpen = false) {
        if (typeof localStorage === 'undefined') {
          return !!defaultOpen;
        }
        try {
          const value = localStorage.getItem(`panel:${id}`);
          if (value === 'open') return true;
          if (value === 'closed') return false;
        } catch (err) {
          // ignore read failures
        }
        return !!defaultOpen;
      }

      function hasStoredPanelState(id) {
        if (typeof localStorage === 'undefined') {
          return false;
        }
        try {
          return localStorage.getItem(`panel:${id}`) != null;
        } catch (err) {
          return false;
        }
      }

      function shouldUseCompactInfoLayout() {
        if (!window.matchMedia) return false;
        return window.matchMedia('(max-width: 1199px)').matches;
      }

      function getSavedSuggestionMode() {
        if (typeof localStorage === 'undefined') {
          return 'played';
        }
        try {
          const saved = localStorage.getItem('suggestionMode');
          return saved === 'next' ? 'next' : 'played';
        } catch (err) {
          return 'played';
        }
      }

      function updateSuggestionModeUI() {
        const label = byId('suggestionModeLabel');
        const toggle = byId('suggestionToggle');
        const offLabel = byId('suggestionToggleOffLabel');
        const onLabel = byId('suggestionToggleOnLabel');
        const config = suggestionModeOptions[state.suggestionMode] || suggestionModeOptions.played;
        if (label) {
          label.textContent = config.label;
        }
        if (toggle) {
          const isNext = state.suggestionMode === 'next';
          toggle.checked = isNext;
          toggle.setAttribute('aria-checked', isNext ? 'true' : 'false');
          if (config.switchTitle) {
            toggle.setAttribute('title', config.switchTitle);
          } else {
            toggle.removeAttribute('title');
          }
        }
        if (offLabel) {
          const isActive = state.suggestionMode === 'played';
          offLabel.classList.toggle('active', isActive);
          offLabel.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        }
        if (onLabel) {
          const isActive = state.suggestionMode === 'next';
          onLabel.classList.toggle('active', isActive);
          onLabel.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        }
      }

      function setSuggestionMode(mode, options = {}) {
        const nextMode = suggestionModeOptions[mode] ? mode : 'played';
        state.suggestionMode = nextMode;
        updateSuggestionModeUI();
        const persist = options.persist !== false;
        if (persist) {
          try {
            if (typeof localStorage !== 'undefined') {
              localStorage.setItem('suggestionMode', nextMode);
            }
          } catch (err) {
            // ignore storage errors
          }
        }
        state.activeSuggestion = null;
        state.hoverSuggestion = null;
        state.suggestionData = [];
        redrawAllArrows([]);
        clearLineOverlay();
        applyAnalysisForCurrentPly();
      }

      function initSuggestionMode() {
        state.suggestionMode = getSavedSuggestionMode();
        updateSuggestionModeUI();
      }

      function initBoard() {
        state.board = Chessboard('board', {
          position: 'start',
          draggable: true,
          pieceTheme: 'chesspieces/wikipedia/{piece}.png',
          onDragStart: (source, piece) => {
            if (!state.exploreMode) return false;
            const turn = state.game ? state.game.turn() : 'w';
            if (turn === 'w' && piece.startsWith('b')) return false;
            if (turn === 'b' && piece.startsWith('w')) return false;
            return true;
          },
          onDrop: (source, target) => {
            if (!state.exploreMode) return 'snapback';
            if (source === target) return 'snapback';
            const fen = state.ply === 0
              ? effectiveInitialFen()
              : (state.verboseHistory[state.ply - 1] ? state.verboseHistory[state.ply - 1].fen : effectiveInitialFen());
            const game = createBaseGame(fen);
            const moveConfig = { from: source, to: target };
            const piece = game.get(source);
            if (piece && piece.type === 'p') {
              const targetRank = target[1];
              if ((piece.color === 'w' && targetRank === '8') || (piece.color === 'b' && targetRank === '1')) {
                moveConfig.promotion = 'q';
              }
            }
            const result = game.move(moveConfig);
            if (!result) return 'snapback';
            void handleUserBranchMove({ move: result, fen: game.fen(), previousFen: fen });
            return 'snapback';
          }
        });
        syncArrowLayer();
        initEvalBarSync();
        scheduleBoardDecorations();
        window.addEventListener('resize', () => {
          state.board.resize();
          syncArrowLayer();
          scheduleBoardBadgeUpdate();
          syncBoardAndEval();
          scheduleBoardDecorations();
        });
      }

      function isOnMainLine() {
        for (const [parentId, selectedId] of state.lineSelections.entries()) {
          const mainChild = getMainlineChildId(parentId);
          if (mainChild && selectedId && selectedId !== mainChild) {
            return false;
          }
        }
        return true;
      }

      function updateExploreToggleUI() {
        const btn = document.getElementById('exploreToggle');
        if (!btn) return;
        const on = Boolean(state.exploreMode);
        btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        btn.classList.toggle('is-on', on);
        btn.textContent = on ? '🧭 Explore: On' : '🧭 Explore: Off';
      }

      function updateExploreControls() {
        updateExploreToggleUI();
        const rejoin = byId('rejoinBtn');
        const reset = byId('exploreResetBtn');
        if (rejoin) {
          rejoin.hidden = isOnMainLine();
          rejoin.disabled = isOnMainLine();
        }
        if (reset) {
          reset.hidden = !state.exploreMode;
          reset.disabled = !state.exploreMode;
        }
        updateNavToolbarLabels(true);
      }

      function setExploreMode(enabled) {
        const nextMode = Boolean(enabled);
        const prevMode = state.exploreMode;
        state.exploreMode = nextMode;
        updateExploreControls();
        if (nextMode && !prevMode) {
          setSuggestionMode('next', { persist: false });
        } else if (!nextMode && prevMode) {
          setSuggestionMode('played', { persist: false });
        }
      }

      function toggleExploreMode() {
        setExploreMode(!state.exploreMode);
      }

      async function handleUserBranchMove({ move, fen, previousFen }) {
        const parent = state.ply === 0 ? getRootNode() : getNode(state.verboseHistory[state.ply - 1].id);
        if (!parent) return;
        if (!Array.isArray(parent.children)) {
          parent.children = [];
        }

        let existing = null;
        for (const childId of parent.children) {
          const child = getNode(childId);
          if (!child) continue;
          const sameMove = child.from === move.from && child.to === move.to;
          const samePromotion = (child.promotion || null) === (move.promotion || null);
          if (sameMove && samePromotion) {
            existing = child;
            break;
          }
        }

        if (existing) {
          setActivePathToNode(existing.id);
          const idx = getNodeIndexInActiveLine(existing.id);
          goToPly(idx + 1);
          renderMoves();
          return;
        }

        const nodeId = nextNodeId();
        const ply = (parent.ply || 0) + 1;
        const moveNumber = Math.floor((ply - 1) / 2) + 1;
        const newNode = {
          id: nodeId,
          parentId: parent.id,
          ply,
          moveNumber,
          mainline: false,
          san: move.san,
          uci: `${move.from}${move.to}${move.promotion || ''}`,
          from: move.from,
          to: move.to,
          fen,
          preFen: previousFen,
          color: move.color,
          piece: move.piece,
          captured: move.captured || null,
          promotion: move.promotion || null,
          flags: move.flags,
          analysis: null,
          eval: null,
          tags: null,
          label: null,
          children: []
        };

        parent.children.push(nodeId);
        if (!state.mainlineSelections.has(parent.id) && parent.children.length) {
          state.mainlineSelections.set(parent.id, parent.children[0]);
        }
        state.nodeMap.set(nodeId, newNode);
        state.lineSelections.set(parent.id, nodeId);
        setActivePathToNode(nodeId);
        const index = getNodeIndexInActiveLine(nodeId);
        goToPly(index + 1);
        renderMoves();

        const parentAnalysis = parent.analysis || state.analysisCache.get(parent.id) || null;
        const beforeEp = parentAnalysis && Number.isFinite(parentAnalysis.actualEp) ? parentAnalysis.actualEp : null;
        let legalMoves = [];
        try {
          const legalGame = new Chess(previousFen);
          legalMoves = legalGame.moves({ verbose: true });
        } catch (err) {
          legalMoves = [];
        }

        const token = nextAnalysisToken();
        state.analysisStatus = 'position';
        try {
          const result = await analyzeMoveEntry(newNode, {
            beforeEp,
            token,
            legalMoves,
            previousMoveEntry: parent,
            ensurePostAnalysis: true,
            computePlans: false
          });
          if (result && result.cancelled) {
            return;
          }
        } catch (err) {
          console.error('Failed to analyze explore move', err);
        } finally {
          state.analysisStatus = 'idle';
        }

        applyAnalysisForCurrentPly();
        renderMoves();
      }

      function syncArrowLayer() {
        const boardEl = byId('board');
        const svg = byId('arrowLayer');
        const rect = boardEl.getBoundingClientRect();
        svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.width}`);
        svg.setAttribute('width', rect.width);
        svg.setAttribute('height', rect.width);
        redrawAllArrows();
      }

      function setStatus(id, msg, type) {
        const el = byId(id);
        if (!el) return;
        el.textContent = msg || '';
        el.classList.remove('error', 'ok');
        if (type === 'error') el.classList.add('error');
        if (type === 'ok') el.classList.add('ok');
      }

      function renderBoardStatus() {
        const el = document.getElementById('boardStatus');
        if (!el) return;

        const totalPlies = Array.isArray(state.verboseHistory) ? state.verboseHistory.length : 0;
        const curPly = Math.max(0, Math.min(state.ply || 0, totalPlies));
        const moveNo = Math.max(1, Math.ceil(curPly / 2));
        const totalMoves = Math.max(1, Math.ceil(totalPlies / 2));
        const mover = state.game && typeof state.game.turn === 'function' && state.game.turn() === 'b' ? 'Black' : 'White';
        const evalLabel = state.lastEval ? formatEvalLabelFromString(state.lastEval) : '—';

        el.textContent = `Move ${moveNo} / ${totalMoves} • ${mover} to move • Eval ${evalLabel}`;
      }

      function extractGameId(input) {
        if (!input) return '';
        try {
          const url = new URL(input.trim());
          return url.pathname.split('/').filter(Boolean)[0] || '';
        } catch (e) {
          return input.trim();
        }
      }

      async function fetchPGN(input) {
        const id = extractGameId(input);
        if (!id) throw new Error('Please provide a Lichess URL or game ID.');
        const params = new URLSearchParams({
          moves: '1',
          tags: '1',
          clocks: '1',
          opening: '1',
          evals: '0',
          literate: '0'
        });
        const headers = { Accept: 'application/x-chess-pgn' };
        const res = await fetch(`https://lichess.org/game/export/${id}.pgn?${params.toString()}`, { headers });
        if (!res.ok) throw new Error(`HTTP ${res.status} – ${res.statusText}`);
        return res.text();
      }

      function populateHeaders(headers) {
        byId('tagWhite').textContent = headers.White || '—';
        byId('tagBlack').textContent = headers.Black || '—';
        byId('tagEvent').textContent = headers.Event || '—';
        byId('tagSite').textContent = headers.Site || '—';
        byId('tagDate').textContent = headers.Date || '—';
        byId('tagResult').textContent = headers.Result || '—';
        byId('tagOpening').textContent = headers.Opening || headers.ECO || '—';
      }

      function parseHeaders(pgn) {
        const out = {};
        const regex = /\[(\w+)\s+"([^"]*)"\]/g;
        let match;
        while ((match = regex.exec(pgn)) !== null) {
          out[match[1]] = match[2];
        }
        return out;
      }

      function buildHistory(game, initialFen) {
        const verbose = [];
        const temp = initialFen && initialFen !== 'start' ? new Chess(initialFen) : new Chess();
        const moves = game.history();
        for (const mv of moves) {
          const preFen = temp.fen();
          const played = temp.move(mv);
          if (played) {
            const uci = `${played.from}${played.to}${played.promotion || ''}`;
            verbose.push({ ...played, uci, fen: temp.fen(), preFen, eval: null, analysis: null });
          }
        }
        return verbose;
      }

      function createRootNode(fen) {
        return {
          id: nextNodeId(),
          parentId: null,
          fen,
          preFen: null,
          ply: 0,
          moveNumber: 0,
          children: [],
          mainline: true,
          san: null,
          uci: null,
          color: null,
          piece: null,
          captured: null,
          promotion: null,
          analysis: null,
          eval: null,
          tags: null,
          label: 'Main line'
        };
      }

      function buildMoveTree(verboseHistory, initialFen) {
        resetMoveTree();
        const baseGame = createBaseGame(initialFen);
        const rootFen = initialFen && initialFen !== 'start'
          ? initialFen
          : baseGame.fen();
        const rootNode = createRootNode(rootFen);
        state.nodeMap.set(rootNode.id, rootNode);
        state.rootNodeId = rootNode.id;
        state.currentNodeId = rootNode.id;

        let parent = rootNode;
        verboseHistory.forEach((entry, index) => {
          const nodeId = nextNodeId();
          const moveNode = {
            ...entry,
            id: nodeId,
            parentId: parent.id,
            ply: index + 1,
            moveNumber: Math.floor(index / 2) + 1,
            children: Array.isArray(entry.children) ? [...entry.children] : [],
            mainline: true,
            analysis: entry.analysis || null,
            eval: entry.eval || null,
            tags: entry.tags || null,
            label: entry.label || null,
            uci: entry.uci || (entry.from && entry.to ? `${entry.from}${entry.to}${entry.promotion || ''}` : null)
          };
          if (!Array.isArray(moveNode.children)) {
            moveNode.children = [];
          }
          state.nodeMap.set(nodeId, moveNode);
          parent.children.push(nodeId);
          setMainlineChild(parent.id, nodeId);
          state.lineSelections.set(parent.id, nodeId);
          parent = moveNode;
        });

        buildActiveLineFromSelections();
      }

      function classificationToIcon(classification) {
        if (!classification) return null;
        const file = classification.toLowerCase().replace(/\s+/g, '-');
        return classificationIconSet.has(file) ? `./move-classifications/${file}.png` : null;
      }

      function getMoveDisplayClassification(analysis) {
        if (!analysis) return null;
        return analysis.overlay || analysis.classification || null;
      }

      function renderMoves() {
        const container = byId('moves');
        if (!container) return;
        container.innerHTML = '';
        container.className = 'moves';

        const numberHeader = document.createElement('span');
        numberHeader.className = 'moves__hdr';
        numberHeader.textContent = '#';
        container.appendChild(numberHeader);

        const whiteHeader = document.createElement('span');
        whiteHeader.className = 'moves__hdr';
        whiteHeader.textContent = getPlayerDisplayName('w');
        container.appendChild(whiteHeader);

        const blackHeader = document.createElement('span');
        blackHeader.className = 'moves__hdr';
        blackHeader.textContent = getPlayerDisplayName('b');
        container.appendChild(blackHeader);

        const rows = [];
        state.verboseHistory.forEach((entry, index) => {
          if (!entry) return;
          const moveNumber = Math.floor(index / 2) + 1;
          if (!rows[moveNumber - 1]) {
            rows[moveNumber - 1] = { number: moveNumber, white: null, black: null };
          }
          if (entry.color === 'b') {
            rows[moveNumber - 1].black = entry;
          } else {
            rows[moveNumber - 1].white = entry;
          }
        });

        const createCell = (entry, color) => {
          if (!entry) {
            const placeholder = document.createElement('button');
            placeholder.type = 'button';
            placeholder.className = 'moves__cell';
            placeholder.disabled = true;
            placeholder.setAttribute('aria-hidden', 'true');
            const dash = document.createElement('span');
            dash.className = 'moves__placeholder';
            dash.textContent = '—';
            placeholder.appendChild(dash);
            return placeholder;
          }

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = `moves__cell moves__cell--${color}`;
          if (entry.id) {
            btn.dataset.nodeId = entry.id;
          }
          btn.dataset.ply = Number.isFinite(entry.ply) ? String(entry.ply) : '';

          const label = document.createElement('span');
          label.className = 'moves__label';

          const san = document.createElement('span');
          san.className = 'moves__san';
          san.textContent = entry.san || entry.uci || '';
          label.appendChild(san);

          const analysis = entry.analysis || (entry.id ? state.analysisCache.get(entry.id) : null);
          const chosenClass = getMoveDisplayClassification(analysis);
          if (chosenClass) {
            const iconPath = classificationToIcon(chosenClass);
            if (iconPath) {
              const icon = document.createElement('img');
              icon.src = iconPath;
              icon.alt = chosenClass;
              if (analysis && analysis.promotion && analysis.promotion.tooltip) {
                icon.title = analysis.promotion.tooltip;
              }
              icon.className = 'moves__icon';
              label.appendChild(icon);
            }
          }

          btn.appendChild(label);

          const evalText = entry.eval || (analysis && analysis.eval) || null;
          let postCpRaw = null;
          if (analysis && Number.isFinite(analysis.actualCp)) {
            postCpRaw = analysis.actualCp;
          } else if (analysis && analysis.actualEntry && Number.isFinite(analysis.actualEntry.cp)) {
            postCpRaw = analysis.actualEntry.cp;
          }
          if (postCpRaw == null && evalText) {
            const parsed = parseEvalToCp(evalText);
            if (parsed && parsed.type === 'cp') {
              postCpRaw = parsed.value;
            }
          }
          const postCp = clampFiniteCp(postCpRaw);
          const evalAfterLabel = postCp != null
            ? formatEvalAfterLabel(postCp)
            : formatEvalAfterLabel(evalText);

          let preCpRaw = null;
          let preEvalRaw = analysis && analysis.beforeEval ? analysis.beforeEval : null;
          if (analysis) {
            if (Number.isFinite(analysis.sfBefore)) {
              preCpRaw = analysis.sfBefore;
            } else if (Number.isFinite(analysis.bestCpBefore)) {
              preCpRaw = analysis.bestCpBefore;
            } else if (Number.isFinite(analysis.actualCpBefore)) {
              preCpRaw = analysis.actualCpBefore;
            } else if (Number.isFinite(analysis.beforeCp)) {
              preCpRaw = analysis.beforeCp;
            } else if (Number.isFinite(analysis.bestCp)) {
              preCpRaw = analysis.bestCp;
            }
            if (!preEvalRaw) {
              const summaryBestEval = analysis.summary && analysis.summary.best && analysis.summary.best.eval
                ? analysis.summary.best.eval
                : null;
              if (summaryBestEval) {
                preEvalRaw = summaryBestEval;
              } else if (analysis.bestEntry && analysis.bestEntry.eval) {
                preEvalRaw = analysis.bestEntry.eval;
              }
            }
          }

          let entryIndex = null;
          if (!Number.isFinite(entryIndex) && Number.isFinite(entry.ply)) {
            entryIndex = entry.ply - 1;
          }
          if (!Number.isFinite(entryIndex)) {
            entryIndex = state.verboseHistory.indexOf(entry);
          }
          if (!Number.isFinite(entryIndex)) {
            entryIndex = -1;
          }
          if ((preCpRaw == null || preEvalRaw == null) && entryIndex > 0) {
            const prevEntry = state.verboseHistory[entryIndex - 1];
            if (prevEntry) {
              const prevEval = prevEntry.eval
                || (prevEntry.analysis && prevEntry.analysis.eval)
                || (prevEntry.analysis && prevEntry.analysis.actualEntry && prevEntry.analysis.actualEntry.eval)
                || null;
              if (!preEvalRaw && prevEval) {
                preEvalRaw = prevEval;
              }
              if (preCpRaw == null && prevEval) {
                const parsedPrev = parseEvalToCp(prevEval);
                if (parsedPrev && parsedPrev.type === 'cp') {
                  preCpRaw = parsedPrev.value;
                }
              }
            }
          }

          const preCp = clampFiniteCp(preCpRaw);
          const postParsed = evalText ? parseEvalToCp(evalText) : null;
          const preParsed = preEvalRaw ? parseEvalToCp(preEvalRaw) : null;
          const isMateAfter = Boolean(
            (postParsed && postParsed.type === 'mate')
            || (Number.isFinite(postCpRaw) && Math.abs(postCpRaw) >= 10000)
          );
          const isMateBefore = Boolean(
            (preParsed && preParsed.type === 'mate')
            || (Number.isFinite(preCpRaw) && Math.abs(preCpRaw) >= 10000)
          );

          let changeText = '';
          if (!isMateBefore && !isMateAfter && preCp != null && postCp != null) {
            changeText = formatChangeArrow(postCp - preCp);
          }

          const metaEl = document.createElement('span');
          metaEl.className = 'moves__meta';
          metaEl.textContent = isMateAfter
            ? `Eval → ${evalAfterLabel}`
            : changeText
              ? `Eval → ${evalAfterLabel} · ${changeText}`
              : `Eval → ${evalAfterLabel}`;
          btn.appendChild(metaEl);

          btn.addEventListener('click', () => {
            if (entry.id) {
              setActivePathToNode(entry.id);
            }
            const ply = Number.isFinite(entry.ply) ? entry.ply : state.verboseHistory.indexOf(entry) + 1;
            goToPly(ply);
          });

          return btn;
        };

        rows.forEach((row) => {
          const numberCell = document.createElement('span');
          numberCell.className = 'moves__no';
          numberCell.textContent = `${row.number}.`;
          container.appendChild(numberCell);
          container.appendChild(createCell(row.white, 'white'));
          container.appendChild(createCell(row.black, 'black'));
        });

        highlightActive();
        updateMoveSummary();
        scheduleEvalChartUpdate({ recomputeData: true });
      }

      function highlightActive() {
        Array.from(document.querySelectorAll('.moves__cell')).forEach((el) => el.classList.remove('moves__cell--active'));
        const node = state.ply > 0 ? state.verboseHistory[state.ply - 1] : null;
        if (!node) return;
        const selector = node.id ? `.moves__cell[data-node-id="${node.id}"]` : `.moves__cell[data-ply="${node.ply}"]`;
        const el = document.querySelector(selector);
        if (el) el.classList.add('moves__cell--active');
      }

      function goToPly(ply) {
        const max = state.verboseHistory.length;
        state.ply = Math.max(0, Math.min(max, ply));
        const baseGame = createBaseGame();
        state.game = baseGame;
        clearLineOverlay();

        if (state.ply === 0) {
          setBoardPosition(state.initialFen);
          state.currentNodeId = state.rootNodeId;
        } else {
          for (let i = 0; i < state.ply; i++) {
            const mv = state.verboseHistory[i];
            state.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion });
          }
          const fen = state.verboseHistory[state.ply - 1].fen;
          setBoardPosition(fen);
          state.currentNodeId = state.verboseHistory[state.ply - 1].id;
        }

        highlightActive();
        updateMaterialDiff();
        applyAnalysisForCurrentPly();

        setStatus('navStatus', '');
        renderBoardStatus();
        updateUrlState();
        updateExploreControls();
        scheduleEvalChartUpdate();
      }

      function clearChildren(node) {
        if (!node) return;
        while (node.firstChild) {
          node.removeChild(node.firstChild);
        }
      }

      function getSquareCenterCoords(square, squareSize) {
        if (typeof square !== 'string' || square.length < 2) return null;
        const normalized = square.toLowerCase();
        const file = normalized.charCodeAt(0) - 97;
        const rank = Number.parseInt(normalized[1], 10) - 1;
        if (!Number.isFinite(file) || !Number.isFinite(rank)) return null;
        if (file < 0 || file > 7 || rank < 0 || rank > 7) return null;
        if (state.orientation === 'white') {
          return {
            x: (file + 0.5) * squareSize,
            y: ((7 - rank) + 0.5) * squareSize
          };
        }
        return {
          x: ((7 - file) + 0.5) * squareSize,
          y: (rank + 0.5) * squareSize
        };
      }

      function buildArrowGeometry(fromSquare, toSquare, squareSize, options = {}) {
        const from = getSquareCenterCoords(fromSquare, squareSize);
        const to = getSquareCenterCoords(toSquare, squareSize);
        if (!from || !to) return null;
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const len = Math.hypot(dx, dy);
        if (!len) return null;
        const unitX = dx / len;
        const unitY = dy / len;
        const perpX = -unitY;
        const perpY = unitX;
        const defaultHeadLength = Number.isFinite(options.headLength) ? options.headLength : 18;
        const headLength = Math.min(defaultHeadLength, len * 0.6);
        const headWidth = Number.isFinite(options.headWidth) ? options.headWidth : 12;
        const startOffset = Math.min(len * 0.1, squareSize * 0.35);
        const endOffset = Math.min(len * 0.15, headLength);
        const sx = from.x + unitX * startOffset;
        const sy = from.y + unitY * startOffset;
        const ex = to.x - unitX * endOffset;
        const ey = to.y - unitY * endOffset;
        const curvature = Number.isFinite(options.curvature) ? options.curvature : 0.28;
        const curveOffset = curvature * len;
        const cx1 = sx + unitX * (len / 3) + perpX * curveOffset;
        const cy1 = sy + unitY * (len / 3) + perpY * curveOffset;
        const cx2 = sx + unitX * (2 * len / 3) + perpX * curveOffset;
        const cy2 = sy + unitY * (2 * len / 3) + perpY * curveOffset;
        return {
          start: { x: sx, y: sy },
          end: { x: ex, y: ey },
          c1: { x: cx1, y: cy1 },
          c2: { x: cx2, y: cy2 },
          headLength,
          headWidth,
          unit: { x: unitX, y: unitY },
          length: len
        };
      }

      function renderArrowWithGeometry(layer, geometry, options = {}) {
        if (!layer || !geometry) return null;
        const stroke = options.stroke || 'var(--sgn-muted)';
        const strokeWidth = Number.isFinite(options.strokeWidth) ? options.strokeWidth : 8;
        const alpha = options.alpha != null ? options.alpha : 0.85;
        const dashed = options.dashed === true;
        const dashArray = options.dashArray || '8 8';

        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('opacity', alpha);
        if (options.zIndex != null) {
          group.style.zIndex = String(options.zIndex);
        }

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', `M ${geometry.start.x} ${geometry.start.y} C ${geometry.c1.x} ${geometry.c1.y} ${geometry.c2.x} ${geometry.c2.y} ${geometry.end.x} ${geometry.end.y}`);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', stroke);
        path.setAttribute('stroke-width', strokeWidth);
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');
        if (dashed) {
          path.setAttribute('stroke-dasharray', dashArray);
        }
        group.appendChild(path);

        const tangentX = geometry.end.x - geometry.c2.x;
        const tangentY = geometry.end.y - geometry.c2.y;
        let tangentLength = Math.hypot(tangentX, tangentY);
        if (!tangentLength) {
          tangentLength = Math.hypot(geometry.end.x - geometry.start.x, geometry.end.y - geometry.start.y) || 1;
        }
        const ux = tangentX / tangentLength;
        const uy = tangentY / tangentLength;
        const baseX = geometry.end.x - ux * geometry.headLength;
        const baseY = geometry.end.y - uy * geometry.headLength;
        const perpX = -uy;
        const perpY = ux;
        const halfWidth = geometry.headWidth / 2;
        const leftX = baseX + perpX * halfWidth;
        const leftY = baseY + perpY * halfWidth;
        const rightX = baseX - perpX * halfWidth;
        const rightY = baseY - perpY * halfWidth;
        const head = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        head.setAttribute('points', `${geometry.end.x},${geometry.end.y} ${leftX},${leftY} ${rightX},${rightY}`);
        head.setAttribute('fill', stroke);
        group.appendChild(head);

        layer.appendChild(group);
        return { group, geometry };
      }

      function pointOnCubicBezier(geometry, t) {
        const mt = 1 - t;
        const a = mt * mt * mt;
        const b = 3 * mt * mt * t;
        const c = 3 * mt * t * t;
        const d = t * t * t;
        return {
          x: a * geometry.start.x + b * geometry.c1.x + c * geometry.c2.x + d * geometry.end.x,
          y: a * geometry.start.y + b * geometry.c1.y + c * geometry.c2.y + d * geometry.end.y
        };
      }

      function getAccentColor() {
        try {
          const computed = getComputedStyle(document.documentElement);
          const value = computed.getPropertyValue('--accent');
          return value && value.trim() ? value.trim() : '#38bdf8';
        } catch (err) {
          return '#38bdf8';
        }
      }


      function ensureArrowLayer() {
        const ns = 'http://www.w3.org/2000/svg';
        const boardEl = byId('board');
        if (!boardEl || !boardEl.parentElement) return null;

        const host = boardEl.parentElement; // wrapper around the board
        if (getComputedStyle(host).position === 'static') {
          host.style.position = 'relative';
        }

        let svg = document.getElementById('arrowSvg');
        let baseLayer, overlayLayer, defs;

        // Create once
        if (!svg) {
          svg = document.createElementNS(ns, 'svg');
          svg.id = 'arrowSvg';
          svg.style.position = 'absolute';
          svg.style.inset = '0';
          svg.style.pointerEvents = 'none';
          svg.setAttribute('aria-hidden', 'true');
          host.appendChild(svg);

          defs = document.createElementNS(ns, 'defs');
          defs.id = 'arrowDefs';

          // One clean arrowhead that inherits the line color
          const head = document.createElementNS(ns, 'marker');
          head.id = 'arrowHead';
          head.setAttribute('viewBox', '0 0 12 12');
          head.setAttribute('refX', '10');
          head.setAttribute('refY', '6');
          head.setAttribute('markerUnits', 'strokeWidth');
          head.setAttribute('markerWidth', '6');
          head.setAttribute('markerHeight', '6');
          head.setAttribute('orient', 'auto');
          const headPath = document.createElementNS(ns, 'path');
          headPath.setAttribute('d', 'M0,0 L12,6 L0,12 Z');
          // modern browsers: arrow head fills with the line's stroke color
          headPath.setAttribute('fill', 'context-stroke');
          head.appendChild(headPath);
          defs.appendChild(head);

          // Smaller head for overlay / ghost preview
          const headSm = document.createElementNS(ns, 'marker');
          headSm.id = 'arrowHeadSm';
          headSm.setAttribute('viewBox', '0 0 12 12');
          headSm.setAttribute('refX', '9.5');
          headSm.setAttribute('refY', '6');
          headSm.setAttribute('markerUnits', 'strokeWidth');
          headSm.setAttribute('markerWidth', '5');
          headSm.setAttribute('markerHeight', '5');
          headSm.setAttribute('orient', 'auto');
          const headSmPath = document.createElementNS(ns, 'path');
          headSmPath.setAttribute('d', 'M0,0 L12,6 L0,12 Z');
          headSmPath.setAttribute('fill', 'context-stroke');
          headSm.appendChild(headSmPath);
          defs.appendChild(defs.appendChild(headSm));

          svg.appendChild(defs);

          baseLayer = document.createElementNS(ns, 'g');
          baseLayer.id = 'arrowBaseLayer';
          overlayLayer = document.createElementNS(ns, 'g');
          overlayLayer.id = 'arrowOverlayLayer';
          svg.appendChild(baseLayer);
          svg.appendChild(overlayLayer);
        }

        // Resize to match board every time we draw
        const rect = boardEl.getBoundingClientRect();
        const w = Math.max(1, Math.round(rect.width));
        const h = Math.max(1, Math.round(rect.height));
        svg.setAttribute('width', String(w));
        svg.setAttribute('height', String(h));
        svg.setAttribute('viewBox', `0 0 ${w} ${h}`);

        return {
          svg,
          baseLayer: document.getElementById('arrowBaseLayer'),
          overlayLayer: document.getElementById('arrowOverlayLayer')
        };
      }

      // Compute a straight segment from square centers, with a small gap at both ends
      function straightSegment(fromSquare, toSquare, squareSize, startGap = 8, endGap = 14) {
        const A = getSquareCenterCoords(fromSquare, squareSize);
        const B = getSquareCenterCoords(toSquare, squareSize);
        if (!A || !B) return null;

        const dx = B.x - A.x, dy = B.y - A.y;
        const L = Math.hypot(dx, dy);
        if (!L) return null;

        const ux = dx / L, uy = dy / L;
        const x1 = A.x + ux * Math.min(startGap, L * 0.10);
        const y1 = A.y + uy * Math.min(startGap, L * 0.10);
        const x2 = B.x - ux * Math.min(endGap, L * 0.14);
        const y2 = B.y - uy * Math.min(endGap, L * 0.14);

        return { x1, y1, x2, y2, length: L };
      }

      // Draw clean straight arrows for engine suggestions (colors come from your tone)
      function renderSuggestionArrows(suggestions = []) {
        const layers = ensureArrowLayer();
        if (!layers) return;
        const { baseLayer } = layers;
        clearChildren(baseLayer);

        const boardEl = byId('board');
        if (!boardEl) return;
        const rect = boardEl.getBoundingClientRect();
        const squareSize = rect.width / 8;

        const active = state.activeSuggestion;
        const hovering = state.hoverSuggestion;

        (suggestions || []).forEach((s) => {
          if (!s || typeof s.uci !== 'string' || s.uci.length < 4) return;
          const from = s.uci.slice(0, 2);
          const to = s.uci.slice(2, 4);
          const seg = straightSegment(from, to, squareSize);
          if (!seg) return;

          const tone = getSuggestionTone(s);
          const color = colorForTone(tone);

          const alpha = hovering
            ? (hovering === s.uci ? 0.95 : 0.30)
            : (active === s.uci ? 0.95 : (s.rank === 1 ? 0.90 : 0.65));

          const width = s.rank === 1 ? 8 : 7;

          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', seg.x1);
          line.setAttribute('y1', seg.y1);
          line.setAttribute('x2', seg.x2);
          line.setAttribute('y2', seg.y2);
          line.setAttribute('stroke', color);
          line.setAttribute('stroke-width', width);
          line.setAttribute('stroke-linecap', 'round');
          line.setAttribute('marker-end', 'url(#arrowHead)');
          line.setAttribute('opacity', alpha);
          baseLayer.appendChild(line);
        });
      }

      // Keep overlay straight too (supports dashed lines + numbering + ghost)
      function drawArrowOverlay(list) {
        const layers = ensureArrowLayer();
        if (!layers) return;
        const { overlayLayer } = layers;
        clearChildren(overlayLayer);

        const boardEl = byId('board');
        if (!boardEl) return;
        const rect = boardEl.getBoundingClientRect();
        const squareSize = rect.width / 8;

        const segments = Array.isArray(list) ? list : [];
        segments.forEach((segment) => {
          if (!segment || typeof segment.uci !== 'string' || segment.uci.length < 4) return;

          const from = segment.uci.slice(0, 2);
          const to = segment.uci.slice(2, 4);
          const seg = straightSegment(from, to, squareSize);
          if (!seg) return;

          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', seg.x1);
          line.setAttribute('y1', seg.y1);
          line.setAttribute('x2', seg.x2);
          line.setAttribute('y2', seg.y2);
          line.setAttribute('stroke', segment.color || '#94a3b8');
          line.setAttribute('stroke-width', Number.isFinite(segment.width) ? segment.width : 4);
          line.setAttribute('stroke-linecap', 'round');
          if (segment.dashed !== false) line.setAttribute('stroke-dasharray', segment.dashArray || '8 8');
          line.setAttribute('marker-end', 'url(#arrowHeadSm)');
          line.setAttribute('opacity', segment.opacity != null ? segment.opacity : 0.65);
          overlayLayer.appendChild(line);

          // Optional ordering bubble
          if (segment.showOrder && Number.isFinite(segment.order)) {
            const radius = segment.labelRadius != null
              ? segment.labelRadius
              : (Math.abs(segment.order) >= 10 ? 16 : 14);

            // Place label near the start of the segment
            const t = segment.labelPosition != null
              ? Math.min(0.85, Math.max(0.15, segment.labelPosition))
              : 0.18;

            const lx = seg.x1 + (seg.x2 - seg.x1) * t;
            const ly = seg.y1 + (seg.y2 - seg.y1) * t;

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.classList.add('arrow-label-circle');
            circle.setAttribute('cx', lx);
            circle.setAttribute('cy', ly);
            circle.setAttribute('r', radius);
            overlayLayer.appendChild(circle);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.classList.add('arrow-label-text');
            text.setAttribute('x', lx);
            text.setAttribute('y', ly);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('font-size', Math.abs(segment.order) >= 10 ? 13 : 14);
            text.textContent = String(segment.order);
            overlayLayer.appendChild(text);
          }
        });

        // Ghost preview (if set)
        if (hasGhostPreview()) {
          const preview = state.ghostPreview;
          const seg = straightSegment(preview.from, preview.to, squareSize, 8, 12);
          if (seg) {
            const accent = getAccentColor();

            const toCenter = getSquareCenterCoords(preview.to, squareSize);
            if (toCenter) {
              const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
              highlight.setAttribute('x', toCenter.x - squareSize / 2);
              highlight.setAttribute('y', toCenter.y - squareSize / 2);
              highlight.setAttribute('width', squareSize);
              highlight.setAttribute('height', squareSize);
              const corner = Math.min(12, squareSize * 0.25);
              highlight.setAttribute('rx', corner);
              highlight.setAttribute('ry', corner);
              highlight.setAttribute('fill', accent);
              highlight.setAttribute('opacity', 0.28);
              overlayLayer.appendChild(highlight);
            }

            const gLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            gLine.setAttribute('x1', seg.x1);
            gLine.setAttribute('y1', seg.y1);
            gLine.setAttribute('x2', seg.x2);
            gLine.setAttribute('y2', seg.y2);
            gLine.setAttribute('stroke', accent);
            gLine.setAttribute('stroke-width', 5);
            gLine.setAttribute('stroke-linecap', 'round');
            gLine.setAttribute('marker-end', 'url(#arrowHeadSm)');
            gLine.setAttribute('opacity', 0.45);
            overlayLayer.appendChild(gLine);
          }
        }
      }

      // Keep this helper; it now just calls our straight suggestions + overlay
      function redrawAllArrows(suggestions = null) {
        const active = Array.isArray(suggestions)
          ? suggestions
          : (Array.isArray(state.suggestionData) ? state.suggestionData : []);
        renderSuggestionArrows(active);
        drawArrowOverlay(state.lineOverlay);
      }

      function overlaysEqual(a, b) {
        if (!Array.isArray(a) || !Array.isArray(b)) return false;
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          const left = a[i] && a[i].uci;
          const right = b[i] && b[i].uci;
          if (left !== right) return false;
        }
        return true;
      }

      function overlayFromSeq(seq) {
        if (!Array.isArray(seq) || !seq.length) return [];
        const max = Math.min(seq.length, 12);
        const segments = [];
        for (let i = 0; i < max; i++) {
          const move = seq[i];
          if (typeof move !== 'string' || move.length < 4) continue;
          const normalized = move.toLowerCase();
          const opacity = Math.max(0.2, 0.85 - i * 0.08);
          segments.push({
            uci: normalized,
            dashed: true,
            opacity,
            width: 4,
            order: i + 1,
            showOrder: true
          });
        }
        return segments;
      }

      function uciSeqFromEntry(entry, limit = 8) {
        if (!entry) return [];
        if (Array.isArray(entry.pvMoves) && entry.pvMoves.length) {
          return entry.pvMoves
            .filter((mv) => typeof mv === 'string' && mv.length >= 4)
            .slice(0, limit)
            .map((mv) => mv.toLowerCase());
        }
        if (Array.isArray(entry.pvVerbose) && entry.pvVerbose.length) {
          const moves = [];
          for (let i = 0; i < entry.pvVerbose.length && moves.length < limit; i++) {
            const mv = entry.pvVerbose[i];
            if (!mv) continue;
            if (typeof mv.uci === 'string' && mv.uci.length >= 4) {
              moves.push(mv.uci.toLowerCase());
            } else if (typeof mv.from === 'string' && typeof mv.to === 'string') {
              const promotion = mv.promotion ? String(mv.promotion).toLowerCase() : '';
              moves.push(`${mv.from}${mv.to}${promotion}`.toLowerCase());
            }
          }
          if (moves.length) return moves;
        }
        if (typeof entry.uci === 'string' && entry.uci.length >= 4) {
          return [entry.uci.toLowerCase()];
        }
        return [];
      }

      function replyUciSeqFromEntry(entry, limit = 6) {
        if (!entry) return [];
        const base = uciSeqFromEntry(entry, limit + 1);
        if (!base.length) return [];
        return base.slice(1, limit + 1);
      }

      function getOverlaySequenceForKind(kind, analysis) {
        if (!analysis) return [];
        if (kind === 'idea') {
          const entry = analysis.actualEntry || analysis.bestEntry;
          return uciSeqFromEntry(entry, 10);
        }
        if (kind === 'problem') {
          const entry = analysis.actualEntry || analysis.bestEntry;
          return replyUciSeqFromEntry(entry, 10);
        }
        if (kind === 'solution') {
          const entry = analysis.bestEntry || analysis.actualEntry;
          return uciSeqFromEntry(entry, 10);
        }
        return [];
      }

      function hasLineOverlay() {
        return Array.isArray(state.lineOverlay) && state.lineOverlay.length > 0;
      }

      function hasGhostPreview() {
        return Boolean(state.ghostPreview && state.ghostPreview.from && state.ghostPreview.to);
      }

      function updateLineOverlayButton() {
        const actions = byId('explanationActions');
        const button = byId('clearLineOverlayBtn');
        const active = hasLineOverlay() || hasGhostPreview();
        if (actions) {
          actions.hidden = !active;
        }
        if (button) {
          button.disabled = !active;
        }
      }

      function refreshShowLineButtons(currentAnalysis = null) {
        const container = byId('explanationCards');
        if (!container) return;
        const buttons = container.querySelectorAll('button[data-action="show-line"]');
        if (!buttons.length) return;
        const analysis = currentAnalysis || getAnalysisForCurrentView();
        let overlayMatchesAny = false;
        buttons.forEach((btn) => {
          const kind = btn.dataset.kind;
          if (!kind) return;
          const seq = getOverlaySequenceForKind(kind, analysis);
          const hasSeq = Array.isArray(seq) && seq.length > 0;
          btn.disabled = !hasSeq;
          const defaultLabel = kind === 'problem' ? 'Show reply' : 'Show line';
          if (!hasSeq) {
            btn.classList.remove('active');
            btn.setAttribute('aria-pressed', 'false');
            btn.textContent = defaultLabel;
            return;
          }
          const overlay = overlayFromSeq(seq);
          const isActive = overlaysEqual(state.lineOverlay, overlay);
          if (isActive) overlayMatchesAny = true;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          btn.textContent = isActive ? 'Hide line' : defaultLabel;
        });
        if (!overlayMatchesAny && hasLineOverlay()) {
          state.lineOverlay = [];
          drawArrowOverlay([]);
          updateLineOverlayButton();
        }
      }

      function updateGhostTokenState() {
        const activeSan = state.ghostPreview && state.ghostPreview.san ? state.ghostPreview.san : null;
        const tokens = document.querySelectorAll('.pv-move-token');
        tokens.forEach((token) => {
          if (!token || !token.dataset) return;
          const san = token.dataset.san || '';
          token.classList.toggle('active', Boolean(activeSan) && san === activeSan);
        });
      }

      function clearGhostPreview() {
        if (!state.ghostPreview) return;
        state.ghostPreview = null;
        drawArrowOverlay(state.lineOverlay);
        updateGhostTokenState();
        updateLineOverlayButton();
      }

      function showGhostPreview(preview) {
        if (!preview || !preview.from || !preview.to) return;
        state.ghostPreview = {
          from: preview.from,
          to: preview.to,
          san: preview.san || null
        };
        drawArrowOverlay(state.lineOverlay);
        updateGhostTokenState();
        updateLineOverlayButton();
      }

      function previewContinuationSan(san) {
        if (!san) return;
        if (state.ghostPreview && state.ghostPreview.san === san) {
          clearGhostPreview();
          return;
        }
        const baseFen = state.game ? state.game.fen() : effectiveInitialFen();
        let game;
        try {
          game = new Chess(baseFen);
        } catch (err) {
          return;
        }
        let move = null;
        try {
          move = game.move(san);
        } catch (err) {
          move = null;
        }
        if (!move || !move.from || !move.to) return;
        showGhostPreview({
          from: move.from,
          to: move.to,
          san: move.san || san
        });
      }

      function handleContinuationTokenInteraction(event) {
        const token = event.target.closest('.pv-move-token');
        if (!token) return false;
        const san = token.dataset ? token.dataset.san : null;
        if (!san) return false;
        event.preventDefault();
        previewContinuationSan(san);
        token.focus();
        return true;
      }

      function handleDocumentClickForGhost(event) {
        if (!hasGhostPreview()) return;
        const token = event.target.closest('.pv-move-token');
        if (token) return;
        clearGhostPreview();
      }

      function handleDocumentKeydown(event) {
        if (event.key === 'Escape' && hasGhostPreview()) {
          clearGhostPreview();
          return;
        }
        const target = event.target;
        const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
        const type = target && target.type ? target.type.toLowerCase() : '';
        const isEditable = target && (target.isContentEditable
          || tag === 'textarea'
          || tag === 'select'
          || (tag === 'input' && !['button', 'checkbox', 'radio', 'range', 'color'].includes(type)));
        if (isEditable) return;
        const isButtonLike = target && (tag === 'button' || target.closest('button, [role="button"]'));
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          goToPly(state.ply - 1);
          return;
        }
        if (event.key === 'ArrowRight') {
          event.preventDefault();
          goToPly(state.ply + 1);
          return;
        }
        if (event.key === ' ' && !isButtonLike) {
          event.preventDefault();
          setEnginePaused(!state.enginePaused);
          return;
        }
        if ((event.key === 'e' || event.key === 'E') && !isButtonLike) {
          event.preventDefault();
          const card = byId('engineExplanationCard');
          if (card) {
            card.open = !card.open;
            persistPanelState('engineExplanationCard', card.open);
          }
        }
      }

      function setLineOverlay(segments, options = {}) {
        const analysis = options && options.analysis ? options.analysis : null;
        if (!Array.isArray(segments) || !segments.length) {
          state.lineOverlay = [];
        } else {
          state.lineOverlay = segments
            .filter((seg) => seg && typeof seg.uci === 'string' && seg.uci.length >= 4)
            .map((seg, index) => ({
              uci: seg.uci.toLowerCase(),
              dashed: seg.dashed !== false,
              opacity: seg.opacity,
              width: seg.width,
              color: seg.color,
              dashArray: seg.dashArray,
              order: Number.isFinite(seg.order) ? seg.order : index + 1,
              showOrder: Boolean(seg.showOrder),
              labelPosition: typeof seg.labelPosition === 'number' ? seg.labelPosition : null,
              labelOffset: Number.isFinite(seg.labelOffset) ? seg.labelOffset : null,
              labelRadius: Number.isFinite(seg.labelRadius) ? seg.labelRadius : null,
              labelFontSize: Number.isFinite(seg.labelFontSize) ? seg.labelFontSize : null
            }));
        }
        drawArrowOverlay(state.lineOverlay);
        updateLineOverlayButton();
        refreshShowLineButtons(analysis);
      }

      function clearLineOverlay(options = {}) {
        const hadOverlay = hasLineOverlay();
        const hadGhost = hasGhostPreview();
        if (hadOverlay) {
          setLineOverlay([], options);
        } else {
          updateLineOverlayButton();
          refreshShowLineButtons(options && options.analysis ? options.analysis : null);
        }
        if (hadGhost) {
          clearGhostPreview();
        }
      }

      function handleExplanationCardClick(event) {
        if (handleContinuationTokenInteraction(event)) return;
        const btn = event.target.closest('button[data-action="show-line"]');
        if (!btn || btn.disabled) return;
        const kind = btn.dataset.kind;
        if (!kind) return;
        const analysis = getAnalysisForCurrentView();
        if (!analysis) {
          refreshShowLineButtons(null);
          return;
        }
        const seq = getOverlaySequenceForKind(kind, analysis);
        if (!Array.isArray(seq) || !seq.length) {
          refreshShowLineButtons(analysis);
          return;
        }
        const overlay = overlayFromSeq(seq);
        if (!overlay.length) {
          refreshShowLineButtons(analysis);
          return;
        }
        if (overlaysEqual(state.lineOverlay, overlay)) {
          clearLineOverlay({ analysis });
        } else {
          setLineOverlay(overlay, { analysis });
        }
        btn.blur();
      }

      function uciToSan(fen, uci) {
        try {
          const game = new Chess(fen);
          const move = {
            from: uci.slice(0, 2),
            to: uci.slice(2, 4),
            promotion: uci.length > 4 ? uci[4] : undefined
          };
          const played = game.move(move);
          return played && played.san ? played.san : uci;
        } catch (e) {
          return uci;
        }
      }

      function parseEvalString(evalStr) {
        if (!evalStr) return null;
        if (evalStr.startsWith('#')) {
          const mate = parseInt(evalStr.slice(1), 10);
          if (Number.isNaN(mate)) return null;
          return { type: 'mate', value: mate };
        }
        const pawns = parseFloat(evalStr);
        if (Number.isNaN(pawns)) return null;
        return { type: 'cp', pawns, cp: pawns * 100 };
      }

      function parseEvalToCp(evalStr) {
        const parsed = parseEvalString(evalStr);
        if (!parsed) return null;
        if (parsed.type === 'mate') return { type: 'mate', value: parsed.value };
        if (parsed.type === 'cp') return { type: 'cp', value: parsed.cp };
        return null;
      }

      function formatCpAsPawns(cp) {
        return `${cp >= 0 ? '+' : '−'}${(Math.abs(cp) / 100).toFixed(2)}`;
      }

      function formatEvalAfterLabel(evalStrOrCp) {
        if (typeof evalStrOrCp === 'number') {
          return `${evalStrOrCp >= 0 ? '+' : '−'}${(Math.abs(evalStrOrCp) / 100).toFixed(2)}`;
        }
        const parsed = parseEvalString(evalStrOrCp);
        if (!parsed) return '—';
        if (parsed.type === 'mate') {
          return `${parsed.value >= 0 ? '+M' : '−M'}${Math.abs(parsed.value)}`;
        }
        return `${parsed.value >= 0 ? '+' : '−'}${(Math.abs(parsed.value) / 100).toFixed(2)}`;
      }

      function clampFiniteCp(v) {
        return (Number.isFinite(v) && Math.abs(v) < 10000) ? v : null;
      }

      function formatChangeArrow(diffCp) {
        if (!Number.isFinite(diffCp)) return '';
        if (diffCp > 0.5) return `↗️ ${formatCpAsPawns(diffCp)}`;
        if (diffCp < -0.5) return `↘️ ${formatCpAsPawns(diffCp)}`;
        return `→ ${formatCpAsPawns(0)}`;
      }

      function normalizeEvalForMover(evalStr, moverIsWhite) {
        const parsed = parseEvalString(evalStr);
        if (!parsed) return null;
        if (parsed.type === 'mate') {
          const mate = moverIsWhite ? parsed.value : -parsed.value;
          return { mate };
        }
        const cp = moverIsWhite ? parsed.cp : -parsed.cp;
        return { cp };
      }

      function evalStringToCentipawns(evalStr) {
        const parsed = parseEvalString(evalStr);
        if (!parsed) return null;
        if (parsed.type === 'mate') {
          return parsed.value > 0 ? 10000 : -10000;
        }
        return parsed.cp;
      }

      function formatEval(pawns) {
        if (!Number.isFinite(pawns)) return '0.00';
        if (pawns === 0) return '0.00';
        return pawns > 0 ? `+${pawns.toFixed(2)}` : pawns.toFixed(2);
      }

      function formatEvalLabelFromString(evalStr) {
        if (!evalStr) return '—';
        const parsed = parseEvalString(evalStr);
        if (!parsed) return '—';
        if (parsed.type === 'mate') {
          const prefix = parsed.value >= 0 ? '+' : '-';
          return `${prefix}M${Math.abs(parsed.value)}`;
        }
        return formatEval(parsed.pawns);
      }

      function sideToMoveFromFen(fen) {
        if (typeof fen !== 'string') return 'w';
        const parts = fen.trim().split(/\s+/);
        return parts[1] === 'b' ? 'b' : 'w';
      }

      function centipawnsToBarPercent(cp) {
        if (!Number.isFinite(cp)) return 50;
        const scaled = Math.tanh(cp / 600);
        return 50 + 50 * scaled;
      }

      function updateEvalBar(evalStr) {
        state.lastEval = evalStr || null;
        const fillEl = byId('evalFill');
        const markerEl = byId('evalMarker');
        const scoreEl = byId('evalScoreLabel');
        const columnEl = byId('evalColumn');
        const orientation = state.orientation || 'white';

        if (columnEl) {
          columnEl.dataset.orientation = orientation;
        }

        let normalized = 0.5;
        let whiteDisplay = '—';

        if (evalStr) {
          const parsed = parseEvalString(evalStr);
          if (parsed) {
            if (parsed.type === 'mate') {
              const mate = parsed.value;
              const moves = Math.abs(mate);
              const prefix = mate >= 0 ? '+' : '-';
              whiteDisplay = `${prefix}M${moves}`;
              if (mate === 0) {
                normalized = 0.5;
              } else {
                normalized = mate > 0 ? 0.99 : 0.01;
              }
            } else {
              const pawns = parsed.pawns;
              whiteDisplay = formatEval(pawns);
              const percent = centipawnsToBarPercent(parsed.cp);
              normalized = percent / 100;
            }
          }
        }

        const clampedWhite = Math.min(0.98, Math.max(0.02, normalized));
        const clampedBlack = Math.min(0.98, Math.max(0.02, 1 - normalized));

        if (scoreEl) {
          scoreEl.textContent = whiteDisplay;
          scoreEl.setAttribute('aria-label', `Evaluation ${whiteDisplay}`);
        }

        if (fillEl) {
          const fillPercent = orientation === 'white' ? clampedWhite : clampedBlack;
          fillEl.style.height = `${(fillPercent * 100).toFixed(1)}%`;
          fillEl.style.bottom = '0';
          fillEl.style.top = 'auto';
        }

        if (markerEl) {
          const markerPercent = orientation === 'white'
            ? (1 - clampedWhite) * 100
            : clampedWhite * 100;
          markerEl.style.top = `${markerPercent.toFixed(1)}%`;
          markerEl.style.bottom = 'auto';
          if (scoreEl) {
            const labelPercent = Math.min(96, Math.max(4, markerPercent));
            scoreEl.style.top = `${labelPercent.toFixed(1)}%`;
          }
        } else if (scoreEl) {
          const midpoint = orientation === 'white' ? 50 : 50;
          scoreEl.style.top = `${midpoint}%`;
        }
        renderBoardStatus();
      }

      function normalizeEvalChartMode(mode) {
        return EVAL_CHART_MODES.includes(mode) ? mode : 'cp';
      }

      function getSavedEvalChartMode() {
        try {
          const stored = localStorage.getItem(EVAL_CHART_MODE_STORAGE_KEY);
          return normalizeEvalChartMode(stored);
        } catch (err) {
          return 'cp';
        }
      }

      function updateEvalChartModeUI() {
        const card = byId('evalChartCard');
        if (!card) return;
        const buttons = card.querySelectorAll('.eval-chart-mode');
        buttons.forEach((button) => {
          if (!button || !button.dataset) return;
          const mode = button.dataset.mode;
          const active = mode === state.evalChartMode;
          button.classList.toggle('active', active);
          button.setAttribute('aria-pressed', active ? 'true' : 'false');
        });
      }

      function setEvalChartMode(mode, options = {}) {
        const normalized = normalizeEvalChartMode(mode);
        state.evalChartMode = normalized;
        updateEvalChartModeUI();
        if (options.persist !== false) {
          try {
            localStorage.setItem(EVAL_CHART_MODE_STORAGE_KEY, normalized);
          } catch (err) {
            // ignore storage errors
          }
        }
        scheduleEvalChartUpdate();
      }

      function getEvalChartTheme() {
        const root = document.documentElement;
        const styles = root ? getComputedStyle(root) : null;
        const read = (name, fallback) => {
          if (!styles) return fallback;
          const value = styles.getPropertyValue(name);
          return value && value.trim() ? value.trim() : fallback;
        };
        return {
          line: read('--eval-chart-line', '#38bdf8'),
          fillWhite: read('--eval-chart-fill-white', 'rgba(248, 250, 252, 0.16)'),
          fillBlack: read('--eval-chart-fill-black', 'rgba(8, 15, 35, 0.35)'),
          axis: read('--eval-chart-axis', 'rgba(148, 163, 184, 0.32)'),
          grid: read('--eval-chart-grid', 'rgba(148, 163, 184, 0.16)'),
          accent: read('--accent', '#38bdf8'),
          markers: {
            brilliant: read('--eval-chart-marker-brilliant', '#2dd4bf'),
            great: read('--eval-chart-marker-great', '#fbbf24'),
            blunder: read('--eval-chart-marker-blunder', '#f87171'),
            mistake: read('--eval-chart-marker-mistake', '#facc15'),
            inaccuracy: read('--eval-chart-marker-inaccuracy', '#94a3b8'),
            best: read('--eval-chart-marker-best', '#4ade80'),
            excellent: read('--eval-chart-marker-excellent', '#38bdf8')
          }
        };
      }

      function getPointClassTag(analysis) {
        if (!analysis) return null;
        const overlay = typeof analysis.overlay === 'string' ? analysis.overlay.toLowerCase() : null;
        if (overlay === 'brilliant' || overlay === 'great') {
          return overlay;
        }
        const classification = typeof analysis.classification === 'string' ? analysis.classification.toLowerCase() : null;
        if (classification) {
          return classification;
        }
        const baseline = typeof analysis.baseline === 'string' ? analysis.baseline.toLowerCase() : null;
        return baseline || null;
      }

      function buildEvalChartPoints() {
        const history = Array.isArray(state.verboseHistory) ? state.verboseHistory : [];
        const points = [];
        history.forEach((entry, index) => {
          if (!entry) return;
          const analysis = entry.analysis || (entry.id ? state.analysisCache.get(entry.id) : null);
          const ply = Number.isFinite(entry.ply) ? entry.ply : index + 1;
          const moveNumber = Math.max(1, Math.ceil(ply / 2));
          const moveColor = entry.color === 'b' ? 'b' : 'w';
          const mover = moveColor === 'w' ? 'b' : 'w';

          let evalSource = typeof entry.eval === 'string' ? entry.eval : null;
          if (!evalSource && analysis && analysis.actualEntry && typeof analysis.actualEntry.eval === 'string') {
            evalSource = analysis.actualEntry.eval;
          }

          let cp = null;
          let mate = null;
          if (evalSource) {
            const parsed = parseEvalToCp(evalSource);
            if (parsed) {
              if (parsed.type === 'mate') {
                mate = parsed.value;
              } else if (parsed.type === 'cp') {
                cp = parsed.value;
              }
            }
          }
          if (cp == null && analysis) {
            if (Number.isFinite(analysis.actualCp)) {
              cp = analysis.actualCp;
            } else if (analysis.actualEntry && Number.isFinite(analysis.actualEntry.cp)) {
              cp = analysis.actualEntry.cp;
            }
          }
          if (cp != null) {
            cp = clampFiniteCp(cp);
          }
          if (!Number.isFinite(cp)) {
            cp = null;
          }
          if (!Number.isFinite(mate)) {
            mate = null;
          }

          const fenAfter = typeof entry.fen === 'string' ? entry.fen : null;
          let epWhite = null;
          if (analysis && analysis.actualEntry) {
            const epMover = expectedPointsForMover(analysis.actualEntry, fenAfter, mover);
            if (Number.isFinite(epMover)) {
              epWhite = mover === 'w' ? epMover : 1 - epMover;
            }
          }
          if (!Number.isFinite(epWhite)) {
            const fallbackEntry = {};
            if (analysis && analysis.actualEntry && analysis.actualEntry.wdl) {
              fallbackEntry.wdl = analysis.actualEntry.wdl;
            } else if (entry.wdl) {
              fallbackEntry.wdl = entry.wdl;
            }
            if (evalSource) {
              fallbackEntry.eval = evalSource;
            }
            const epMover = expectedPointsForMover(fallbackEntry, fenAfter, mover);
            if (Number.isFinite(epMover)) {
              epWhite = mover === 'w' ? epMover : 1 - epMover;
            }
          }
          if (!Number.isFinite(epWhite) && Number.isFinite(cp)) {
            const ep = cpToExpectedPoints(cp);
            if (Number.isFinite(ep)) {
              epWhite = ep;
            }
          }
          if (!Number.isFinite(epWhite)) {
            epWhite = null;
          } else {
            epWhite = Math.max(0, Math.min(1, epWhite));
          }

          const classTagRaw = getPointClassTag(analysis);
          const classTag = classTagRaw ? classTagRaw.toLowerCase() : null;

          points.push({
            index,
            ply,
            moveNumber,
            moveColor,
            mover,
            san: entry.san || entry.uci || '',
            cp,
            mate,
            whiteEp: epWhite,
            winPercent: epWhite != null ? epWhite * 100 : null,
            classTag,
            entry,
            analysis
          });
        });

        for (let i = 0; i < points.length; i += 1) {
          const point = points[i];
          const prev = i > 0 ? points[i - 1] : null;
          point.deltaCp = Number.isFinite(point.cp) && prev && Number.isFinite(prev.cp)
            ? point.cp - prev.cp
            : null;
          point.deltaWinPercent = Number.isFinite(point.winPercent) && prev && Number.isFinite(prev.winPercent)
            ? point.winPercent - prev.winPercent
            : null;
        }

        return points;
      }

      function scheduleEvalChartUpdate({ recomputeData = false } = {}) {
        if (recomputeData) {
          state.evalChartDataDirty = true;
        }
        if (evalChartRaf != null) return;
        evalChartRaf = requestAnimationFrame(() => {
          evalChartRaf = null;
          renderEvalChart();
        });
      }

      function hideEvalChartTooltip() {
        const tooltip = byId('evalChartTooltip');
        if (!tooltip) return;
        tooltip.style.display = 'none';
        tooltip.setAttribute('aria-hidden', 'true');
      }

      function formatEvalChartValue(point, mode) {
        if (mode === 'win') {
          if (Number.isFinite(point.winPercent)) {
            return formatWinPercentDisplay(point.winPercent) || `${point.winPercent.toFixed(1)}%`;
          }
          if (Number.isFinite(point.mate)) {
            return point.mate > 0 ? '100%' : '0%';
          }
          return '—';
        }
        if (Number.isFinite(point.mate)) {
          const prefix = point.mate >= 0 ? '+M' : '−M';
          return `${prefix}${Math.abs(point.mate)}`;
        }
        if (Number.isFinite(point.cp)) {
          return formatEvalAfterLabel(point.cp);
        }
        return '—';
      }

      function formatEvalChartDelta(point, mode) {
        if (mode === 'win') {
          const delta = point.deltaWinPercent;
          if (!Number.isFinite(delta)) return null;
          const absDelta = Math.abs(delta);
          const diffText = formatWinDeltaDisplay(absDelta) || `${absDelta.toFixed(1)}%`;
          const minus = '\u2212';
          const sign = delta > 0 ? '+' : delta < 0 ? minus : '';
          const arrow = delta > 0 ? '↗︎' : delta < 0 ? '↘︎' : '→';
          const className = delta > 0 ? 'positive' : delta < 0 ? 'negative' : '';
          const textValue = delta === 0 ? '0%' : `${sign}${diffText.replace(/^[+\-−]/, '')}`;
          return { text: `${arrow} ${textValue}`, className };
        }
        const delta = point.deltaCp;
        if (!Number.isFinite(delta)) return null;
        const pawns = delta / 100;
        const decimals = Math.abs(pawns) >= 1 ? 1 : 2;
        const formatted = pawns.toFixed(decimals);
        const arrow = delta > 0 ? '↗︎' : delta < 0 ? '↘︎' : '→';
        const className = delta > 0 ? 'positive' : delta < 0 ? 'negative' : '';
        const textValue = delta === 0 ? '+0.00' : `${delta > 0 ? '+' : ''}${formatted}`;
        return { text: `${arrow} ${textValue}`, className };
      }

      function buildEvalChartTooltipContent(point) {
        const tooltip = byId('evalChartTooltip');
        if (!tooltip) return;
        tooltip.innerHTML = '';
        const mode = normalizeEvalChartMode(state.evalChartMode);
        const moveRow = document.createElement('div');
        moveRow.className = 'eval-chart-tooltip__move';
        const san = point.entry && point.entry.san ? point.entry.san : (point.entry && point.entry.uci ? point.entry.uci : '');
        moveRow.textContent = `Move ${point.moveNumber}${point.moveColor === 'b' ? '…' : '.'} ${san}`;
        tooltip.appendChild(moveRow);

        const evalRow = document.createElement('div');
        evalRow.className = 'eval-chart-tooltip__eval';
        const label = document.createElement('span');
        label.textContent = `${mode === 'win' ? 'Win' : 'Eval'} → ${formatEvalChartValue(point, mode)}`;
        evalRow.appendChild(label);
        const deltaInfo = formatEvalChartDelta(point, mode);
        if (deltaInfo && deltaInfo.text) {
          const deltaSpan = document.createElement('span');
          deltaSpan.className = 'eval-chart-tooltip__delta';
          if (deltaInfo.className) {
            deltaSpan.classList.add(deltaInfo.className);
          }
          deltaSpan.textContent = deltaInfo.text;
          evalRow.appendChild(deltaSpan);
        }
        tooltip.appendChild(evalRow);

        const classTag = point.classTag ? point.classTag.toLowerCase() : null;
        if (classTag && CLASSIFICATION_LABELS[classTag]) {
          const tagRow = document.createElement('div');
          tagRow.className = 'eval-chart-tooltip__tag';
          tagRow.textContent = CLASSIFICATION_LABELS[classTag];
          tooltip.appendChild(tagRow);
        }
      }

      function updateEvalChartTooltip() {
        const tooltip = byId('evalChartTooltip');
        const canvas = byId('evalChart');
        const wrap = byId('evalChartCanvasWrap');
        if (!tooltip || !canvas || !wrap) return;
        const index = state.evalChartHoverIndex;
        if (index == null || !state.evalChartLayout || !state.evalChartLayout[index]
          || !state.evalChartLayout[index].hasValue) {
          hideEvalChartTooltip();
          return;
        }
        const layoutPoint = state.evalChartLayout[index];
        buildEvalChartTooltipContent(layoutPoint.point);
        tooltip.style.display = 'block';
        tooltip.setAttribute('aria-hidden', 'false');

        const wrapRect = wrap.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        const offsetX = canvasRect.left - wrapRect.left;
        const offsetY = canvasRect.top - wrapRect.top;
        let left = offsetX + layoutPoint.x - tooltipRect.width / 2;
        let top = offsetY + layoutPoint.y - tooltipRect.height - 12;
        if (top < 8) {
          top = offsetY + layoutPoint.y + 12;
        }
        if (left < 8) {
          left = 8;
        } else if (left + tooltipRect.width > wrapRect.width - 8) {
          left = wrapRect.width - tooltipRect.width - 8;
        }
        if (top + tooltipRect.height > wrapRect.height - 8) {
          top = wrapRect.height - tooltipRect.height - 8;
        }
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      }

      function renderEvalChart() {
        const canvas = byId('evalChart');
        const wrap = byId('evalChartCanvasWrap');
        const emptyState = byId('evalChartEmpty');
        if (!canvas || !wrap) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        if (state.evalChartDataDirty) {
          state.evalChartPoints = buildEvalChartPoints();
          state.evalChartDataDirty = false;
        }

        const points = state.evalChartPoints;
        const width = canvas.clientWidth || wrap.clientWidth || 0;
        const height = canvas.clientHeight || wrap.clientHeight || 0;
        if (!width || !height) {
          hideEvalChartTooltip();
          if (emptyState) emptyState.hidden = false;
          return;
        }

        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.round(width * dpr));
        canvas.height = Math.max(1, Math.round(height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);

        const mode = normalizeEvalChartMode(state.evalChartMode);
        const theme = getEvalChartTheme();
        const range = mode === 'win' ? WIN_RANGE : CP_RANGE;
        const centerY = height / 2;

        const layout = [];
        const step = points.length > 1 ? width / (points.length - 1) : 0;
        let hasValues = false;

        points.forEach((point, index) => {
          const x = points.length > 1 ? step * index : width / 2;
          let value = null;
          if (mode === 'win') {
            if (Number.isFinite(point.winPercent)) {
              const offset = point.winPercent - 50;
              value = Math.max(-WIN_RANGE, Math.min(WIN_RANGE, offset));
            } else if (Number.isFinite(point.mate)) {
              value = Math.sign(point.mate) * WIN_RANGE;
            }
          } else {
            if (Number.isFinite(point.cp)) {
              value = Math.max(-CP_RANGE, Math.min(CP_RANGE, point.cp));
            } else if (Number.isFinite(point.mate)) {
              value = Math.sign(point.mate) * CP_RANGE;
            }
          }
          const hasValue = Number.isFinite(value);
          if (hasValue) {
            hasValues = true;
          }
          const y = hasValue ? centerY - (value / range) * centerY : centerY;
          layout.push({ x, y, value, hasValue, point });
        });
        state.evalChartLayout = layout;

        if (!hasValues) {
          if (emptyState) emptyState.hidden = false;
          hideEvalChartTooltip();
          return;
        }
        if (emptyState) emptyState.hidden = true;

        ctx.save();
        ctx.strokeStyle = theme.grid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(width, centerY);
        ctx.stroke();
        ctx.restore();

        const segments = [];
        let current = [];
        layout.forEach((item) => {
          if (item.hasValue) {
            current.push(item);
          } else if (current.length) {
            segments.push(current);
            current = [];
          }
        });
        if (current.length) {
          segments.push(current);
        }

        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        segments.forEach((segment) => {
          if (!segment.length) return;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(segment[0].x, centerY);
          segment.forEach((pt) => {
            ctx.lineTo(pt.x, pt.y);
          });
          const last = segment[segment.length - 1];
          ctx.lineTo(last.x, centerY);
          ctx.closePath();

          ctx.save();
          ctx.clip();
          ctx.fillStyle = theme.fillWhite;
          ctx.fillRect(0, 0, width, centerY);
          ctx.restore();

          ctx.save();
          ctx.clip();
          ctx.fillStyle = theme.fillBlack;
          ctx.fillRect(0, centerY, width, centerY);
          ctx.restore();
          ctx.restore();

          ctx.beginPath();
          ctx.moveTo(segment[0].x, segment[0].y);
          for (let i = 1; i < segment.length; i += 1) {
            ctx.lineTo(segment[i].x, segment[i].y);
          }
          ctx.strokeStyle = theme.line;
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        layout.forEach((pt) => {
          const tag = pt.point.classTag ? pt.point.classTag.toLowerCase() : null;
          const markerColor = tag && theme.markers[tag] ? theme.markers[tag] : null;
          if (markerColor && pt.hasValue) {
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 4.5, 0, Math.PI * 2);
            ctx.fillStyle = markerColor;
            ctx.fill();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = 'rgba(15, 23, 42, 0.55)';
            ctx.stroke();
          }
          if (Number.isFinite(pt.point.mate)) {
            const top = pt.point.mate > 0;
            const baseY = top ? 12 : height - 12;
            const tipY = top ? 6 : height - 6;
            ctx.beginPath();
            ctx.moveTo(pt.x, tipY);
            ctx.lineTo(pt.x - 6, baseY);
            ctx.lineTo(pt.x + 6, baseY);
            ctx.closePath();
            ctx.fillStyle = theme.line;
            ctx.fill();
            ctx.font = '11px "JetBrains Mono", "SFMono-Regular", Menlo, Consolas, monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = top ? 'top' : 'bottom';
            ctx.fillStyle = theme.line;
            const textY = top ? baseY + 2 : baseY - 2;
            ctx.fillText(`#${Math.abs(pt.point.mate)}`, pt.x, textY);
          }
        });

        const activeIndex = state.ply > 0 ? Math.min(state.ply - 1, layout.length - 1) : null;
        if (activeIndex != null && layout[activeIndex] && layout[activeIndex].hasValue) {
          const active = layout[activeIndex];
          ctx.save();
          ctx.setLineDash([4, 4]);
          ctx.strokeStyle = theme.axis;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(active.x, 0);
          ctx.lineTo(active.x, height);
          ctx.stroke();
          ctx.restore();

          ctx.beginPath();
          ctx.arc(active.x, active.y, 6, 0, Math.PI * 2);
          ctx.lineWidth = 2;
          ctx.strokeStyle = theme.accent;
          ctx.stroke();
        }

        const hoverIndex = state.evalChartHoverIndex;
        if (hoverIndex != null && layout[hoverIndex] && layout[hoverIndex].hasValue) {
          const hover = layout[hoverIndex];
          ctx.save();
          ctx.setLineDash([2, 3]);
          ctx.strokeStyle = theme.accent;
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.moveTo(hover.x, 0);
          ctx.lineTo(hover.x, height);
          ctx.stroke();
          ctx.restore();

          ctx.save();
          ctx.beginPath();
          ctx.arc(hover.x, hover.y, 7, 0, Math.PI * 2);
          ctx.fillStyle = theme.accent;
          ctx.globalAlpha = 0.18;
          ctx.fill();
          ctx.restore();
          ctx.beginPath();
          ctx.arc(hover.x, hover.y, 7, 0, Math.PI * 2);
          ctx.lineWidth = 2;
          ctx.strokeStyle = theme.accent;
          ctx.stroke();
        }

        updateEvalChartTooltip();
      }

      function handleEvalChartPointer(event) {
        const canvas = byId('evalChart');
        if (!canvas || !state.evalChartLayout || !state.evalChartLayout.length) return;
        const rect = canvas.getBoundingClientRect();
        let clientX = null;
        if (event.touches && event.touches.length) {
          clientX = event.touches[0].clientX;
        } else if (event.clientX != null) {
          clientX = event.clientX;
        }
        if (!Number.isFinite(clientX)) return;
        const x = clientX - rect.left;
        let nearestIndex = null;
        let nearestDistance = Infinity;
        state.evalChartLayout.forEach((pt, idx) => {
          if (!pt || !pt.hasValue) return;
          const distance = Math.abs(pt.x - x);
          if (distance < nearestDistance) {
            nearestDistance = distance;
            nearestIndex = idx;
          }
        });
        if (nearestIndex == null) {
          if (state.evalChartHoverIndex != null) {
            state.evalChartHoverIndex = null;
            state.evalChartHoverPosition = null;
            hideEvalChartTooltip();
            scheduleEvalChartUpdate();
          }
          return;
        }
        if (state.evalChartHoverIndex !== nearestIndex) {
          state.evalChartHoverIndex = nearestIndex;
          state.evalChartHoverPosition = {
            x: clientX,
            y: event.touches && event.touches.length ? event.touches[0].clientY : event.clientY
          };
          updateEvalChartTooltip();
          scheduleEvalChartUpdate();
        } else {
          state.evalChartHoverPosition = {
            x: clientX,
            y: event.touches && event.touches.length ? event.touches[0].clientY : event.clientY
          };
          updateEvalChartTooltip();
        }
      }

      function handleEvalChartLeave() {
        if (state.evalChartHoverIndex != null) {
          state.evalChartHoverIndex = null;
          state.evalChartHoverPosition = null;
          hideEvalChartTooltip();
          scheduleEvalChartUpdate();
        } else {
          hideEvalChartTooltip();
        }
      }

      function handleEvalChartClick(event) {
        handleEvalChartPointer(event);
        const index = state.evalChartHoverIndex;
        if (index == null || !state.evalChartLayout || !state.evalChartLayout[index]) return;
        const layoutPoint = state.evalChartLayout[index];
        if (layoutPoint && layoutPoint.point && Number.isFinite(layoutPoint.point.ply)) {
          goToPly(layoutPoint.point.ply);
        }
      }

      function initEvalChart() {
        const card = byId('evalChartCard');
        const canvas = byId('evalChart');
        if (!card || !canvas) return;
        state.evalChartMode = getSavedEvalChartMode();
        updateEvalChartModeUI();

        card.addEventListener('click', (event) => {
          const button = event.target.closest('.eval-chart-mode');
          if (!button || !button.dataset.mode) return;
          setEvalChartMode(button.dataset.mode);
        });

        canvas.addEventListener('mousemove', handleEvalChartPointer);
        canvas.addEventListener('mouseleave', handleEvalChartLeave);
        canvas.addEventListener('click', handleEvalChartClick);
        canvas.addEventListener('touchstart', (event) => {
          handleEvalChartPointer(event);
          event.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchmove', (event) => {
          handleEvalChartPointer(event);
          event.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchend', (event) => {
          if (state.evalChartHoverIndex != null && state.evalChartLayout[state.evalChartHoverIndex]) {
            const layoutPoint = state.evalChartLayout[state.evalChartHoverIndex];
            if (layoutPoint && layoutPoint.point && Number.isFinite(layoutPoint.point.ply)) {
              goToPly(layoutPoint.point.ply);
            }
          }
          handleEvalChartLeave();
          event.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchcancel', (event) => {
          handleEvalChartLeave();
          event.preventDefault();
        }, { passive: false });

        window.addEventListener('resize', () => scheduleEvalChartUpdate());
        state.evalChartDataDirty = true;
        scheduleEvalChartUpdate({ recomputeData: true });
      }

      function getSuggestionIcon(baseline, overlayFinal) {
        const overlay = overlayFinal ? overlayFinal.toLowerCase() : null;
        if (overlay === 'brilliant') return '!!';
        if (overlay === 'great') return '!';
        const base = baseline ? baseline.toLowerCase() : null;
        if (base === 'best') return '★';
        if (base === 'excellent') return '👍';
        return null;
      }

      function getSuggestionTone(suggestion) {
        if (!suggestion) return 'best';
        if (suggestion.rank === 1) return 'top';
        if (suggestion.overlayFinal === 'brilliant') return 'brilliant';
        if (suggestion.overlayFinal === 'great') return 'great';
        if (suggestion.baseline === 'best') return 'best';
        if (suggestion.baseline === 'excellent') return 'excellent';
        return 'best';
      }

      function colorForTone(tone) {
        const style = getComputedStyle(document.documentElement);
        const varName = (() => {
          switch (tone) {
            case 'top':
              return '--sgn-top';
            case 'best':
              return '--sgn-best';
            case 'excellent':
              return '--sgn-excellent';
            case 'great':
              return '--sgn-great';
            case 'brilliant':
              return '--sgn-brilliant';
            default:
              return '--sgn-best';
          }
        })();
        const value = style.getPropertyValue(varName);
        return value && value.trim() ? value.trim() : '#10B981';
      }

      function formatEpGapPercent(value) {
        if (!Number.isFinite(value)) return '—';
        const percent = value * 100;
        const sign = percent > 0 ? '+' : (percent < 0 ? '−' : '+');
        return `(${sign}${Math.abs(percent).toFixed(1)}%)`;
      }

      function buildSuggestionDisplay({ classification, record }) {
        if (!classification || !record) {
          return { evalLabel: record && record.evalLabel ? record.evalLabel : '—', deltaLabel: null };
        }
        const actualEntry = classification.actualEntry || null;
        const bestEntry = classification.bestEntry || null;
        const evalLabel = record.evalLabel || (actualEntry && actualEntry.eval) || '—';
        let deltaLabel = record.deltaLabel || null;
        const bestParsed = parseEvalString(bestEntry ? bestEntry.eval : null);
        const actualParsed = parseEvalString(actualEntry ? actualEntry.eval : null);
        if (bestParsed && bestParsed.type === 'mate' && actualParsed && actualParsed.type === 'mate'
          && Math.sign(bestParsed.value) === Math.sign(actualParsed.value)) {
          const diff = Math.abs(actualParsed.value) - Math.abs(bestParsed.value);
          if (diff === 0) {
            deltaLabel = '#0';
          } else if (diff > 0) {
            deltaLabel = `#-${diff}`;
          } else {
            deltaLabel = `#+${Math.abs(diff)}`;
          }
        } else if (bestParsed && bestParsed.type === 'mate' && (!actualParsed || actualParsed.type !== 'mate')) {
          deltaLabel = '#-∞';
        } else if (actualParsed && actualParsed.type === 'mate' && (!bestParsed || bestParsed.type !== 'mate')) {
          deltaLabel = '#+∞';
        } else if (Number.isFinite(classification.bestEp) && Number.isFinite(classification.actualEp)) {
          const dropPercent = (classification.bestEp - classification.actualEp) * 100;
          if (Math.abs(dropPercent) >= 0.05) {
            const approx = formatWinDeltaDisplay(Math.abs(dropPercent));
            const prefix = dropPercent > 0 ? '−' : '+';
            deltaLabel = `${prefix}${approx || Math.abs(dropPercent).toFixed(1)}%`;
          }
        } else if (Number.isFinite(classification.bestCp) && Number.isFinite(classification.actualCp)) {
          const diffCp = classification.actualCp - classification.bestCp;
          if (Math.abs(diffCp) >= 1) {
            const pawns = diffCp / 100;
            deltaLabel = `${diffCp > 0 ? '+' : '−'}${Math.abs(pawns).toFixed(2)}`;
          }
        }
        return { evalLabel, deltaLabel };
      }

      function useMoveClassification({
        entries = [],
        analysis,
        baseFen,
        moverColor,
        basePly,
        beforeEpOverride = null,
        previousMoveEntry = null
      }) {
        if (!analysis || !baseFen || !Number.isFinite(basePly)) {
          return [];
        }
        const rawList = Array.isArray(entries) ? entries : [];
        if (!rawList.length) {
          return [];
        }
        const seen = new Set();
        const normalizedEntries = [];
        rawList.forEach((entry, index) => {
          if (!entry || !entry.uci) return;
          const key = entry.uci.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          normalizedEntries.push({
            ...entry,
            uci: key,
            rank: Number.isFinite(entry.rank) ? entry.rank : (index + 1)
          });
        });
        if (!normalizedEntries.length) {
          return [];
        }
        const rating = getAverageGameRating();
        const results = [];
        normalizedEntries.forEach((entry) => {
          const moveEntry = createMoveEntryFromUci(baseFen, moverColor, entry.uci);
          if (!moveEntry) return;
          moveEntry.ply = basePly;
          moveEntry.preFen = baseFen;
          moveEntry.san = entry.san || (Array.isArray(entry.pvSan) && entry.pvSan.length ? entry.pvSan[0] : null) || moveEntry.san || null;

          const classification = computeClassificationForMove({
            analysis,
            preFen: baseFen,
            moveEntry,
            actualEntry: entry,
            beforeEpOverride,
            previousMoveEntry
          });
          if (!classification) return;

          const record = buildClassifiedMoveRecord({
            ply: basePly,
            moveEntry,
            classification
          });
          if (!record) return;

          const display = buildSuggestionDisplay({ classification, record });
          record.evalLabel = display.evalLabel;
          record.deltaLabel = display.deltaLabel;
          recordMoveClassification(basePly, entry.uci, record);

          const topEp = Number.isFinite(classification.bestEp) ? classification.bestEp : null;
          const postEp = Number.isFinite(classification.actualEp) ? classification.actualEp : null;
          const epGapToTop = topEp != null && postEp != null ? topEp - postEp : null;
          const preEvalCp = expectedPointsToCentipawns(classification.beforeEp, rating);
          const overlayFinal = classification.overlay === 'brilliant' || classification.overlay === 'great'
            ? classification.overlay
            : null;
          const baselineRaw = classification.baseline || classification.classification || null;
          const baseline = baselineRaw ? baselineRaw.toLowerCase() : null;

          results.push({
            uci: entry.uci,
            san: record.san || entry.san || entry.uci,
            rank: Number.isFinite(entry.rank) ? entry.rank : (results.length + 1),
            postEvalCp: Number.isFinite(classification.actualCp) ? classification.actualCp : null,
            preEvalCp: Number.isFinite(preEvalCp) ? preEvalCp : null,
            postEvalEp: postEp,
            topEp,
            epGapToTop,
            baseline,
            overlayFinal,
            icon: getSuggestionIcon(baseline, overlayFinal),
            evalLabel: display.evalLabel,
            deltaLabel: display.deltaLabel,
            entry,
            classification,
            record,
            overlaySeq: uciSeqFromEntry(entry, 10)
          });
        });

        results.sort((a, b) => a.rank - b.rank);
        return results;
      }

      function updatePVDisplay(entries) {
        const listEl = byId('pvList');
        if (!listEl) return;
        listEl.innerHTML = '';

        const analysis = getAnalysisForCurrentView();
        if (!Array.isArray(entries) || !entries.length || !analysis) {
          state.suggestionData = [];
          state.activeSuggestion = null;
          state.hoverSuggestion = null;
          redrawAllArrows([]);
          return;
        }

        const preCpCandidates = analysis
          ? [
            Number.isFinite(analysis.sfBefore) ? analysis.sfBefore : null,
            Number.isFinite(analysis.bestCpBefore) ? analysis.bestCpBefore : null,
            Number.isFinite(analysis.actualCpBefore) ? analysis.actualCpBefore : null,
            Number.isFinite(analysis.beforeCp) ? analysis.beforeCp : null,
            Number.isFinite(analysis.bestCp) ? analysis.bestCp : null
          ]
          : [];
        let preCpFinal = null;
        for (const value of preCpCandidates) {
          const clamped = clampFiniteCp(value);
          if (clamped != null) {
            preCpFinal = clamped;
            break;
          }
        }
        if (preCpFinal == null && analysis) {
          const summaryBestEval = analysis.summary && analysis.summary.best && analysis.summary.best.eval
            ? analysis.summary.best.eval
            : null;
          const beforeEvalLabel = analysis.beforeEval
            || summaryBestEval
            || (analysis.bestEntry && analysis.bestEntry.eval)
            || null;
          const preParsed = beforeEvalLabel ? parseEvalToCp(beforeEvalLabel) : null;
          if (preParsed && preParsed.type === 'cp') {
            preCpFinal = clampFiniteCp(preParsed.value);
          }
        }

        const isPlayedMode = state.suggestionMode === 'played';
        const historyIndex = state.ply > 0 ? state.ply - 1 : null;
        const activeEntry = historyIndex != null ? state.verboseHistory[historyIndex] : null;

        let baseFen = null;
        let moverColor = 'w';
        let basePly = isPlayedMode ? state.ply : state.ply + 1;
        let beforeEpOverride = Number.isFinite(analysis.beforeEp) ? analysis.beforeEp : null;
        let previousMoveEntry = null;

        if (isPlayedMode) {
          baseFen = (activeEntry && activeEntry.preFen) || effectiveInitialFen();
          moverColor = activeEntry && activeEntry.color ? activeEntry.color : sideToMoveFromFen(baseFen);
          basePly = activeEntry && Number.isFinite(activeEntry.ply) ? activeEntry.ply : state.ply;
          previousMoveEntry = historyIndex != null && historyIndex > 0 ? state.verboseHistory[historyIndex - 1] : null;
        } else {
          const currentFen = state.ply === 0
            ? effectiveInitialFen()
            : ((state.verboseHistory[state.ply - 1] && state.verboseHistory[state.ply - 1].fen) || effectiveInitialFen());
          baseFen = currentFen;
          moverColor = sideToMoveFromFen(baseFen);
          basePly = state.ply + 1;
          previousMoveEntry = state.ply > 0 ? state.verboseHistory[state.ply - 1] : null;
        }

        if (!baseFen) {
          baseFen = effectiveInitialFen();
        }

        const classified = useMoveClassification({
          entries,
          analysis,
          baseFen,
          moverColor,
          basePly,
          beforeEpOverride,
          previousMoveEntry
        });

        const filtered = classified.filter((item) => {
          const overlay = item.overlayFinal;
          const base = item.baseline;
          return overlay === 'brilliant' || overlay === 'great' || base === 'best' || base === 'excellent';
        });

        if (!filtered.length) {
          state.suggestionData = [];
          state.activeSuggestion = null;
          state.hoverSuggestion = null;
          redrawAllArrows([]);
          return;
        }

        filtered.sort((a, b) => a.rank - b.rank);
        const limited = filtered.slice(0, MULTIPV_MAX_CANDIDATES);

        if (!state.activeSuggestion || !limited.some((item) => item.uci === state.activeSuggestion)) {
          state.activeSuggestion = limited[0] ? limited[0].uci : null;
        }
        if (state.hoverSuggestion && !limited.some((item) => item.uci === state.hoverSuggestion)) {
          state.hoverSuggestion = null;
        }

        state.suggestionData = limited;

        const activeUci = state.activeSuggestion;
        limited.forEach((item) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'suggestion';
          button.dataset.uci = item.uci;
          button.dataset.ply = String(basePly);
          const tone = getSuggestionTone(item);
          button.dataset.tone = tone;

          const badge = document.createElement('div');
          badge.className = 'suggestion__badge';

          const rankEl = document.createElement('span');
          rankEl.className = 'suggestion__rank';
          rankEl.textContent = item.rank;
          badge.appendChild(rankEl);

          if (item.icon) {
            const iconEl = document.createElement('span');
            iconEl.className = 'suggestion__icon';
            iconEl.textContent = item.icon;
            badge.appendChild(iconEl);
          }

          button.appendChild(badge);

          const text = document.createElement('div');
          text.className = 'suggestion__text';

          const sanEl = document.createElement('span');
          sanEl.className = 'suggestion__move-main';
          sanEl.textContent = item.san || item.uci;
          text.appendChild(sanEl);

          const classification = item.classification || null;
          const record = item.record || null;
          const rawPostEval = (item.entry && item.entry.eval)
            || (record && record.evalLabel)
            || item.evalLabel
            || null;
          let postCpRaw = null;
          if (classification && Number.isFinite(classification.actualCp)) {
            postCpRaw = classification.actualCp;
          } else if (record && Number.isFinite(record.evalCp)) {
            postCpRaw = record.evalCp;
          } else if (item.entry && Number.isFinite(item.entry.cp)) {
            postCpRaw = item.entry.cp;
          }
          const postCp = clampFiniteCp(postCpRaw);
          const evalAfterLabel = postCp != null
            ? formatEvalAfterLabel(postCp)
            : formatEvalAfterLabel(rawPostEval);
          const postParsed = rawPostEval ? parseEvalToCp(rawPostEval) : null;
          const isMateAfter = Boolean(
            (postParsed && postParsed.type === 'mate')
            || (Number.isFinite(postCpRaw) && Math.abs(postCpRaw) >= 10000)
          );
          let changeText = '';
          if (!isMateAfter && preCpFinal != null && postCp != null) {
            changeText = formatChangeArrow(postCp - preCpFinal);
          }
          const metaEl = document.createElement('span');
          metaEl.className = 'suggestion__meta';
          metaEl.textContent = isMateAfter
            ? `Eval → ${evalAfterLabel}`
            : changeText
              ? `Eval → ${evalAfterLabel} · ${changeText}`
              : `Eval → ${evalAfterLabel}`;
          text.appendChild(metaEl);

          button.appendChild(text);

          const tag = item.overlayFinal || item.baseline || 'best';
          const normalizedTag = tag ? tag.toLowerCase() : 'best';
          const badgeLabel = document.createElement('span');
          badgeLabel.className = 'suggestion__badge-label';
          const labelText = normalizedTag.charAt(0).toUpperCase() + normalizedTag.slice(1);
          const iconPath = classificationToIcon(normalizedTag);
          if (iconPath) {
            const icon = document.createElement('img');
            icon.src = iconPath;
            icon.alt = labelText;
            icon.className = 'classification-icon';
            badgeLabel.appendChild(icon);
          }
          const textLabel = document.createElement('span');
          textLabel.textContent = labelText;
          badgeLabel.appendChild(textLabel);
          button.appendChild(badgeLabel);

          const gapEl = document.createElement('span');
          gapEl.className = 'suggestion__gap';
          gapEl.textContent = formatEpGapPercent(item.epGapToTop);
          button.appendChild(gapEl);

          if (activeUci && item.uci === activeUci) {
            button.classList.add('suggestion--active');
            button.setAttribute('aria-pressed', 'true');
          } else {
            button.setAttribute('aria-pressed', 'false');
          }

          const overlaySegments = overlayFromSeq(item.overlaySeq);

          button.addEventListener('click', () => {
            if (overlaySegments.length) {
              if (overlaysEqual(state.lineOverlay, overlaySegments)) {
                clearLineOverlay({ analysis });
              } else {
                setLineOverlay(overlaySegments, { analysis });
              }
            } else {
              clearLineOverlay({ analysis });
            }
            if (item.entry && item.entry.uci && item.entry.uci.length >= 4) {
              const from = item.entry.uci.slice(0, 2);
              const to = item.entry.uci.slice(2, 4);
              showGhostPreview({ from, to, san: item.san || item.entry.uci });
            }
            state.activeSuggestion = item.uci;
            Array.from(listEl.querySelectorAll('.suggestion')).forEach((el) => {
              const isActive = el.dataset.uci === item.uci;
              el.classList.toggle('suggestion--active', isActive);
              el.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            });
            redrawAllArrows();
          });

          const handleEnter = () => {
            state.hoverSuggestion = item.uci;
            redrawAllArrows();
          };

          const handleLeave = () => {
            state.hoverSuggestion = null;
            redrawAllArrows();
          };

          button.addEventListener('mouseenter', handleEnter);
          button.addEventListener('mouseleave', handleLeave);
          button.addEventListener('focus', handleEnter);
          button.addEventListener('blur', handleLeave);

          listEl.appendChild(button);
        });

        redrawAllArrows(limited);
      }

      function clampRating(value) {
        return Math.max(400, Math.min(2600, value));
      }

      function computeBaselineRating(bucket) {
        if (!bucket) return null;
        const moves = bucket.moves || 0;
        if (moves < 4) return null;
        const analyzed = Math.max(0, bucket.analyzedMoves || 0);
        let rating = 900;
        const accuracy = bucket.accuracyCount > 0 ? bucket.accuracySum / bucket.accuracyCount : null;
        if (Number.isFinite(accuracy)) {
          rating += (accuracy - 45) * 18;
          if (accuracy > 75) {
            rating += (accuracy - 75) * 6;
          }
        } else {
          rating += 120;
        }
        const cpLoss = bucket.cpLossCount > 0 ? bucket.cpLossSum / bucket.cpLossCount : null;
        if (Number.isFinite(cpLoss)) {
          rating -= Math.max(0, cpLoss) * 3.6;
          if (cpLoss > 35) {
            rating -= (cpLoss - 35) * 1.5;
          }
        } else {
          rating -= 40;
        }
        const goodMoves = (bucket.counts.best || 0)
          + (bucket.counts.excellent || 0)
          + (bucket.counts.great || 0)
          + (bucket.counts.brilliant || 0);
        const minorErrors = (bucket.counts.inaccuracy || 0) + (bucket.counts.miss || 0);
        const majorErrors = (bucket.counts.mistake || 0) + (bucket.counts.blunder || 0);
        rating += goodMoves * 5;
        rating -= minorErrors * 8;
        rating -= majorErrors * 26;
        rating += Math.min(moves, 70) * 1.1;
        rating += Math.min(analyzed, 50) * 0.8;
        return clampRating(rating);
      }

      function parseRatingValue(raw) {
        if (raw == null) return null;
        const str = String(raw).trim();
        if (!str || str === '?' || str === '—') return null;
        const match = str.match(/-?\d+/);
        if (!match) return null;
        const value = parseInt(match[0], 10);
        return Number.isFinite(value) ? value : null;
      }

      function getHeaderRating(color) {
        if (!state.headers) return null;
        const prefix = color === 'b' ? 'Black' : 'White';
        const keys = [`${prefix}Elo`, `${prefix}Rating`, `${prefix}USCF`, `${prefix}Fide`, `${prefix}FIDE`];
        for (const key of keys) {
          if (Object.prototype.hasOwnProperty.call(state.headers, key)) {
            const parsed = parseRatingValue(state.headers[key]);
            if (Number.isFinite(parsed)) {
              return clampRating(parsed);
            }
          }
        }
        return null;
      }

      function getPlayerRating(color) {
        const fromHeader = getHeaderRating(color);
        if (Number.isFinite(fromHeader)) {
          return fromHeader;
        }
        return 1500;
      }

      function getAverageGameRating() {
        const white = getPlayerRating('w');
        const black = getPlayerRating('b');
        if (Number.isFinite(white) && Number.isFinite(black)) {
          return (white + black) / 2;
        }
        if (Number.isFinite(white)) return white;
        if (Number.isFinite(black)) return black;
        return 1500;
      }

      function ratingLerp(rating, lowRating, highRating, lowValue, highValue) {
        const clamped = clampRating(Number.isFinite(rating) ? rating : (lowRating + highRating) / 2);
        if (clamped <= lowRating) return lowValue;
        if (clamped >= highRating) return highValue;
        const ratio = (clamped - lowRating) / (highRating - lowRating);
        return lowValue + (highValue - lowValue) * ratio;
      }

      function slopeForRating(rating) {
        const clamped = clampRating(Number.isFinite(rating) ? rating : 1500);
        const minSlope = 0.0032;
        const maxSlope = 0.006;
        const ratio = Math.max(0, Math.min(1, (clamped - 400) / (2600 - 400)));
        return minSlope + (maxSlope - minSlope) * ratio;
      }

      function parseGameResultScores(resultTag) {
        const normalized = typeof resultTag === 'string' ? resultTag.trim() : '';
        switch (normalized) {
          case '1-0':
            return { white: 1, black: 0 };
          case '0-1':
            return { white: 0, black: 1 };
          case '1/2-1/2':
            return { white: 0.5, black: 0.5 };
          default:
            return null;
        }
      }

      function expectedScore(ratingA, ratingB) {
        return 1 / (1 + Math.pow(10, (ratingB - ratingA) / 400));
      }

      function applyEloAdjustment(rating, opponentRating, score, kFactor = 20) {
        if (!Number.isFinite(rating) || !Number.isFinite(opponentRating) || !Number.isFinite(score)) {
          return rating;
        }
        const expected = expectedScore(rating, opponentRating);
        return clampRating(rating + kFactor * (score - expected));
      }

      function estimateEloFromSummary(summary, scores) {
        if (!summary) {
          return { white: null, black: null };
        }
        const whiteBase = computeBaselineRating(summary.w);
        const blackBase = computeBaselineRating(summary.b);
        if (!scores || whiteBase == null || blackBase == null) {
          return { white: whiteBase, black: blackBase };
        }
        return {
          white: applyEloAdjustment(whiteBase, blackBase, scores.white),
          black: applyEloAdjustment(blackBase, whiteBase, scores.black)
        };
      }

      function updateEloEstimates(summary) {
        const data = summary || computeMoveSummary();
        const scores = parseGameResultScores(state.headers && state.headers.Result);
        const estimates = estimateEloFromSummary(data, scores);
        const roundedWhite = Number.isFinite(estimates.white) ? Math.round(estimates.white) : null;
        const roundedBlack = Number.isFinite(estimates.black) ? Math.round(estimates.black) : null;

        const table = byId('moveSummaryTable');
        if (table) {
          const whiteCard = table.querySelector('.summary-player-card[data-color="w"] [data-role="elo"]');
          if (whiteCard) {
            whiteCard.textContent = roundedWhite != null ? `Elo ${roundedWhite}` : 'Elo —';
          }
          const blackCard = table.querySelector('.summary-player-card[data-color="b"] [data-role="elo"]');
          if (blackCard) {
            blackCard.textContent = roundedBlack != null ? `Elo ${roundedBlack}` : 'Elo —';
          }
        }

        const whiteEl = byId('eloWhite');
        const blackEl = byId('eloBlack');
        if (whiteEl) {
          whiteEl.textContent = roundedWhite != null ? roundedWhite : '—';
        }
        if (blackEl) {
          blackEl.textContent = roundedBlack != null ? roundedBlack : '—';
        }
      }

      function cpToExpectedPoints(cp, ratingOverride) {
        if (cp == null || Number.isNaN(cp)) return 0.5;
        if (cp >= 10000) return 1;
        if (cp <= -10000) return 0;
        const rating = Number.isFinite(ratingOverride) ? ratingOverride : getAverageGameRating();
        const slope = slopeForRating(rating);
        const capped = Math.max(-2000, Math.min(2000, cp));
        const winChance = 1 / (1 + Math.exp(-slope * capped));
        return Math.max(0, Math.min(1, winChance));
      }

      function centipawnsToWinPercent(cp, ratingOverride) {
        if (cp == null || Number.isNaN(cp)) return null;
        const ep = cpToExpectedPoints(cp, ratingOverride);
        return Math.max(0, Math.min(100, ep * 100));
      }

      function expectedPointsToCentipawns(ep, ratingOverride) {
        if (!Number.isFinite(ep)) return null;
        const clamped = Math.min(0.999, Math.max(0.001, ep));
        const rating = Number.isFinite(ratingOverride) ? ratingOverride : getAverageGameRating();
        const slope = slopeForRating(rating);
        if (!Number.isFinite(slope) || slope === 0) return null;
        const logit = Math.log(clamped / (1 - clamped));
        const cp = logit / slope;
        return Math.max(-2000, Math.min(2000, cp));
      }

      function expectedPointsFromWdl(wdl, color = 'w') {
        if (!wdl) return null;
        const w = Number.isFinite(wdl.w) ? Math.max(0, wdl.w) : 0;
        const d = Number.isFinite(wdl.d) ? Math.max(0, wdl.d) : 0;
        const l = Number.isFinite(wdl.l) ? Math.max(0, wdl.l) : 0;
        const total = w + d + l;
        if (total <= 0) return null;
        if (color === 'b') {
          return (l + 0.5 * d) / total;
        }
        return (w + 0.5 * d) / total;
      }

      // Stockfish reports WDL counts for the side-to-move. Convert directly to
      // expected points for that mover: EP = (wins + 0.5 * draws) / total.
      function epFromWdlForMover(wdl /*, fen, fallbackColor = 'w' */) {
        if (!wdl) return null;
        const w = Number.isFinite(wdl.w) ? Math.max(0, wdl.w) : 0;
        const d = Number.isFinite(wdl.d) ? Math.max(0, wdl.d) : 0;
        const l = Number.isFinite(wdl.l) ? Math.max(0, wdl.l) : 0;
        const total = w + d + l;
        if (total <= 0) return null;
        return (w + 0.5 * d) / total;
      }

      function expectedPointsForMover(entry, fen, fallbackColor = 'w') {
        if (!entry) return null;
        const stm = typeof fen === 'string' ? sideToMoveFromFen(fen) : null;
        const mover = stm === 'b' ? 'b' : (stm === 'w' ? 'w' : (fallbackColor === 'b' ? 'b' : 'w'));
        const epWdl = epFromWdlForMover(entry.wdl);
        if (Number.isFinite(epWdl)) {
          return epWdl;
        }
        const cp = evalStringToCentipawns(entry.eval);
        if (!Number.isFinite(cp)) {
          return null;
        }
        const epWhite = cpToExpectedPoints(cp);
        return mover === 'w' ? epWhite : 1 - epWhite;
      }

      function winPercentFromWdl(wdl, color = 'w') {
        if (!wdl) return null;
        const w = Number.isFinite(wdl.w) ? Math.max(0, wdl.w) : 0;
        const d = Number.isFinite(wdl.d) ? Math.max(0, wdl.d) : 0;
        const l = Number.isFinite(wdl.l) ? Math.max(0, wdl.l) : 0;
        const total = w + d + l;
        if (total <= 0) return null;
        if (color === 'b') {
          return Math.max(0, Math.min(100, (l / total) * 100));
        }
        return Math.max(0, Math.min(100, (w / total) * 100));
      }

      function expectedPointsForEntry(entry, moverColor = 'w') {
        return expectedPointsForMover(entry, null, moverColor);
      }

      function shortlistPvEntries(entries, options = {}) {
        const fen = typeof options.fen === 'string' ? options.fen : null;
        const moverColor = fen ? sideToMoveFromFen(fen) : (options.moverColor === 'b' ? 'b' : 'w');
        const keepMargin = Number.isFinite(options.keepMargin) ? options.keepMargin : PV_KEEP_MARGIN;
        const onlyOneMargin = Number.isFinite(options.onlyOneMargin) ? options.onlyOneMargin : PV_ONLY_ONE_MARGIN;
        const bestMargin = Number.isFinite(options.bestMargin) ? options.bestMargin : PV_BEST_MARGIN;
        const maxEntries = Number.isFinite(options.maxEntries) ? options.maxEntries : MULTIPV_MAX_CANDIDATES;
        const mateSlack = Number.isFinite(options.mateSlack) ? options.mateSlack : PV_MATE_SLACK;
        const emptyMeta = {
          moverColor,
          keepMargin,
          onlyOneMargin,
          bestMargin,
          mateSlack,
          keptCount: 0,
          totalCandidates: 0,
          bestExpectedPoints: null,
          secondExpectedPoints: null,
          dropPercent: null,
          dropPercentDisplay: null,
          reason: null,
          message: null,
          mateDistance: null
        };
        if (!Array.isArray(entries) || entries.length === 0) {
          return { entries: [], meta: emptyMeta };
        }

        const annotated = entries.map((entry) => {
          const parsedEval = parseEvalString(entry.eval);
          const mateValue = parsedEval && parsedEval.type === 'mate' ? parsedEval.value : null;
          let ep = expectedPointsForMover(entry, fen, moverColor);
          if (!Number.isFinite(ep) && mateValue != null) {
            const mateForMover = (moverColor === 'w' && mateValue > 0) || (moverColor === 'b' && mateValue < 0);
            const mateForOpponent = (moverColor === 'w' && mateValue < 0) || (moverColor === 'b' && mateValue > 0);
            if (mateForMover) {
              ep = 1;
            } else if (mateForOpponent) {
              ep = 0;
            }
          }
          const normalizedEp = Number.isFinite(ep) ? ep : null;
          return {
            original: entry,
            ep: normalizedEp,
            parsedEval,
            mateValue: Number.isFinite(mateValue) ? mateValue : null,
            mateDistance: Number.isFinite(mateValue) ? Math.abs(mateValue) : null
          };
        });

        const hasEp = annotated.some((item) => Number.isFinite(item.ep));
        const sorted = annotated.slice().sort((a, b) => {
          if (hasEp) {
            const epA = Number.isFinite(a.ep) ? a.ep : -Infinity;
            const epB = Number.isFinite(b.ep) ? b.ep : -Infinity;
            if (epA !== epB) {
              return epB - epA;
            }
            if (
              a.mateDistance != null
              && b.mateDistance != null
              && a.mateValue != null
              && b.mateValue != null
              && Math.sign(a.mateValue) === Math.sign(b.mateValue)
            ) {
              return a.mateDistance - b.mateDistance;
            }
          }
          const rankA = Number.isFinite(a.original.rank) ? a.original.rank : Infinity;
          const rankB = Number.isFinite(b.original.rank) ? b.original.rank : Infinity;
          return rankA - rankB;
        });

        const bestInfo = sorted[0];
        const originalCount = sorted.length;
        const bestEp = bestInfo && Number.isFinite(bestInfo.ep) ? bestInfo.ep : null;
        const secondInfo = sorted.length > 1 ? sorted[1] : null;
        const secondEp = secondInfo && Number.isFinite(secondInfo.ep) ? secondInfo.ep : null;
        const rawDrop = bestEp != null && secondEp != null ? bestEp - secondEp : null;
        const dropPercent = rawDrop != null ? Math.max(0, rawDrop * 100) : null;
        const dropPercentDisplay = dropPercent != null ? formatWinDeltaDisplay(dropPercent) : null;
        let keptInfos = [];
        let reason = 'margin';
        const bestEvalParsed = bestInfo ? bestInfo.parsedEval : null;

        if (bestInfo && bestEvalParsed && bestEvalParsed.type === 'mate' && bestEvalParsed.value !== 0) {
          reason = 'mate';
          const bestSign = Math.sign(bestEvalParsed.value) || 1;
          const maxDistance = Math.abs(bestEvalParsed.value) + mateSlack;
          keptInfos = sorted.filter((info) => {
            const parsed = info.parsedEval;
            if (!parsed || parsed.type !== 'mate') return false;
            if ((Math.sign(parsed.value || 0) || 0) !== bestSign) return false;
            const distance = Math.abs(parsed.value || 0);
            return Number.isFinite(distance) && distance <= maxDistance;
          });
          if (!keptInfos.length) {
            keptInfos = [bestInfo];
          }
        } else if (rawDrop != null && rawDrop >= (onlyOneMargin - PV_EPSILON)) {
          reason = 'gap';
          keptInfos = bestInfo ? [bestInfo] : [];
        } else {
          keptInfos = [];
          for (const info of sorted) {
            if (keptInfos.length >= maxEntries) break;
            if (info === bestInfo) {
              keptInfos.push(info);
              continue;
            }
            if (bestEp == null) {
              keptInfos.push(info);
              continue;
            }
            if (Number.isFinite(info.ep) && (bestEp - info.ep) <= (keepMargin + PV_EPSILON)) {
              keptInfos.push(info);
            }
          }
          if (!keptInfos.length && bestInfo) {
            keptInfos = [bestInfo];
          }
        }

        const normalized = keptInfos.slice(0, maxEntries).map((info, idx) => {
          const ep = Number.isFinite(info.ep) ? info.ep : null;
          const base = {
            ...info.original,
            rank: idx + 1,
            expectedPoints: ep
          };
          if (reason === 'mate') {
            return { ...base, tag: 'Best' };
          }
          if (idx === 0) {
            return { ...base, tag: 'Best' };
          }
          if (bestEp != null && ep != null && (bestEp - ep) <= (bestMargin + PV_EPSILON)) {
            return { ...base, tag: 'Best' };
          }
          return { ...base, tag: 'Excellent' };
        });

        let message = null;
        if (originalCount >= 2) {
          if (reason === 'mate' && bestEvalParsed) {
            message = normalized.length > 1
              ? `Mating lines only — all listed moves deliver mate in ≤${Math.abs(bestEvalParsed.value) + mateSlack}.`
              : `Mate in ${Math.abs(bestEvalParsed.value)} is forced.`;
          } else if (normalized.length === 1) {
            if (dropPercentDisplay) {
              message = `Only one move keeps your chances; the rest drop ≈${dropPercentDisplay}.`;
            } else if (reason === 'gap') {
              message = `Only one move keeps your chances; the rest drop ≥${Math.round(onlyOneMargin * 100)}%.`;
            } else {
              message = 'Only one move met the quality bar.';
            }
          } else if (normalized.length > 1) {
            const approxMargin = Math.max(1, Math.round(keepMargin * 100));
            message = `These moves are within ~${approxMargin}% of each other; pick based on style/plan.`;
          }
        }

        return {
          entries: normalized,
          meta: {
            ...emptyMeta,
            keptCount: normalized.length,
            totalCandidates: originalCount,
            bestExpectedPoints: bestEp,
            secondExpectedPoints: secondEp,
            dropPercent: dropPercent != null ? dropPercent : null,
            dropPercentDisplay: dropPercentDisplay || null,
            reason,
            message,
            mateDistance: reason === 'mate' && bestInfo ? bestInfo.mateDistance : null
          }
        };
      }

      function buildPositionSummary(fen, entries = []) {
        if (!Array.isArray(entries) || entries.length === 0) {
          return null;
        }
        const byMove = new Map();
        const scored = [];

        entries.forEach((entry) => {
          if (!entry || !entry.uci) return;
          const ep = expectedPointsForMover(entry, fen);
          if (!Number.isFinite(ep)) return;
          byMove.set(entry.uci, {
            ep,
            tag: null,
            eval: entry.eval || null,
            pvSan: Array.isArray(entry.pvSan) ? entry.pvSan.slice() : null
          });
          scored.push({ uci: entry.uci, ep });
        });

        if (!scored.length) {
          return null;
        }

        scored.sort((a, b) => b.ep - a.ep);
        const EP1 = scored[0].ep;
        const bestUci = scored[0].uci;
        const bestEntry = entries.find((entry) => entry && entry.uci === bestUci) || null;
        const summaryBest = bestEntry ? { ...bestEntry, expectedPoints: EP1 } : null;
        const suggestions = [];
        const onlyOne = scored.length >= 2 && (EP1 - scored[1].ep) >= (EP_GAP_ONLY_ONE - PV_EPSILON);

        scored.forEach((item, idx) => {
          const gap = EP1 - item.ep;
          let tag;
          if (gap <= (EP_GAP_BEST_MAX + PV_EPSILON)) {
            tag = 'best';
          } else if (gap <= (EP_GAP_EXCELLENT_MAX + PV_EPSILON)) {
            tag = 'excellent';
          } else {
            tag = 'hide';
          }
          const info = byMove.get(item.uci);
          if (info) {
            info.tag = tag;
          }
          if (tag === 'hide') {
            return;
          }
          if (onlyOne && idx > 0) {
            return;
          }
          const original = entries.find((entry) => entry && entry.uci === item.uci) || null;
          if (original) {
            suggestions.push({
              ...original,
              expectedPoints: item.ep,
              tag: tag === 'best' ? 'Best' : 'Excellent'
            });
          } else {
            suggestions.push({ uci: item.uci, tag: tag === 'best' ? 'Best' : 'Excellent', expectedPoints: item.ep });
          }
        });

        return {
          EP1,
          best: summaryBest,
          byMove,
          suggestions
        };
      }

      function computeGreatOverlay({
        fen,
        EP1,
        epBefore,
        playedUci,
        byMove,
        legalMovesEp = [],
        epPlayedOverride = null,
        onlyMoveSampleComplete = false,
        moverRating = null
      }) {
        if (!playedUci || !Number.isFinite(EP1)) {
          return null;
        }
        let epPlayed = null;
        if (byMove instanceof Map) {
          const info = byMove.get(playedUci);
          if (info && Number.isFinite(info.ep)) {
            epPlayed = info.ep;
          }
        }
        if (!Number.isFinite(epPlayed) && Number.isFinite(epPlayedOverride)) {
          epPlayed = epPlayedOverride;
        }
        if (!Number.isFinite(epPlayed)) {
          return null;
        }
        const gap = EP1 - epPlayed;
        if (!Number.isFinite(gap) || gap > (EP_GAP_EXCELLENT_MAX + PV_EPSILON)) {
          return null;
        }

        let goodCount = 0;
        let playedCounted = false;
        let closestAlternativeGap = null;
        if (onlyMoveSampleComplete && Array.isArray(legalMovesEp)) {
          legalMovesEp.forEach((item) => {
            if (!item) return;
            const uci = item.uci;
            const ep = Number.isFinite(item.ep) ? item.ep : null;
            if (!Number.isFinite(ep)) return;
            const moveGap = EP1 - ep;
            if (moveGap <= (EP_GAP_EXCELLENT_MAX + PV_EPSILON)) {
              goodCount += 1;
              if (uci === playedUci) {
                playedCounted = true;
              }
            } else if (uci !== playedUci) {
              if (closestAlternativeGap == null || moveGap < closestAlternativeGap) {
                closestAlternativeGap = moveGap;
              }
            }
          });
        }

        const onlyMove = onlyMoveSampleComplete
          && playedCounted
          && goodCount === 1
          && gap <= (EP_GAP_EXCELLENT_MAX + PV_EPSILON)
          && (closestAlternativeGap == null || closestAlternativeGap >= (EP_GAP_ONLY_ONE - PV_EPSILON));

        let phaseFlip = false;
        if (Number.isFinite(epBefore)) {
          const delta = epPlayed - epBefore;
          if (delta >= (GREAT_PHASE_DELTA - PV_EPSILON)) {
            const ratingContext = Number.isFinite(moverRating) ? moverRating : getAverageGameRating();
            const losingBand = ratingLerp(ratingContext, 800, 2200, 0.32, 0.40);
            const equalBandLower = ratingLerp(ratingContext, 800, 2200, 0.42, 0.50);
            const equalBandUpper = ratingLerp(ratingContext, 800, 2200, 0.50, 0.58);
            const winningBand = ratingLerp(ratingContext, 800, 2200, 0.62, 0.70);
            const crossesLosingToEqual = epBefore < losingBand && epPlayed >= equalBandLower;
            const crossesEqualToWinning = epBefore >= equalBandLower
              && epBefore <= equalBandUpper
              && epPlayed >= winningBand;
            if (crossesLosingToEqual || crossesEqualToWinning) {
              phaseFlip = true;
            }
          }
        }

        return (onlyMove || phaseFlip) ? 'great' : null;
      }

      function createMovedPieceId(moveEntry) {
        if (!moveEntry) return null;
        const color = moveEntry.color === 'b' ? 'b' : (moveEntry.color === 'w' ? 'w' : null);
        const from = typeof moveEntry.from === 'string' ? moveEntry.from : null;
        const to = typeof moveEntry.to === 'string' ? moveEntry.to : null;
        if (!color || !from || !to) {
          return null;
        }
        const plyPart = Number.isFinite(moveEntry.ply) ? `#${moveEntry.ply}` : '';
        return `${color}:${from}->${to}${plyPart}`;
      }

      function captureSquareFromMove(result) {
        if (!result || !result.captured) {
          return null;
        }
        if (result.flags && result.flags.includes('e') && typeof result.to === 'string' && result.to.length === 2) {
          const file = result.to[0];
          const rank = parseInt(result.to[1], 10);
          if (!Number.isFinite(rank)) {
            return null;
          }
          const offset = result.color === 'w' ? -1 : 1;
          const capturedRank = rank + offset;
          if (capturedRank < 1 || capturedRank > 8) {
            return null;
          }
          return `${file}${capturedRank}`;
        }
        return typeof result.to === 'string' ? result.to : null;
      }

      function computeMaterialDeltaAfterMove(moveEntry) {
        if (!moveEntry || !moveEntry.preFen || !moveEntry.from || !moveEntry.to) return null;
        try {
          const game = new Chess(moveEntry.preFen);
          const mover = moveEntry.color === 'b' ? 'b' : 'w';
          const opponent = mover === 'w' ? 'b' : 'w';
          const beforeCounts = countPiecesOnBoard(game.board());
          const beforeMoverMaterial = sumMaterial(beforeCounts[mover]);
          const beforeDiff = beforeMoverMaterial - sumMaterial(beforeCounts[opponent]);
          const executed = game.move({
            from: moveEntry.from,
            to: moveEntry.to,
            promotion: moveEntry.promotion
          });
          if (!executed) return null;
          const afterCounts = countPiecesOnBoard(game.board());
          const afterMoverMaterial = sumMaterial(afterCounts[mover]);
          const afterDiff = afterMoverMaterial - sumMaterial(afterCounts[opponent]);
          const capturedType = executed.captured || null;
          const capturedValue = capturedType ? (pieceValues[capturedType] || 0) : 0;
          return {
            before: beforeDiff,
            after: afterDiff,
            delta: afterDiff - beforeDiff,
            beforeUs: beforeMoverMaterial,
            afterUs: afterMoverMaterial,
            deltaUs: afterMoverMaterial - beforeMoverMaterial,
            movedPieceId: createMovedPieceId(moveEntry),
            movedTo: moveEntry.to || null,
            movedPieceType: executed.piece || null,
            movedPieceValue: executed.piece ? (pieceValues[executed.piece] || 0) : null,
            captured: {
              type: capturedType,
              value: capturedValue
            }
          };
        } catch (err) {
          console.warn('Failed to compute material delta', err);
          return null;
        }
      }

      function computeMaterialDeltaAfterReply(moveEntry, actualEntry) {
        if (!moveEntry || !moveEntry.preFen || !moveEntry.from || !moveEntry.to) return null;
        const pvMoves = actualEntry && Array.isArray(actualEntry.pvMoves) ? actualEntry.pvMoves : null;
        const pvSan = actualEntry && Array.isArray(actualEntry.pvSan) ? actualEntry.pvSan : null;
        const replyUci = pvMoves && pvMoves.length > 1 && typeof pvMoves[1] === 'string' ? pvMoves[1] : null;
        const replySan = pvSan && pvSan.length > 1 && typeof pvSan[1] === 'string' ? pvSan[1] : null;
        const reReplyUci = pvMoves && pvMoves.length > 2 && typeof pvMoves[2] === 'string' ? pvMoves[2] : null;
        const reReplySan = pvSan && pvSan.length > 2 && typeof pvSan[2] === 'string' ? pvSan[2] : null;
        if (!replyUci && !replySan) {
          return null;
        }
        try {
          const game = new Chess(moveEntry.preFen);
          const mover = moveEntry.color === 'b' ? 'b' : 'w';
          const opponent = mover === 'w' ? 'b' : 'w';
          const beforeCounts = countPiecesOnBoard(game.board());
          const beforeMoverMaterial = sumMaterial(beforeCounts[mover]);
          const beforeDiff = beforeMoverMaterial - sumMaterial(beforeCounts[opponent]);
          const executed = game.move({
            from: moveEntry.from,
            to: moveEntry.to,
            promotion: moveEntry.promotion
          });
          if (!executed) return null;
          const movedPieceId = createMovedPieceId(moveEntry);
          const movedTo = moveEntry.to || null;
          let replyApplied = false;
          let replyResult = null;
          if (replyUci && /^[a-h][1-8][a-h][1-8][qrbn]?$/.test(replyUci)) {
            const replyMove = {
              from: replyUci.slice(0, 2),
              to: replyUci.slice(2, 4)
            };
            if (replyUci.length > 4) {
              replyMove.promotion = replyUci.slice(4);
            }
            replyResult = game.move(replyMove);
            if (replyResult) {
              replyApplied = true;
            }
          }
          if (!replyApplied && replySan) {
            try {
              replyResult = game.move(replySan);
              if (replyResult) {
                replyApplied = true;
              }
            } catch (err) {
              // ignore SAN parsing failures
            }
          }
          if (!replyApplied) return null;
          const afterCounts = countPiecesOnBoard(game.board());
          const afterMoverMaterial = sumMaterial(afterCounts[mover]);
          const afterDiff = afterMoverMaterial - sumMaterial(afterCounts[opponent]);
          const replyCapturedType = replyResult && replyResult.captured ? replyResult.captured : null;
          const replyCapturedValue = replyCapturedType ? (pieceValues[replyCapturedType] || 0) : 0;
          const replyCapturedSquare = captureSquareFromMove(replyResult);
          const capturedMovedPiece = Boolean(replyCapturedSquare && movedTo && replyCapturedSquare === movedTo);
          let reReplyApplied = false;
          let reReplyResult = null;
          if (reReplyUci && /^[a-h][1-8][a-h][1-8][qrbn]?$/.test(reReplyUci)) {
            const followMove = {
              from: reReplyUci.slice(0, 2),
              to: reReplyUci.slice(2, 4)
            };
            if (reReplyUci.length > 4) {
              followMove.promotion = reReplyUci.slice(4);
            }
            reReplyResult = game.move(followMove);
            if (reReplyResult) {
              reReplyApplied = true;
            }
          }
          if (!reReplyApplied && reReplySan) {
            try {
              reReplyResult = game.move(reReplySan);
              if (reReplyResult) {
                reReplyApplied = true;
              }
            } catch (err) {
              // ignore SAN parsing failures
            }
          }
          let afterReReplyCounts = null;
          let afterReReplyMoverMaterial = null;
          let afterReReplyDiff = null;
          if (reReplyApplied) {
            afterReReplyCounts = countPiecesOnBoard(game.board());
            afterReReplyMoverMaterial = sumMaterial(afterReReplyCounts[mover]);
            afterReReplyDiff = afterReReplyMoverMaterial - sumMaterial(afterReReplyCounts[opponent]);
          }
          return {
            before: beforeDiff,
            after: afterDiff,
            delta: afterDiff - beforeDiff,
            beforeUs: beforeMoverMaterial,
            afterUs: afterMoverMaterial,
            deltaUs: afterMoverMaterial - beforeMoverMaterial,
            movedPieceId,
            movedTo,
            lostAfterReply: {
              type: replyCapturedType,
              value: replyCapturedValue,
              square: replyCapturedSquare,
              pieceId: capturedMovedPiece ? movedPieceId : null,
              isMovedPiece: capturedMovedPiece
            },
            reReplyUci: reReplyApplied && reReplyUci ? reReplyUci : null,
            reReplySan: reReplyApplied && reReplySan ? reReplySan : null,
            afterReReply: reReplyApplied && Number.isFinite(afterReReplyDiff) ? afterReReplyDiff : null,
            afterUsReReply: reReplyApplied && Number.isFinite(afterReReplyMoverMaterial) ? afterReReplyMoverMaterial : null,
            deltaAfterReReply: reReplyApplied && Number.isFinite(afterReReplyDiff)
              ? afterReReplyDiff - beforeDiff
              : null,
            deltaUsAfterReReply: reReplyApplied && Number.isFinite(afterReReplyMoverMaterial)
              ? afterReReplyMoverMaterial - beforeMoverMaterial
              : null
          };
        } catch (err) {
          console.warn('Failed to compute material delta after reply', err);
          return null;
        }
      }

      function applySpecialPromotions({
        baseLabel,
        preEvalCp,
        postEvalCp,
        bestLineEvalCp,
        secondBestEvalCp,
        materialDeltaAfterMove,
        materialDeltaAfterReply = null,
        preEval = null,
        postEval = null,
        phase = null,
        moveSan = null,
        sacrificeInfo = null,
        epBeforeMover = null,
        postEvalCpAfterReReply = null,
        bestMoverEp = null,
        secondBestMoverEp = null,
        playedMoverEp = null,
        altMaxMoverEp = null
      }) {
        if (!enableSpecialPromotions) {
          return null;
        }
        const normalizedBase = typeof baseLabel === 'string' ? baseLabel.toLowerCase() : '';
        if (!(normalizedBase === 'best' || normalizedBase === 'excellent')) {
          return null;
        }

        const normalizedPreBest = preEval && preEval.best ? preEval.best : null;
        const normalizedPreSecond = preEval && preEval.secondBest ? preEval.secondBest : null;
        const fallbackPreBest = !normalizedPreBest && Number.isFinite(preEvalCp) ? { cp: preEvalCp } : null;
        const fallbackPreSecond = !normalizedPreSecond && Number.isFinite(secondBestEvalCp) ? { cp: secondBestEvalCp } : null;
        const preBestEval = normalizedPreBest || fallbackPreBest;
        const preSecondEval = normalizedPreSecond || fallbackPreSecond;
        const postEvalObj = postEval || (Number.isFinite(postEvalCp) ? { cp: postEvalCp } : null);
        const sacInfo = sacrificeInfo || {};
        const sacLostIsMovedPiece = Boolean(sacInfo.lostIsMovedPiece);
        const sacNetLoss = Number.isFinite(sacInfo.netLost) ? sacInfo.netLost : null;
        const sacCapturedValue = Number.isFinite(sacInfo.capturedOnMoveValue) ? sacInfo.capturedOnMoveValue : 0;
        const sacLostValue = Number.isFinite(sacInfo.lostAfterReplyValue) ? sacInfo.lostAfterReplyValue : 0;
        const sacLostSquare = sacInfo.lostAfterReplySquare || null;
        const sacLostPieceId = sacInfo.lostAfterReplyPieceId || null;
        const sacNetAfterReReply = Number.isFinite(sacInfo.deltaAfterReReplyNet) ? sacInfo.deltaAfterReReplyNet : null;
        const isDirectSacrifice1Ply = sacInfo.isDirectSacrifice === true;
        const isDirectSacrifice2Ply = sacInfo.isDirectSacrifice2Ply === true;
        const comparisonPreCp = Number.isFinite(preEvalCp)
          ? preEvalCp
          : (preBestEval && Number.isFinite(preBestEval.cp) ? preBestEval.cp : null);
        const comparisonPostCp = Number.isFinite(postEvalCp)
          ? postEvalCp
          : (postEvalObj && Number.isFinite(postEvalObj.cp) ? postEvalObj.cp : null);
        const comparisonPostReReplyCp = Number.isFinite(postEvalCpAfterReReply)
          ? postEvalCpAfterReReply
          : comparisonPostCp;

        const cpNearBest = Number.isFinite(bestLineEvalCp)
          && Number.isFinite(comparisonPostCp)
          && (bestLineEvalCp - comparisonPostCp) <= NEAR_BEST_CP;
        const isMateBefore = mateForUs(preBestEval);
        const isMateAfter = mateForUs(postEvalObj);
        const nearBest = cpNearBest || (isMateBefore && isMateAfter);
        const nearBestBaseline = (normalizedBase === 'best') || nearBest;
        const mateDepthAfter = isMateAfter && postEvalObj && Number.isFinite(postEvalObj.mate)
          ? Math.abs(postEvalObj.mate)
          : null;
        const isFinalMateMove = isMateAfter && mateDepthAfter === 1;
        const opponentCapturedMovedPiece = sacLostIsMovedPiece && sacLostValue > 0;
        const mateSac = nearBestBaseline
          && isMateAfter
          && mateDepthAfter != null
          && mateDepthAfter <= BRILLIANT_MATE_SAC_MAX_DEPTH
          && !isFinalMateMove
          && isDirectSacrifice1Ply
          && opponentCapturedMovedPiece;
        if (mateSac) {
          const tooltipParts = ['Promoted to Brilliant: sacrificial forced mate.'];
          tooltipParts.push(`Mate in ${mateDepthAfter}.`);
          return {
            label: 'brilliant',
            reason: 'brilliant-mate-sacrifice',
            tooltip: tooltipParts.join(' '),
            promotionPath: 'mateSac',
            log: {
              move: moveSan || null,
              baseLabel: normalizedBase,
              promotedTo: 'brilliant',
              reason: 'brilliant-mate-sacrifice',
              mateDepthAfter,
              materialDeltaAfterMove,
              materialDeltaAfterReply,
              preEvalCp,
              postEvalCp,
              bestLineEvalCp,
              secondBestEvalCp,
              sacCapturedValue,
              sacLostValue,
              sacNetLoss,
              sacLostSquare,
              sacLostPieceId,
              isDirectSacrifice1Ply,
              isDirectSacrifice2Ply,
              opponentCapturedMovedPiece,
              isFinalMateMove,
              postEvalCpAfterReReply,
              mateSacResult: true,
              nonMateBrilliantResult: false
            }
          };
        }

        const endgameOnlyMove = phase === 'endgame'
          ? (Number.isFinite(bestLineEvalCp)
            && Number.isFinite(secondBestEvalCp)
            && (bestLineEvalCp - secondBestEvalCp) >= ONLY_MOVE_GAP_CP)
          : true;

        const bestVsSecondGap = Number.isFinite(bestLineEvalCp)
          && Number.isFinite(secondBestEvalCp)
          ? (bestLineEvalCp - secondBestEvalCp)
          : null;
        const onlyMoveGapCp = Number.isFinite(bestLineEvalCp)
          ? bestLineEvalCp - (Number.isFinite(secondBestEvalCp) ? secondBestEvalCp : -Infinity)
          : null;
        const epGapToSecond = Number.isFinite(bestMoverEp) && Number.isFinite(secondBestMoverEp)
          ? (bestMoverEp - secondBestMoverEp)
          : null;
        const epNearBestPlayed = Number.isFinite(bestMoverEp)
          && Number.isFinite(playedMoverEp)
          && Math.abs(bestMoverEp - playedMoverEp) <= (0.02 + PV_EPSILON);
        const cpKeepsEvaluation = Number.isFinite(comparisonPreCp)
          && Number.isFinite(comparisonPostReReplyCp)
          && comparisonPostReReplyCp >= (comparisonPreCp - 50);
        const hasLargeOnlyMoveGap = onlyMoveGapCp != null && onlyMoveGapCp >= 150;

        if (nearBestBaseline
          && !isMateAfter
          && isDirectSacrifice2Ply
          && epNearBestPlayed
          && cpKeepsEvaluation
          && hasLargeOnlyMoveGap
          && endgameOnlyMove) {
          const gapText = formatNegativeCpGap(bestVsSecondGap);
          const evalText = formatCpAsPawnString(postEvalCpAfterReReply, { forceSign: true });
          const tooltipParts = ['Promoted to Brilliant: sacrifice kept the evaluation on track.'];
          if (evalText) {
            tooltipParts.push(`Eval ≈ ${evalText}.`);
          }
          if (gapText) {
            tooltipParts.push(`2nd-best is ${gapText} worse.`);
          }
          return {
            label: 'brilliant',
            reason: 'brilliant-sacrifice',
            tooltip: tooltipParts.join(' '),
            promotionPath: 'nonMateSac',
            log: {
              move: moveSan || null,
              baseLabel: normalizedBase,
              promotedTo: 'brilliant',
              reason: 'brilliant-sacrifice',
              preEvalCp,
              postEvalCp,
              bestLineEvalCp,
              secondBestEvalCp,
              materialDeltaAfterMove,
              materialDeltaAfterReply,
              sacCapturedValue,
              sacLostValue,
              sacNetLoss,
              sacNetAfterReReply,
              sacLostSquare,
              sacLostPieceId,
              postEvalCpAfterReReply,
              epNearBestPlayed,
              cpKeepsEvaluation,
              hasLargeOnlyMoveGap,
              mateSacResult: false,
              nonMateBrilliantResult: true
            }
          };
        }

        const normalizedEpBefore = clampExpectedPoints(epBeforeMover);
        const normalizedEpPlayed = clampExpectedPoints(playedMoverEp);
        const normalizedEpAltMax = clampExpectedPoints(
          Number.isFinite(altMaxMoverEp)
            ? altMaxMoverEp
            : (Number.isFinite(secondBestMoverEp) ? secondBestMoverEp : null)
        );

        const bandBefore = getOutcomeBand(normalizedEpBefore);
        const bandPlayed = getOutcomeBand(normalizedEpPlayed);
        const bandAltMax = getOutcomeBand(normalizedEpAltMax);
        const decisiveBefore = isDecisiveEp(normalizedEpBefore);
        const decisiveAfter = isDecisiveEp(normalizedEpPlayed);
        const altDecisive = isDecisiveEp(normalizedEpAltMax);
        const epGapAlt = (Number.isFinite(normalizedEpPlayed) && Number.isFinite(normalizedEpAltMax))
          ? (normalizedEpPlayed - normalizedEpAltMax)
          : null;

        const bandRankBefore = bandBefore != null ? GREAT_BAND_ORDER[bandBefore] : null;
        const bandRankPlayed = bandPlayed != null ? GREAT_BAND_ORDER[bandPlayed] : null;
        const bandRankAlt = bandAltMax != null ? GREAT_BAND_ORDER[bandAltMax] : null;

        const swingUp = Number.isFinite(normalizedEpBefore)
          && Number.isFinite(normalizedEpPlayed)
          && bandRankBefore != null
          && bandRankPlayed != null
          && bandRankPlayed > bandRankBefore
          && (normalizedEpPlayed - normalizedEpBefore) >= (GREAT_SWING_MIN_DELTA - PV_EPSILON);

        const keepsBand = bandRankBefore != null
          && bandRankPlayed != null
          && bandRankPlayed >= bandRankBefore;

        const othersDropClass = Number.isFinite(normalizedEpPlayed)
          && Number.isFinite(normalizedEpAltMax)
          && bandRankAlt != null
          && bandRankPlayed != null
          && bandRankAlt < bandRankPlayed
          && epGapAlt != null
          && epGapAlt >= (GREAT_ONLY_MOVE_MIN_DELTA - PV_EPSILON);

        const onlyMoveGreat = keepsBand && othersDropClass;
        const sameDecisiveBand = decisiveBefore
          && decisiveAfter
          && bandBefore != null
          && bandPlayed != null
          && bandBefore === bandPlayed;
        const alternativesKeepDecisive = sameDecisiveBand
          && altDecisive
          && bandAltMax === bandPlayed;

        const bandLabels = { loss: 'fighting on', draw: 'drawing', win: 'winning' };
        let reason = null;
        let reasonKey = null;
        let tooltipParts = null;
        if (nearBestBaseline && !isMateAfter && !isMateBefore) {
          if (swingUp) {
            reason = 'great-swing';
            reasonKey = 'swing';
            tooltipParts = ['Promoted to Great: turned the outcome band.'];
            const fromBand = bandBefore ? bandLabels[bandBefore] : null;
            const toBand = bandPlayed ? bandLabels[bandPlayed] : null;
            if (fromBand && toBand) {
              tooltipParts.push(`Position improved from ${fromBand} to ${toBand}.`);
            }
          } else if (onlyMoveGreat && !alternativesKeepDecisive) {
            reason = 'great-only-move';
            reasonKey = 'onlyMove';
            tooltipParts = ['Promoted to Great: only move kept the outcome on track.'];
            if (bandPlayed) {
              tooltipParts.push(`This move keeps a ${bandLabels[bandPlayed]} result.`);
            }
            if (bandAltMax) {
              tooltipParts.push(`Alternatives slip to ${bandLabels[bandAltMax]} positions.`);
            }
            if (Number.isFinite(epGapAlt)) {
              const gapText = formatWinDeltaDisplay(epGapAlt * 100);
              if (gapText) {
                tooltipParts.push(`Next-best drops ${gapText} in win chances.`);
              }
            }
          }
        }

        if (reason) {
          return {
            label: 'great',
            reason,
            tooltip: tooltipParts ? tooltipParts.join(' ') : 'Promoted to Great.',
            log: {
              move: moveSan || null,
              baseLabel: normalizedBase,
              promotedTo: 'great',
              reason,
              preEvalCp,
              postEvalCp,
              bestLineEvalCp,
              secondBestEvalCp,
              materialDeltaAfterMove,
              bandBefore,
              bandPlayed,
              bandAltMax,
              decisiveBefore,
              decisiveAfter,
              epGapAlt,
              swingUp,
              onlyMoveGreat,
              greatReason: reasonKey
            }
          };
        }

        return null;
      }

      function computeMoveAccuracy(winPercentBefore, winPercentAfter) {
        if (!Number.isFinite(winPercentBefore) || !Number.isFinite(winPercentAfter)) {
          return null;
        }
        const delta = winPercentBefore - winPercentAfter;
        const raw = 103.1668 * Math.exp(-0.04354 * delta) - 3.1669;
        return Math.max(0, Math.min(100, raw));
      }

      // Consider a move a "sacrifice" only if, after an immediate capture
      // and recapture sequence on the landing square, the net material balance
      // (mover minus opponent) worsens by at least three points compared to
      // before the move. We evaluate the opponent capture, then the mover's
      // best recapture on that same square.
      function detectSacrifice(moveEntry) {
        if (!moveEntry || !moveEntry.preFen || !moveEntry.fen) return false;
        try {
          const before = new Chess(moveEntry.preFen);
          const moved = before.get(moveEntry.from);
          if (!moved) return false;

          const movedVal = pieceValues[moved.type];
          if (!Number.isFinite(movedVal) || movedVal < 3) {
            return false;
          }

          const mover = moveEntry.color;
          const opponent = mover === 'w' ? 'b' : 'w';

          const beforeCounts = countPiecesOnBoard(before.board());
          const diffBefore = sumMaterial(beforeCounts[mover]) - sumMaterial(beforeCounts[opponent]);

          const after = new Chess(moveEntry.fen);
          const targetSquare = moveEntry.to;
          const replies = after.moves({ verbose: true });
          for (const reply of replies) {
            if (!reply || !reply.flags || !reply.flags.includes('c')) continue;
            if (reply.to !== targetSquare) continue;
            const replyGame = new Chess(moveEntry.fen);
            const executedReply = replyGame.move({ from: reply.from, to: reply.to, promotion: reply.promotion });
            if (!executedReply) continue;
            const replyCounts = countPiecesOnBoard(replyGame.board());
            const diffAfterCapture = sumMaterial(replyCounts[mover]) - sumMaterial(replyCounts[opponent]);

            const replyFen = replyGame.fen();
            const recaptures = replyGame.moves({ verbose: true });
            let hasRecapture = false;
            let bestRecaptureDiff = null;
            recaptures.forEach((recap) => {
              if (!recap || !recap.flags || !recap.flags.includes('c')) return;
              if (recap.to !== targetSquare) return;
              hasRecapture = true;
              const recapGame = new Chess(replyFen);
              const executedRecap = recapGame.move({ from: recap.from, to: recap.to, promotion: recap.promotion });
              if (!executedRecap) return;
              const recapCounts = countPiecesOnBoard(recapGame.board());
              const diffAfterRecap = sumMaterial(recapCounts[mover]) - sumMaterial(recapCounts[opponent]);
              if (bestRecaptureDiff == null || diffAfterRecap > bestRecaptureDiff) {
                bestRecaptureDiff = diffAfterRecap;
              }
            });

            if (hasRecapture) {
              if ((bestRecaptureDiff - diffBefore) <= -3) {
                return true;
              }
            } else {
              if ((diffAfterCapture - diffBefore) <= -3) {
                return true;
              }
            }
          }
        } catch (err) {
          console.warn('Failed to evaluate sacrifice', err);
        }
        return false;
      }

      function convertPvToVerbose(fen, moves, limit = 12) {
        const out = [];
        if (!fen || !Array.isArray(moves) || moves.length === 0) {
          return out;
        }
        try {
          const game = new Chess(fen);
          for (const raw of moves) {
            if (typeof raw !== 'string' || raw.length < 4) continue;
            const move = {
              from: raw.slice(0, 2),
              to: raw.slice(2, 4),
              promotion: raw.length > 4 ? raw.slice(4) : undefined
            };
            const played = game.move(move);
            if (!played) break;
            out.push({ ...played, uci: raw, fen: game.fen() });
            if (out.length >= limit) break;
          }
        } catch (err) {
          console.warn('Failed to expand PV line', err);
        }
        return out;
      }

      function describePiece(type) {
        const lower = String(type || '').toLowerCase();
        return pieceNames[lower] || 'piece';
      }

      function formatWinPercentDisplay(value) {
        if (!Number.isFinite(value)) return null;
        if (value >= 99) return '99%';
        if (value <= 1) return '1%';
        if (value >= 10 && value <= 90) return `${Math.round(value)}%`;
        if (value > 90) return `${value.toFixed(0)}%`;
        return `${value.toFixed(1)}%`;
      }

      function formatWinDeltaDisplay(value) {
        if (!Number.isFinite(value)) return null;
        const abs = Math.abs(value);
        if (abs >= 30) return `${Math.round(abs)}%`;
        if (abs >= 10) return `${abs.toFixed(0)}%`;
        if (abs >= 3) return `${abs.toFixed(1)}%`;
        return `${abs.toFixed(1)}%`;
      }

      function formatCpAsPawnString(cp, { forceSign = false } = {}) {
        if (!Number.isFinite(cp)) return null;
        const pawns = cp / 100;
        const abs = Math.abs(pawns);
        const decimals = abs >= 1 ? 1 : 2;
        const rounded = pawns.toFixed(decimals);
        if (rounded.startsWith('-')) {
          return rounded;
        }
        if (forceSign && !rounded.startsWith('+')) {
          return `+${rounded}`;
        }
        return rounded;
      }

      function formatNegativeCpGap(cpGap) {
        if (!Number.isFinite(cpGap)) return null;
        return formatCpAsPawnString(-Math.abs(cpGap), { forceSign: true });
      }

      function winPercentForEntry(entry, moverColor, fen = null) {
        if (!entry) return null;
        const epMover = expectedPointsForMover(entry, fen, moverColor);
        if (!Number.isFinite(epMover)) return null;
        return Math.max(0, Math.min(100, epMover * 100));
      }

      function buildContinuationEntry(label, sanMoves, limit = 6) {
        if (!Array.isArray(sanMoves) || !sanMoves.length) return null;
        const moves = sanMoves.filter(Boolean).slice(0, limit);
        if (!moves.length) return null;
        return {
          type: 'continuation',
          label: label || null,
          moves
        };
      }

      function isContinuationEntry(value) {
        return Boolean(value && typeof value === 'object' && value.type === 'continuation' && Array.isArray(value.moves));
      }

      function createMoveTokenButton(san) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'pv-move-token';
        button.dataset.san = san;
        button.textContent = san;
        button.setAttribute('aria-label', `Preview move ${san}`);
        return button;
      }

      function createContinuationListItem(entry) {
        if (!isContinuationEntry(entry)) return null;
        const item = document.createElement('li');
        if (entry.label) {
          const label = document.createElement('span');
          label.className = 'pv-continuation-label';
          label.textContent = `${entry.label}:`;
          item.appendChild(label);
          if (entry.moves.length) {
            item.appendChild(document.createTextNode(' '));
          }
        }
        entry.moves.forEach((san, index) => {
          if (!san) return;
          const value = typeof san === 'string' ? san.trim() : String(san);
          if (!value) return;
          const token = createMoveTokenButton(value);
          item.appendChild(token);
          if (index < entry.moves.length - 1) {
            item.appendChild(document.createTextNode(' '));
          }
        });
        return item;
      }

      function buildMoveExplanation({
        moveEntry,
        bestEntry,
        actualEntry,
        bestEval,
        actualEval,
        beforeEp,
        bestEp,
        actualEp,
        cpLoss,
        classification,
        overlay,
        planScenarios
      }) {
        if (!moveEntry) return null;
        const moverIsWhite = moveEntry.color !== 'b';
        const moverColorName = moverIsWhite ? 'White' : 'Black';
        const opponentColorName = moverIsWhite ? 'Black' : 'White';
        const labelMap = {
          brilliant: 'Brilliant move',
          great: 'Great move',
          miss: 'Missed win',
          best: 'Best move',
          excellent: 'Excellent move',
          good: 'Good move',
          inaccuracy: 'Inaccuracy',
          mistake: 'Mistake',
          blunder: 'Blunder',
          book: 'Book move'
        };
        const key = overlay || classification;
        const labelText = labelMap[key] || labelMap[classification] || 'Move review';

        const beforeMoverEp = Number.isFinite(beforeEp)
          ? (moverIsWhite ? beforeEp : 1 - beforeEp)
          : (Number.isFinite(bestEp) ? (moverIsWhite ? bestEp : 1 - bestEp) : null);
        const actualMoverEp = Number.isFinite(actualEp)
          ? (moverIsWhite ? actualEp : 1 - actualEp)
          : null;
        const bestMoverEp = Number.isFinite(bestEp)
          ? (moverIsWhite ? bestEp : 1 - bestEp)
          : null;

        const beforePercent = Number.isFinite(beforeMoverEp) ? beforeMoverEp * 100 : null;
        const afterPercent = Number.isFinite(actualMoverEp) ? actualMoverEp * 100 : null;
        const bestPercent = Number.isFinite(bestMoverEp) ? bestMoverEp * 100 : null;

        const dropFromBefore = (beforePercent != null && afterPercent != null)
          ? beforePercent - afterPercent
          : null;
        const missFromBest = (bestPercent != null && afterPercent != null)
          ? bestPercent - afterPercent
          : null;
        const improvement = (beforePercent != null && afterPercent != null)
          ? afterPercent - beforePercent
          : null;

        let summaryClause = null;
        if (dropFromBefore != null && dropFromBefore > 0.75) {
          const approx = formatWinDeltaDisplay(dropFromBefore);
          summaryClause = `drops about ${approx} win chance`;
        } else if (missFromBest != null && missFromBest > 0.75) {
          const approx = formatWinDeltaDisplay(missFromBest);
          summaryClause = `misses roughly ${approx} win chance`;
        } else if (improvement != null && improvement > 0.75) {
          const approx = formatWinDeltaDisplay(improvement);
          summaryClause = `improves ${moverColorName.toLowerCase()}’s chances by about ${approx}`;
        } else if (cpLoss != null && cpLoss >= 20) {
          const pawns = cpLoss / 100;
          const pawnText = Math.abs(pawns) >= 1 ? pawns.toFixed(1) : pawns.toFixed(2);
          summaryClause = `drops roughly ${pawnText} pawns`;
        } else if (afterPercent != null && summaryClause == null) {
          const approx = formatWinPercentDisplay(afterPercent);
          if (approx) {
            summaryClause = `leaves ${moverColorName.toLowerCase()} with about ${approx} win chance`;
          }
        }

        const summary = summaryClause ? `${labelText} — ${summaryClause}.` : `${labelText}.`;

        const details = [];
        const actualLine = actualEntry && Array.isArray(actualEntry.pvVerbose)
          ? actualEntry.pvVerbose
          : [];
        const bestLine = bestEntry && Array.isArray(bestEntry.pvVerbose)
          ? bestEntry.pvVerbose
          : [];
        const actualFirst = actualLine[0];
        const opponentReply = actualLine[1];
        const bestFirst = bestLine[0];

        if (actualEval && actualEval.type === 'mate') {
          const moves = Math.abs(actualEval.value);
          const mateForMover = (moverIsWhite && actualEval.value > 0) || (!moverIsWhite && actualEval.value < 0);
          if (mateForMover) {
            details.push(`${moverColorName} has mate in ${moves} on the board.`);
          } else {
            details.push(`${opponentColorName} can force mate in ${moves}.`);
          }
        } else if (bestEval && bestEval.type === 'mate') {
          const moves = Math.abs(bestEval.value);
          const mateForMover = (moverIsWhite && bestEval.value > 0) || (!moverIsWhite && bestEval.value < 0);
          if (mateForMover) {
            const moveLabel = bestEntry ? (bestEntry.san || bestEntry.uci) : 'the best line';
            details.push(`${moverColorName} had mate in ${moves} starting with ${moveLabel}.`);
          } else {
            details.push(`${opponentColorName} was threatening mate in ${moves}; the engine line addresses it.`);
          }
        }

        if (opponentReply && opponentReply.captured) {
          const captured = describePiece(opponentReply.captured);
          details.push(`${opponentColorName} replies with ${opponentReply.san}, winning your ${captured}.`);
        }

        if (actualFirst && actualFirst.captured && (!opponentReply || !opponentReply.captured)) {
          const captured = describePiece(actualFirst.captured);
          details.push(`${moverColorName} gains a ${captured} with ${actualFirst.san}.`);
        }

        if (bestFirst) {
          if (bestFirst.captured && (!actualFirst || bestFirst.uci !== actualFirst.uci)) {
            const captured = describePiece(bestFirst.captured);
            details.push(`Engine prefers ${bestFirst.san} to collect the ${captured}.`);
          } else if (bestFirst.san && bestFirst.san.includes('+') && (!actualFirst || !actualFirst.san || !actualFirst.san.includes('+'))) {
            details.push(`Engine move ${bestFirst.san} keeps the initiative with check.`);
          }
        }

        if (bestEntry && actualEntry && bestEntry.uci !== actualEntry.uci) {
          if (bestPercent != null && afterPercent != null && bestPercent > afterPercent + 0.75) {
            const beforeText = formatWinPercentDisplay(bestPercent);
            const afterText = formatWinPercentDisplay(afterPercent);
            if (beforeText && afterText) {
              details.push(`${bestEntry.san || bestEntry.uci} keeps ${moverColorName.toLowerCase()} near ${beforeText} instead of ${afterText}.`);
            }
          } else if (bestEntry.eval) {
            details.push(`Engine evaluation after ${bestEntry.san || bestEntry.uci}: ${bestEntry.eval}.`);
          }
        } else if (bestEntry && actualEntry && bestEntry.uci === actualEntry.uci) {
          details.push('Matches the engine’s first choice.');
        }

        if (!planScenarios && bestEntry && Array.isArray(bestEntry.pvSan) && bestEntry.pvSan.length > 0) {
          const continuation = buildContinuationEntry('Line', bestEntry.pvSan, 6);
          if (continuation) {
            details.push(continuation);
          }
        }

        const cards = [];
        const planActual = planScenarios && planScenarios.actual ? planScenarios.actual : null;
        const planBest = planScenarios && planScenarios.best ? planScenarios.best : null;
        const ideaPlan = planActual || planBest;

        function makePlanHeadline(plan) {
          if (!plan) return null;
          const moveLabel = plan.moveSan || plan.moveUci || 'the move';
          const parts = [`Play ${moveLabel}`];
          if (plan.moverWinPercent != null) {
            const approx = formatWinPercentDisplay(plan.moverWinPercent);
            if (approx) {
              parts.push(`keeps ${moverColorName.toLowerCase()} near ${approx}`);
            }
          } else if (plan.delta != null) {
            const approx = formatWinDeltaDisplay(Math.abs(plan.delta));
            if (approx) {
              if (plan.delta >= 0) {
                parts.push(`improves chances by about ${approx}`);
              } else {
                parts.push(`costs roughly ${approx}`);
              }
            }
          }
          return parts.join(' — ');
        }

        function buildPlanBullets(plan, opts = {}) {
          const bullets = [];
          if (!plan) return bullets;
          if (plan.delta != null && plan.moverWinPercent != null && plan.beforeWinPercent != null && Math.abs(plan.delta) >= 0.75) {
            const approx = formatWinDeltaDisplay(plan.delta);
            if (approx) {
              bullets.push(`${plan.delta >= 0 ? 'Improves' : 'Drops'} the position by about ${approx}.`);
            }
          }
          if (plan.isMate) {
            bullets.push('Forces mate immediately.');
          } else if (plan.isCheck) {
            bullets.push('Delivers check to keep the initiative.');
          }
          if (plan.isCapture && plan.capturePiece) {
            bullets.push(`Wins a ${plan.capturePiece}.`);
          }
          if (plan.replySan && opts.showReply && plan.replyWinPercent != null) {
            const after = formatWinPercentDisplay(plan.replyWinPercent);
            if (after) {
              bullets.push(`${opponentColorName} can answer with ${plan.replySan}, leaving ${moverColorName.toLowerCase()} around ${after}.`);
            } else {
              bullets.push(`${opponentColorName} can answer with ${plan.replySan}.`);
            }
          } else if (plan.replySan && opts.showReply) {
            bullets.push(`${opponentColorName} can answer with ${plan.replySan}.`);
          }
          if (plan.replyCaptures) {
            bullets.push(`${plan.replySan} targets your ${plan.replyCaptures}.`);
          }
          if (plan.ignoreWinPercent != null && plan.replyWinPercent != null && Math.abs(plan.ignoreWinPercent - plan.replyWinPercent) >= 1.5) {
            const ignore = formatWinPercentDisplay(plan.ignoreWinPercent);
            const after = formatWinPercentDisplay(plan.replyWinPercent);
            if (ignore && after) {
              bullets.push(`If ${opponentColorName.toLowerCase()} ignores it, you stay near ${ignore} instead of ${after}.`);
            }
          }
          const continuation = buildContinuationEntry('Line', plan.snippet, 6);
          if (continuation) {
            bullets.push(continuation);
          }
          return bullets;
        }

        if (ideaPlan) {
          const ideaHeadline = makePlanHeadline(ideaPlan);
          const bullets = buildPlanBullets(ideaPlan, { showReply: Boolean(planActual && planActual === ideaPlan) });
          cards.push({
            key: 'idea',
            title: 'Idea',
            headline: ideaHeadline,
            bullets
          });
        }

        if (planActual && planActual.replySan) {
          const headline = `${opponentColorName} can meet it with ${planActual.replySan}`;
          const bullets = [];
          const after = formatWinPercentDisplay(planActual.replyWinPercent);
          if (after) {
            bullets.push(`Your chances drop to about ${after}.`);
          }
          if (planActual.replyCaptures) {
            bullets.push(`That move wins your ${planActual.replyCaptures}.`);
          }
          if (planActual.ignoreWinPercent != null && planActual.replyWinPercent != null && Math.abs(planActual.ignoreWinPercent - planActual.replyWinPercent) >= 1.5) {
            const ignore = formatWinPercentDisplay(planActual.ignoreWinPercent);
            const afterText = formatWinPercentDisplay(planActual.replyWinPercent);
            if (ignore && afterText) {
              bullets.push(`If ${opponentColorName.toLowerCase()} plays another move, you keep about ${ignore}.`);
            }
          }
          const replyContinuation = buildContinuationEntry('Continuation', planActual.replySnippet, 6);
          if (replyContinuation) {
            bullets.push(replyContinuation);
          }
          cards.push({
            key: 'problem',
            title: 'Problem',
            headline,
            bullets
          });
        }

        if (planBest && (!planActual || planBest.moveUci !== planActual.moveUci)) {
          const headline = `Solution — start with ${planBest.moveSan || planBest.moveUci}`;
          const bullets = [];
          if (planBest.moverWinPercent != null) {
            const approx = formatWinPercentDisplay(planBest.moverWinPercent);
            if (approx) {
              bullets.push(`Keeps ${moverColorName.toLowerCase()} around ${approx}.`);
            }
          }
          if (planActual && planActual.moverWinPercent != null && planBest.moverWinPercent != null) {
            const delta = planBest.moverWinPercent - planActual.moverWinPercent;
            if (Math.abs(delta) >= 1.5) {
              const approx = formatWinDeltaDisplay(delta);
              if (approx) {
                bullets.push(`Improves the plan by roughly ${approx}.`);
              }
            }
          }
          if (planActual && planActual.replyUci && planBest.legalReplyUcis && !planBest.legalReplyUcis.has(planActual.replyUci)) {
            bullets.push(`${planActual.replySan || 'The refutation'} is no longer available.`);
          } else if (planBest.replySan && planActual && planActual.replySan && planBest.replySan !== planActual.replySan) {
            bullets.push(`After ${planBest.moveSan || planBest.moveUci}, the best reply becomes ${planBest.replySan}.`);
          }
          const continuation = buildContinuationEntry('Line', planBest.snippet, 6);
          if (continuation) {
            bullets.push(continuation);
          }
          cards.push({
            key: 'solution',
            title: 'Solution',
            headline,
            bullets
          });
        }

        return { headline: summary, details, cards };
      }

      async function computePlanScenarios({
        fen,
        moverColor,
        actualEntry,
        bestEntry,
        beforeEp,
        depth,
        movetime,
        token,
        ply
      }) {
        const beforeMoverEp = Number.isFinite(beforeEp)
          ? (moverColor === 'b' ? 1 - beforeEp : beforeEp)
          : null;
        const beforeWinPercent = Number.isFinite(beforeMoverEp)
          ? Math.max(0, Math.min(100, beforeMoverEp * 100))
          : null;
        const plans = {};
        const baseDepth = Number.isFinite(depth) ? depth : 18;
        const replyDepth = Math.max(6, Math.min(baseDepth - 2, 12));
        const replyMovetime = Math.min(550, Math.max(140, Number.isFinite(movetime) ? Math.floor(movetime / 2) : 220));

        async function evaluateEntry(entry, tag) {
          if (!entry || !entry.uci) return null;
          const verbose = Array.isArray(entry.pvVerbose) ? entry.pvVerbose : [];
          let first = verbose[0];
          if (!first) {
            const fallback = createMoveEntryFromUci(fen, moverColor, entry.uci);
            if (fallback) {
              first = { ...fallback, san: entry.san || uciToSan(fen, entry.uci), uci: entry.uci };
            }
          }
          if (!first) return null;

          const plan = {
            type: tag,
            moveUci: entry.uci,
            moveSan: first.san || entry.san || entry.uci,
            snippet: Array.isArray(entry.pvSan) ? [...entry.pvSan] : [],
            beforeWinPercent,
            moverWinPercent: winPercentForEntry(entry, moverColor, fen),
            delta: null,
            isCapture: Boolean(first.captured),
            capturePiece: first.captured ? describePiece(first.captured) : null,
            isCheck: Boolean(first.san && first.san.includes('+')),
            isMate: Boolean(first.san && first.san.includes('#')),
            reply: verbose[1] || null,
            replySan: verbose[1] && verbose[1].san ? verbose[1].san : null,
            replyUci: verbose[1] ? `${verbose[1].from}${verbose[1].to}${verbose[1].promotion || ''}` : null,
            replyCaptures: verbose[1] && verbose[1].captured ? describePiece(verbose[1].captured) : null,
            replyWinPercent: null,
            replySnippet: null,
            ignoreWinPercent: null,
            ignoreSnippet: null,
            legalReplyUcis: null
          };

          if (plan.moverWinPercent != null && beforeWinPercent != null) {
            plan.delta = plan.moverWinPercent - beforeWinPercent;
          }

          if (plan.reply) {
            plan.replyWinPercent = plan.moverWinPercent != null
              ? plan.moverWinPercent
              : winPercentForEntry(entry, moverColor, fen);
          }

          const afterFen = first.fen || null;
          if (afterFen && (plan.reply || plan.replyUci)) {
            let legal = [];
            try {
              const game = new Chess(afterFen);
              legal = game.moves({ verbose: true });
            } catch (err) {
              legal = [];
            }
            if (legal.length) {
              const legalSet = new Set();
              const altMoves = [];
              legal.forEach((mv) => {
                const uci = `${mv.from}${mv.to}${mv.promotion || ''}`;
                legalSet.add(uci);
                if (!plan.replyUci || uci !== plan.replyUci) {
                  altMoves.push(uci);
                }
              });
              plan.legalReplyUcis = legalSet;

              if (plan.reply && (!plan.replySnippet || plan.replySnippet.length === 0)) {
                const replySanSeq = [];
                for (let i = 1; i < verbose.length && replySanSeq.length < 5; i++) {
                  if (verbose[i] && verbose[i].san) {
                    replySanSeq.push(verbose[i].san);
                  }
                }
                if (replySanSeq.length) {
                  plan.replySnippet = replySanSeq;
                }
              }

              if (altMoves.length) {
                let ignoreResult = null;
                try {
                  ignoreResult = await engineController.run({
                    fen: afterFen,
                    depth: replyDepth,
                    movetime: replyMovetime,
                    searchMoves: altMoves,
                    ply: ply + 1
                  });
                } catch (err) {
                  ignoreResult = null;
                }
                if (token !== state.analysisToken) {
                  throw new Error('cancelled');
                }
                const ignoreEntry = ignoreResult && ignoreResult.entries && ignoreResult.entries[0];
                if (ignoreEntry) {
                  const ignorePercent = winPercentForEntry(ignoreEntry, moverColor);
                  if (ignorePercent != null) {
                    plan.ignoreWinPercent = ignorePercent;
                  }
                  if (Array.isArray(ignoreEntry.pvSan) && ignoreEntry.pvSan.length) {
                    plan.ignoreSnippet = ignoreEntry.pvSan.slice(0, 5);
                  }
                }
              }
            }
          }

          if (!plan.replySnippet && Array.isArray(entry.pvSan) && entry.pvSan.length > 1) {
            plan.replySnippet = entry.pvSan.slice(1, Math.min(entry.pvSan.length, 6));
          }

          return plan;
        }

        let actualPlan = null;
        try {
          actualPlan = await evaluateEntry(actualEntry, 'actual');
        } catch (err) {
          if (err && err.message === 'cancelled') throw err;
          console.warn('Failed to build actual plan explanation', err);
        }
        if (token !== state.analysisToken) {
          throw new Error('cancelled');
        }
        if (actualPlan) {
          plans.actual = actualPlan;
        }

        if (bestEntry) {
          if (actualPlan && actualEntry && bestEntry.uci === actualEntry.uci) {
            plans.best = actualPlan;
          } else {
            try {
              const bestPlan = await evaluateEntry(bestEntry, 'best');
              if (token !== state.analysisToken) {
                throw new Error('cancelled');
              }
              if (bestPlan) {
                plans.best = bestPlan;
              }
            } catch (err) {
              if (err && err.message === 'cancelled') throw err;
              console.warn('Failed to build best plan explanation', err);
            }
          }
        }

        return plans;
      }

      function computeClassificationForMove({
        analysis,
        preFen,
        moveEntry,
        actualEntry,
        beforeEpOverride = null,
        legalMoves = null,
        previousMoveEntry = null
      }) {
        if (!analysis || !moveEntry || !actualEntry || !preFen) return null;
        const moverColor = moveEntry.color ? moveEntry.color : sideToMoveFromFen(preFen);
        const pvEntries = Array.isArray(analysis.pvEntries) ? analysis.pvEntries.slice() : [];
        if (actualEntry && !pvEntries.some((entry) => entry && entry.uci === actualEntry.uci)) {
          pvEntries.push(actualEntry);
        }
        const bestEntry = analysis.bestEntry || pvEntries[0] || null;

        let summary = analysis.summary || null;
        if (summary && summary.byMove instanceof Map) {
          summary = { ...summary, byMove: new Map(summary.byMove) };
        } else {
          summary = {
            EP1: null,
            best: null,
            byMove: new Map(),
            suggestions: []
          };
        }

        const bestCp = evalStringToCentipawns(bestEntry ? bestEntry.eval : null);
        const actualCp = evalStringToCentipawns(actualEntry ? actualEntry.eval : null);
        const bestMoverEp = expectedPointsForMover(bestEntry, preFen, moverColor);
        const actualMoverEp = expectedPointsForMover(actualEntry, preFen, moverColor);

        if (actualEntry && actualEntry.uci && !summary.byMove.has(actualEntry.uci)) {
          summary.byMove.set(actualEntry.uci, {
            ep: Number.isFinite(actualMoverEp) ? actualMoverEp : null,
            tag: null,
            eval: actualEntry.eval || null,
            pvSan: Array.isArray(actualEntry.pvSan) ? actualEntry.pvSan.slice() : null
          });
        }

        let beforeEp = Number.isFinite(beforeEpOverride) ? beforeEpOverride : null;
        if (!Number.isFinite(beforeEp)) {
          const summaryEp = Number.isFinite(summary.EP1) ? summary.EP1 : null;
          if (Number.isFinite(summaryEp)) {
            beforeEp = moverColor === 'w' ? summaryEp : (1 - summaryEp);
          } else if (Number.isFinite(bestMoverEp)) {
            beforeEp = moverColor === 'w' ? bestMoverEp : (1 - bestMoverEp);
          }
        }
        if (!Number.isFinite(beforeEp)) {
          beforeEp = 0.5;
        }

        const bestEp = Number.isFinite(bestMoverEp)
          ? (moverColor === 'w' ? bestMoverEp : 1 - bestMoverEp)
          : cpToExpectedPoints(bestCp);
        const actualEp = Number.isFinite(actualMoverEp)
          ? (moverColor === 'w' ? actualMoverEp : 1 - actualMoverEp)
          : cpToExpectedPoints(actualCp);

        let winPercentBefore = winPercentForEntry(bestEntry, moverColor, preFen);
        if (winPercentBefore == null && Number.isFinite(beforeEp)) {
          const beforeMoverEp = moverColor === 'w' ? beforeEp : 1 - beforeEp;
          winPercentBefore = Math.max(0, Math.min(100, beforeMoverEp * 100));
        }
        if (winPercentBefore == null && Number.isFinite(bestEp)) {
          const ep = moverColor === 'w' ? bestEp : 1 - bestEp;
          winPercentBefore = Math.max(0, Math.min(100, ep * 100));
        }

        let winPercentAfter = winPercentForEntry(actualEntry, moverColor, preFen);
        if (winPercentAfter == null && Number.isFinite(actualMoverEp)) {
          winPercentAfter = Math.max(0, Math.min(100, actualMoverEp * 100));
        }
        if (winPercentAfter == null && Number.isFinite(actualEp)) {
          const ep = moverColor === 'w' ? actualEp : 1 - actualEp;
          winPercentAfter = Math.max(0, Math.min(100, ep * 100));
        }

        const accuracyPercent = computeMoveAccuracy(winPercentBefore, winPercentAfter);
        const cpLoss = computeCpLoss(bestCp, actualCp, moverColor);

        let availableLegalMoves = legalMoves;
        if (!Array.isArray(availableLegalMoves)) {
          try {
            const legalGame = new Chess(preFen);
            availableLegalMoves = legalGame.moves({ verbose: true });
          } catch (err) {
            availableLegalMoves = [];
          }
        }

        const bestEvalParsed = parseEvalString(bestEntry ? bestEntry.eval : null);
        const actualEvalParsed = parseEvalString(actualEntry ? actualEntry.eval : null);
        const actualIsSac = moveEntry ? detectSacrifice(moveEntry) : null;

        const classificationData = classifyMoveContext({
          bestEp,
          actualEp,
          beforeEp,
          moveEntry,
          bestEntry,
          actualEntry,
          pvEntries,
          summary,
          cpLoss,
          bestCp,
          actualCp,
          bestEval: bestEvalParsed,
          actualEval: actualEvalParsed,
          legalMoves: availableLegalMoves,
          previousMoveEntry,
          probeEvaluations: [],
          actualIsSac,
          nonSacBestMoverEp: null,
          bestMoverEp,
          actualMoverEp,
          rootFen: preFen
        }) || { classification: null, overlay: null, expectedLoss: null, suggestionTag: null, promotion: null, baseline: null };

        const evalText = actualEntry && actualEntry.eval
          ? actualEntry.eval
          : (bestEntry && bestEntry.eval ? bestEntry.eval : null);

        const result = {
          pvEntries,
          bestEntry,
          actualEntry,
          bestEp,
          actualEp,
          beforeEp,
          expectedLoss: classificationData.expectedLoss,
          classification: classificationData.classification,
          overlay: classificationData.overlay,
          suggestionTag: classificationData.suggestionTag,
          promotion: classificationData.promotion || null,
          baseline: classificationData.baseline || null,
          bestCp,
          actualCp,
          cpLoss,
          winPercentBefore,
          winPercentAfter,
          accuracy: accuracyPercent,
          summary,
          shortlist: analysis.shortlistMeta || null,
          depth: analysis.depth || DEFAULT_ANALYSIS_DEPTH,
          movetime: analysis.movetime || DEFAULT_ANALYSIS_MOVETIME,
          eval: evalText,
          moverColor,
          actualMoverEp,
          bestMoverEp
        };

        return result;
      }

      function buildClassifiedMoveRecord({ ply, moveEntry, classification }) {
        if (!classification || !Number.isFinite(ply)) {
          return null;
        }
        const actualEntry = classification.actualEntry || null;
        const uci = (actualEntry && actualEntry.uci)
          || (moveEntry && moveEntry.uci)
          || null;
        const preFen = (moveEntry && moveEntry.preFen)
          || (actualEntry && actualEntry.preFen)
          || null;
        let san = (moveEntry && moveEntry.san)
          || (actualEntry && actualEntry.san)
          || null;
        if (!san && preFen && uci) {
          san = uciToSan(preFen, uci);
        }
        const evalCp = Number.isFinite(classification.actualCp) ? classification.actualCp : null;
        const deltaVsBestCp = (Number.isFinite(classification.actualCp) && Number.isFinite(classification.bestCp))
          ? classification.actualCp - classification.bestCp
          : null;
        const epPlayed = Number.isFinite(classification.actualMoverEp) ? classification.actualMoverEp : null;
        const epBest = Number.isFinite(classification.bestMoverEp) ? classification.bestMoverEp : null;
        const tag = getMoveDisplayClassification(classification);
        const baseline = classification.baseline || classification.classification || null;
        const parsedEval = parseEvalString(actualEntry ? actualEntry.eval : null);
        const isMate = Boolean(parsedEval && parsedEval.type === 'mate');
        const mateDepth = isMate ? Math.abs(parsedEval.value) : null;
        const evalLabel = actualEntry && actualEntry.eval ? actualEntry.eval : null;

        return {
          ply,
          san: san || (uci || ''),
          uci: uci || null,
          evalCp,
          deltaVsBestCp,
          epPlayed,
          epBest,
          tag: tag || null,
          baseline: baseline || null,
          isMate,
          mateDepth,
          evalLabel,
          deltaLabel: null
        };
      }

      function classifyPlayedMove({
        preFen,
        playedUci,
        preAnalysis,
        postAnalysis = null,
        moveEntry = null,
        beforeEpOverride = null,
        legalMoves = null,
        previousMoveEntry = null
      }) {
        if (!preFen || !preAnalysis || !playedUci) return null;
        let actualEntry = null;
        if (preAnalysis.entriesByUci && preAnalysis.entriesByUci.has(playedUci)) {
          actualEntry = preAnalysis.entriesByUci.get(playedUci);
        } else if (Array.isArray(preAnalysis.pvEntries)) {
          actualEntry = preAnalysis.pvEntries.find((entry) => entry && entry.uci === playedUci) || null;
        }
        if (!actualEntry) return null;

        const preparedMove = moveEntry || createMoveEntryFromUci(preFen, actualEntry.color || sideToMoveFromFen(preFen), playedUci);
        if (!preparedMove) return null;
        if (!preparedMove.color) {
          preparedMove.color = actualEntry.color || sideToMoveFromFen(preFen);
        }

        const classification = computeClassificationForMove({
          analysis: preAnalysis,
          preFen,
          moveEntry: preparedMove,
          actualEntry,
          beforeEpOverride,
          legalMoves,
          previousMoveEntry
        });

        if (!classification) return null;

        classification.postAnalysis = postAnalysis || null;

        if (preAnalysis.classifications && typeof preAnalysis.classifications.set === 'function') {
          preAnalysis.classifications.set(playedUci, classification);
        }

        return classification;
      }

      async function analyzeMoveEntry(moveEntry, options = {}) {
        if (!moveEntry) {
          return { afterEp: options.beforeEp ?? null };
        }
        const actualUci = moveEntry.uci || `${moveEntry.from}${moveEntry.to}${moveEntry.promotion || ''}`;
        const preFen = moveEntry.preFen || effectiveInitialFen();
        const beforeEp = Number.isFinite(options.beforeEp) ? options.beforeEp : null;
        const token = options.token != null ? options.token : state.analysisToken;
        const previousMoveEntry = options.previousMoveEntry || null;
        const includeMoveOptions = {
          token,
          ply: Number.isFinite(moveEntry.ply) ? moveEntry.ply : state.ply,
          includeMoveUci: actualUci
        };

        let preAnalysis;
        try {
          preAnalysis = await ensureAnalysisForFen(preFen, includeMoveOptions);
        } catch (err) {
          if (err && err.message === 'cancelled') {
            return { cancelled: true };
          }
          throw err;
        }

        let classification = classifyPlayedMove({
          preFen,
          playedUci: actualUci,
          preAnalysis,
          moveEntry,
          beforeEpOverride: beforeEp,
          legalMoves: options.legalMoves || null,
          previousMoveEntry
        });

        if (!classification) {
          return { afterEp: beforeEp, preAnalysis };
        }

        let postAnalysis = null;
        if (options.ensurePostAnalysis) {
          try {
            postAnalysis = await ensureAnalysisForFen(moveEntry.fen, {
              token,
              ply: Number.isFinite(moveEntry.ply) ? moveEntry.ply + 1 : state.ply + 1
            });
          } catch (err) {
            if (err && err.message === 'cancelled') {
              return { cancelled: true };
            }
            postAnalysis = null;
          }
          if (postAnalysis) {
            classification.postAnalysis = postAnalysis;
          }
        }

        let planScenarios = null;
        if (options.computePlans !== false) {
          try {
            planScenarios = await computePlanScenarios({
              fen: preFen,
              moverColor: classification.moverColor || (moveEntry.color || sideToMoveFromFen(preFen)),
              actualEntry: classification.actualEntry,
              bestEntry: classification.bestEntry,
              beforeEp: classification.beforeEp,
              depth: preAnalysis.depth || DEFAULT_ANALYSIS_DEPTH,
              movetime: preAnalysis.movetime || DEFAULT_ANALYSIS_MOVETIME,
              token,
              ply: Number.isFinite(moveEntry.ply) ? moveEntry.ply : state.ply
            });
          } catch (err) {
            if (err && err.message === 'cancelled') {
              return { cancelled: true };
            }
            planScenarios = null;
          }
        }

        const explanation = buildMoveExplanation({
          moveEntry,
          bestEntry: classification.bestEntry,
          actualEntry: classification.actualEntry,
          bestEval: parseEvalString(classification.bestEntry ? classification.bestEntry.eval : null),
          actualEval: parseEvalString(classification.actualEntry ? classification.actualEntry.eval : null),
          beforeEp: classification.beforeEp,
          bestEp: classification.bestEp,
          actualEp: classification.actualEp,
          cpLoss: classification.cpLoss,
          classification: classification.classification,
          overlay: classification.overlay,
          planScenarios
        });

        const moveAnalysis = {
          ...classification,
          planScenarios,
          explanation
        };

        moveEntry.analysis = moveAnalysis;
        moveEntry.eval = classification.eval || null;
        if (moveEntry.id) {
          state.analysisCache.set(moveEntry.id, moveAnalysis);
        }
        if (Number.isFinite(moveEntry.ply)) {
          const record = buildClassifiedMoveRecord({
            ply: moveEntry.ply,
            moveEntry,
            classification
          });
          if (record) {
            recordMoveClassification(record.ply, null, record);
          }
        }
        if (Number.isFinite(moveEntry.ply) && state.ply === moveEntry.ply) {
          scheduleBoardBadgeUpdate();
        }

        return {
          afterEp: Number.isFinite(classification.actualEp) ? classification.actualEp : beforeEp,
          preAnalysis,
          postAnalysis,
          moveAnalysis
        };
      }

      function createMoveEntryFromUci(preFen, color, uci) {
        if (!preFen || !uci) return null;
        try {
          const game = new Chess(preFen);
          const from = uci.slice(0, 2);
          const to = uci.slice(2, 4);
          const promotion = uci.length > 4 ? uci.slice(4) : undefined;
          const moveResult = game.move({ from, to, promotion });
          if (!moveResult) {
            return null;
          }
          return {
            color,
            from,
            to,
            promotion,
            preFen,
            fen: game.fen()
          };
        } catch (err) {
          console.warn('Failed to build move entry from UCI', err);
          return null;
        }
      }

      function createMoveEntryFromVerbose(preFen, color, move) {
        if (!move) return null;
        const uci = `${move.from}${move.to}${move.promotion || ''}`;
        return createMoveEntryFromUci(preFen, color, uci);
      }

      function classifyMoveContext({
        bestEp,
        actualEp,
        beforeEp,
        moveEntry,
        bestEntry,
        actualEntry,
        pvEntries,
        summary,
        bestCp,
        actualCp,
        bestEval,
        actualEval,
        legalMoves,
        previousMoveEntry,
        probeEvaluations = [],
        actualIsSac: actualMoveSacIndicator = null,
        nonSacBestMoverEp: nonSacBestOverride = null,
        bestMoverEp: bestMoverEpOverride = null,
        actualMoverEp: actualMoverEpOverride = null,
        rootFen = null
      }) {
        const moverColor = moveEntry && moveEntry.color === 'b' ? 'b' : 'w';
        const moverIsWhite = moverColor === 'w';
        const sameAsBest = Boolean(bestEntry && actualEntry && bestEntry.uci === actualEntry.uci);
        const averageRating = getAverageGameRating();
        const moverRating = getPlayerRating(moverColor);
        const baselineFen = typeof rootFen === 'string'
          ? rootFen
          : (moveEntry && moveEntry.preFen) || effectiveInitialFen();

        const summaryData = summary && typeof summary === 'object' ? summary : null;
        const summaryByMove = summaryData && summaryData.byMove instanceof Map ? summaryData.byMove : null;
        const summaryBestMoverEp = summaryData && Number.isFinite(summaryData.EP1) ? summaryData.EP1 : null;
        const summaryActualInfo = summaryByMove && actualEntry && actualEntry.uci ? summaryByMove.get(actualEntry.uci) : null;
        const summaryActualMoverEp = summaryActualInfo && Number.isFinite(summaryActualInfo.ep) ? summaryActualInfo.ep : null;
        const summaryActualTag = summaryActualInfo && typeof summaryActualInfo.tag === 'string'
          ? summaryActualInfo.tag.toLowerCase()
          : null;

        let bestMoverEp = Number.isFinite(summaryBestMoverEp)
          ? summaryBestMoverEp
          : (Number.isFinite(bestMoverEpOverride)
            ? bestMoverEpOverride
            : expectedPointsForMover(bestEntry, baselineFen, moverColor));
        if (!Number.isFinite(bestMoverEp) && Number.isFinite(bestCp)) {
          const epWhite = cpToExpectedPoints(bestCp, averageRating);
          bestMoverEp = Number.isFinite(epWhite) ? (moverIsWhite ? epWhite : 1 - epWhite) : null;
        }
        let actualMoverEp = Number.isFinite(summaryActualMoverEp)
          ? summaryActualMoverEp
          : (Number.isFinite(actualMoverEpOverride)
            ? actualMoverEpOverride
            : expectedPointsForMover(actualEntry, baselineFen, moverColor));
        if (!Number.isFinite(actualMoverEp) && Number.isFinite(actualCp)) {
          const epWhite = cpToExpectedPoints(actualCp, averageRating);
          actualMoverEp = Number.isFinite(epWhite) ? (moverIsWhite ? epWhite : 1 - epWhite) : null;
        }
        const beforeWhiteEp = Number.isFinite(beforeEp) ? beforeEp : null;
        const beforeMoverEp = Number.isFinite(beforeWhiteEp)
          ? (moverIsWhite ? beforeWhiteEp : 1 - beforeWhiteEp)
          : null;

        const cpGap = Number.isFinite(bestCp) && Number.isFinite(actualCp)
          ? Math.abs(bestCp - actualCp)
          : null;

        let loss = null;
        if (Number.isFinite(bestMoverEp) && Number.isFinite(actualMoverEp)) {
          loss = Math.max(0, bestMoverEp - actualMoverEp);
        }
        let suggestionTag = null;
        if (Number.isFinite(loss)) {
          if (loss <= (PV_BEST_MARGIN + PV_EPSILON)) {
            suggestionTag = 'best';
          } else if (loss <= (PV_KEEP_MARGIN + PV_EPSILON)) {
            suggestionTag = 'excellent';
          }
        } else if (summaryActualTag === 'best' || summaryActualTag === 'excellent') {
          suggestionTag = summaryActualTag;
        }

        const bestLossMargin = PV_BEST_MARGIN;
        const lossIsKnown = Number.isFinite(loss);
        const qualifiesAsBest = sameAsBest || (lossIsKnown && loss <= (bestLossMargin + PV_EPSILON));

        const bestMateVal = bestEval && bestEval.type === 'mate' ? bestEval.value : null;
        const actualMateVal = actualEval && actualEval.type === 'mate' ? actualEval.value : null;
        const bestMateDistance = bestMateVal != null ? Math.abs(bestMateVal) : null;
        const actualMateDistance = actualMateVal != null ? Math.abs(actualMateVal) : null;

        const bestMateForMover = bestMateVal != null
          && ((moverIsWhite && bestMateVal > 0) || (!moverIsWhite && bestMateVal < 0));
        const bestMateForOpponent = bestMateVal != null
          && ((moverIsWhite && bestMateVal < 0) || (!moverIsWhite && bestMateVal > 0));
        const actualMateForMover = actualMateVal != null
          && ((moverIsWhite && actualMateVal > 0) || (!moverIsWhite && actualMateVal < 0));
        const actualMateForOpponent = actualMateVal != null
          && ((moverIsWhite && actualMateVal < 0) || (!moverIsWhite && actualMateVal > 0));

        let classification;
        if (actualMateForOpponent) {
          if (bestMateForOpponent && actualMateDistance != null && bestMateDistance != null) {
            classification = actualMateDistance <= bestMateDistance ? 'best' : 'blunder';
          } else {
            classification = 'blunder';
          }
        } else {
          if (!lossIsKnown) {
            classification = qualifiesAsBest ? 'best' : 'good';
          } else if (qualifiesAsBest) {
            classification = 'best';
          } else if (loss <= (PV_KEEP_MARGIN + PV_EPSILON)) {
            classification = 'excellent';
          } else if (loss <= (0.05 + PV_EPSILON)) {
            classification = 'good';
          } else if (loss <= (0.10 + PV_EPSILON)) {
            classification = 'inaccuracy';
          } else if (loss <= (0.20 + PV_EPSILON)) {
            classification = 'mistake';
          } else {
            classification = 'blunder';
          }

          if (bestMateForMover && !actualMateForMover) {
            classification = 'blunder';
          } else if (actualMateForMover && !bestMateForMover) {
            if (classification !== 'best' && classification !== 'excellent') {
              classification = 'excellent';
            }
          } else if (actualMateForMover && bestMateForMover && actualMateDistance != null && bestMateDistance != null && actualMateDistance > bestMateDistance) {
            if (classification === 'best') {
              classification = 'excellent';
            }
          }
        }

        const baseline = classification;

        const entryData = [];
        const actualMoveIsSac = actualMoveSacIndicator != null
          ? Boolean(actualMoveSacIndicator)
          : detectSacrifice(moveEntry);
        if (Array.isArray(pvEntries)) {
          pvEntries.forEach((entry) => {
            let epMover = null;
            if (summaryByMove && entry && entry.uci) {
              const info = summaryByMove.get(entry.uci);
              if (info && Number.isFinite(info.ep)) {
                epMover = info.ep;
              }
            }
            if (!Number.isFinite(epMover) && Number.isFinite(entry.expectedPoints)) {
              epMover = entry.expectedPoints;
            }
            if (!Number.isFinite(epMover)) {
              const derived = expectedPointsForMover(entry, baselineFen, moverColor);
              epMover = Number.isFinite(derived) ? derived : null;
            }
            let entryIsSac = false;
            if (entry && entry.uci && moveEntry && moveEntry.preFen) {
              const hypo = createMoveEntryFromUci(moveEntry.preFen, moverColor, entry.uci);
              if (hypo) {
                entryIsSac = detectSacrifice(hypo);
              }
            }
            entryData.push({ entry, epMover, isSac: entryIsSac });
          });
        }
        const actualId = actualEntry && actualEntry.uci ? actualEntry.uci : null;
        if (actualId && !entryData.some((item) => item.entry && item.entry.uci === actualId)) {
          entryData.push({
            entry: actualEntry,
            epMover: Number.isFinite(actualMoverEp) ? actualMoverEp : null,
            isSac: actualMoveIsSac
          });
        }

        const existingUcis = new Set();
        entryData.forEach((item) => {
          if (item.entry && item.entry.uci) {
            existingUcis.add(item.entry.uci);
          }
        });
        if (Array.isArray(probeEvaluations)) {
          probeEvaluations.forEach((probe) => {
            if (!probe || !probe.uci || existingUcis.has(probe.uci)) return;
            const epMover = Number.isFinite(probe.epMover) ? probe.epMover : null;
            entryData.push({
              entry: { uci: probe.uci },
              epMover,
              isSac: Boolean(probe.isSac)
            });
            existingUcis.add(probe.uci);
          });
        }

        const dedupedEntryMap = new Map();
        entryData.forEach((item) => {
          if (!item || !item.entry || !item.entry.uci) return;
          const uci = item.entry.uci;
          const normalizedEp = Number.isFinite(item.epMover) ? item.epMover : null;
          if (!dedupedEntryMap.has(uci)) {
            dedupedEntryMap.set(uci, {
              entry: item.entry,
              epMover: normalizedEp,
              isSac: Boolean(item.isSac)
            });
            return;
          }
          const existing = dedupedEntryMap.get(uci);
          const existingEp = Number.isFinite(existing.epMover) ? existing.epMover : null;
          const shouldReplaceEntry = Number.isFinite(normalizedEp)
            && (!Number.isFinite(existingEp) || normalizedEp > existingEp);
          if (shouldReplaceEntry) {
            existing.entry = item.entry;
            existing.epMover = normalizedEp;
          }
          if (!shouldReplaceEntry && !existing.entry && item.entry) {
            existing.entry = item.entry;
          }
          existing.isSac = existing.isSac || Boolean(item.isSac);
        });
        const dedupedEntryData = Array.from(dedupedEntryMap.values());

        const moverWinBefore = beforeMoverEp;
        const moverWinAfter = Number.isFinite(actualMoverEp) ? actualMoverEp : null;
        const entryEpByUci = new Map();
        const mateValueByMove = new Map();
        dedupedEntryData.forEach((item) => {
          if (!item || !item.entry || !item.entry.uci) return;
          entryEpByUci.set(item.entry.uci, Number.isFinite(item.epMover) ? item.epMover : null);
          if (typeof item.entry.eval === 'string') {
            const parsed = parseEvalString(item.entry.eval);
            if (parsed && parsed.type === 'mate') {
              mateValueByMove.set(item.entry.uci, parsed.value);
            }
          }
        });
        const rankedDistinctEntries = dedupedEntryData
          .filter((item) => item.entry && item.entry.uci && Number.isFinite(item.epMover))
          .sort((a, b) => b.epMover - a.epMover);

        const bestDistinctEntry = rankedDistinctEntries.length > 0
          ? rankedDistinctEntries[0]
          : null;
        let alternativeBest = null;
        for (let i = 0; i < rankedDistinctEntries.length; i += 1) {
          const candidate = rankedDistinctEntries[i];
          if (!candidate || !candidate.entry) continue;
          if (actualId && candidate.entry.uci === actualId) continue;
          alternativeBest = { ep: candidate.epMover, entry: candidate.entry };
          break;
        }
        const secondDistinctEntry = rankedDistinctEntries.length > 1
          ? rankedDistinctEntries[1]
          : null;

        let altMaxOverTopK = null;
        dedupedEntryData.forEach((item) => {
          if (!item.entry) return;
          if (bestEntry && item.entry.uci === bestEntry.uci) return;
          if (!Number.isFinite(item.epMover)) return;
          if (altMaxOverTopK == null || item.epMover > altMaxOverTopK) {
            altMaxOverTopK = item.epMover;
          }
        });

        const EP_secondBest = alternativeBest ? alternativeBest.ep : null;
        const EP_altMaxOverTopK = altMaxOverTopK;

        const materialAfterMoveInfo = computeMaterialDeltaAfterMove(moveEntry);
        const materialAfterMove = materialAfterMoveInfo ? materialAfterMoveInfo.afterUs : null;
        const materialDeltaAfterMoveUs = materialAfterMoveInfo ? materialAfterMoveInfo.deltaUs : null;
        const materialReplyInfo = computeMaterialDeltaAfterReply(moveEntry, actualEntry);
        const materialBefore = materialReplyInfo ? materialReplyInfo.beforeUs : null;
        const materialAfterReply = materialReplyInfo ? materialReplyInfo.afterUs : null;
        const materialDeltaAfterReply = materialReplyInfo ? materialReplyInfo.deltaUs : null;
        const materialDeltaAfterReplyNet = materialReplyInfo ? materialReplyInfo.delta : null;
        const materialAfterReReply = materialReplyInfo ? materialReplyInfo.afterUsReReply : null;
        const materialDeltaAfterReReply = materialReplyInfo ? materialReplyInfo.deltaUsAfterReReply : null;
        const materialDeltaAfterReReplyNet = materialReplyInfo ? materialReplyInfo.deltaAfterReReply : null;
        const ourBestReReplyUci = materialReplyInfo && materialReplyInfo.reReplyUci
          ? materialReplyInfo.reReplyUci
          : null;
        const captureInfo = materialAfterMoveInfo && materialAfterMoveInfo.captured
          ? materialAfterMoveInfo.captured
          : null;
        const capturedOnMoveValue = captureInfo && Number.isFinite(captureInfo.value)
          ? captureInfo.value
          : 0;
        const lostAfterReplyInfo = materialReplyInfo && materialReplyInfo.lostAfterReply
          ? materialReplyInfo.lostAfterReply
          : null;
        const lostAfterReplyValue = lostAfterReplyInfo && Number.isFinite(lostAfterReplyInfo.value)
          ? lostAfterReplyInfo.value
          : 0;
        const lostAfterReplySquare = lostAfterReplyInfo && typeof lostAfterReplyInfo.square === 'string'
          ? lostAfterReplyInfo.square
          : null;
        const lostAfterReplyPieceId = lostAfterReplyInfo && lostAfterReplyInfo.pieceId
          ? lostAfterReplyInfo.pieceId
          : null;
        const lostAfterReplyIsMovedPiece = lostAfterReplyInfo ? Boolean(lostAfterReplyInfo.isMovedPiece) : false;
        const movedPieceId = (materialAfterMoveInfo && materialAfterMoveInfo.movedPieceId)
          || (materialReplyInfo && materialReplyInfo.movedPieceId)
          || null;
        const movedToSquare = (materialAfterMoveInfo && materialAfterMoveInfo.movedTo)
          || (materialReplyInfo && materialReplyInfo.movedTo)
          || (moveEntry && moveEntry.to ? moveEntry.to : null);
        const netLostAfterReplyValue = lostAfterReplyIsMovedPiece
          ? (lostAfterReplyValue - capturedOnMoveValue)
          : null;
        const isDirectSacrifice = Boolean(
          lostAfterReplyIsMovedPiece
          && Number.isFinite(netLostAfterReplyValue)
          && netLostAfterReplyValue >= SAC_MIN_LOSS_POINTS
        );
        const isDirectSacrifice2Ply = Boolean(
          lostAfterReplyIsMovedPiece
          && Number.isFinite(materialDeltaAfterReReplyNet)
          && materialDeltaAfterReReplyNet <= -SAC_TWO_PLY_MIN_NET
        );
        const directSacrificeInfo = {
          capturedOnMoveValue: Number.isFinite(capturedOnMoveValue) ? capturedOnMoveValue : 0,
          lostAfterReplyValue: Number.isFinite(lostAfterReplyValue) ? lostAfterReplyValue : 0,
          lostAfterReplySquare,
          lostAfterReplyPieceId,
          netLost: Number.isFinite(netLostAfterReplyValue) ? netLostAfterReplyValue : null,
          lostIsMovedPiece: lostAfterReplyIsMovedPiece,
          movedPieceId,
          movedTo: movedToSquare,
          isDirectSacrifice,
          isDirectSacrifice2Ply,
          materialAfterReReply: Number.isFinite(materialAfterReReply) ? materialAfterReReply : null,
          materialDeltaAfterReReply: Number.isFinite(materialDeltaAfterReReply) ? materialDeltaAfterReReply : null,
          deltaAfterReReplyNet: Number.isFinite(materialDeltaAfterReReplyNet) ? materialDeltaAfterReReplyNet : null,
          reReplyUci: ourBestReReplyUci
        };

        const missOpportunityThreshold = ratingLerp(moverRating, 1000, 2000, 0.72, 0.82);
        const missConversionThreshold = ratingLerp(moverRating, 1000, 2000, 0.78, 0.88);
        const missDropThreshold = ratingLerp(moverRating, 1000, 2000, 0.58, 0.68);
        const missGapThreshold = ratingLerp(moverRating, 1000, 2000, 0.14, 0.2);

        const missCandidate = moverWinBefore != null
          && moverWinAfter != null
          && Number.isFinite(bestMoverEp)
          && moverWinBefore >= missOpportunityThreshold
          && bestMoverEp >= missConversionThreshold
          && moverWinAfter <= missDropThreshold
          && (bestMoverEp - moverWinAfter) >= missGapThreshold;

        const epNearBest = Number.isFinite(bestMoverEp)
          && Number.isFinite(actualMoverEp)
          && Math.abs(bestMoverEp - actualMoverEp) <= (0.02 + PV_EPSILON);
        const cpNearBest = !epNearBest
          && Number.isFinite(bestCp)
          && Number.isFinite(actualCp)
          && Math.abs(bestCp - actualCp) <= 20;
        const nearBest = epNearBest || cpNearBest;

        const SAC_MIN_PIECE_LOSS = SAC_PIECE_LOSS_THRESHOLD - PV_EPSILON;
        const sacrificeCandidates = [];
        const sacImmediate = Number.isFinite(materialDeltaAfterMoveUs)
          && materialDeltaAfterMoveUs <= -SAC_MIN_PIECE_LOSS;
        const sacAfterReply = Number.isFinite(materialDeltaAfterReply)
          && materialDeltaAfterReply <= -SAC_MIN_PIECE_LOSS;
        if (sacImmediate && Number.isFinite(materialDeltaAfterMoveUs)) {
          sacrificeCandidates.push(-materialDeltaAfterMoveUs);
        }
        if (sacAfterReply && Number.isFinite(materialDeltaAfterReply)) {
          sacrificeCandidates.push(-materialDeltaAfterReply);
        }
        const sacrificeValue = sacrificeCandidates.length > 0
          ? Math.max(...sacrificeCandidates)
          : null;
        const isSacrificeWithin1Ply = sacImmediate || sacAfterReply;
        const sacPlyOffset = sacImmediate ? 0 : (sacAfterReply ? 1 : null);
        const isSacrifice = isSacrificeWithin1Ply;

        const mateSlack = 2;
        let mateDistanceTest = false;
        if (bestMateForMover && actualMateForMover && Number.isFinite(bestMateDistance)) {
          let allLoseOrSlow = true;
          dedupedEntryData.forEach((item) => {
            if (!item.entry || (actualId && item.entry.uci === actualId)) return;
            const mateVal = mateValueByMove.has(item.entry.uci) ? mateValueByMove.get(item.entry.uci) : null;
            if (mateVal == null) {
              allLoseOrSlow = false;
              return;
            }
            const mateForMover = (moverIsWhite && mateVal > 0) || (!moverIsWhite && mateVal < 0);
            if (!mateForMover) {
              return;
            }
            const altDistance = Math.abs(mateVal);
            const reference = Number.isFinite(actualMateDistance) ? actualMateDistance : bestMateDistance;
            if (!Number.isFinite(reference) || altDistance < (reference + mateSlack)) {
              allLoseOrSlow = false;
            }
          });
          mateDistanceTest = allLoseOrSlow;
        }

        const toMoverCp = (cp) => {
          if (!Number.isFinite(cp)) return null;
          return moverIsWhite ? cp : -cp;
        };
        const evalByUci = new Map();
        const cpByUci = new Map();
        const candidateCps = [];
        let bestLineEvalCp = toMoverCp(bestCp);
        let secondBestEvalCp = null;
        if (Array.isArray(pvEntries)) {
          pvEntries.forEach((entry) => {
            if (!entry) return;
            const cpValue = evalStringToCentipawns(entry.eval);
            const normalizedCp = toMoverCp(cpValue);
            if (entry.uci) {
              const normalizedEval = normalizeEvalForMover(entry.eval, moverIsWhite);
              if (normalizedEval) {
                evalByUci.set(entry.uci, normalizedEval);
              }
            }
            if (!Number.isFinite(normalizedCp)) return;
            if (entry.uci) {
              if (!cpByUci.has(entry.uci) || normalizedCp > cpByUci.get(entry.uci)) {
                cpByUci.set(entry.uci, normalizedCp);
              }
            } else {
              candidateCps.push({ cp: normalizedCp, uci: entry.uci || null });
            }
          });
          cpByUci.forEach((cp, uci) => {
            candidateCps.push({ cp, uci });
          });
          candidateCps.sort((a, b) => b.cp - a.cp);
          if (candidateCps.length > 0 && Number.isFinite(candidateCps[0].cp)) {
            bestLineEvalCp = candidateCps[0].cp;
          }
          if (candidateCps.length > 1 && Number.isFinite(candidateCps[1].cp)) {
            secondBestEvalCp = candidateCps[1].cp;
          }
        }

        const preEvalCp = bestLineEvalCp;
        const postEvalCp = toMoverCp(actualCp);
        const onlyMoveGapCpFinite = Number.isFinite(bestLineEvalCp) && Number.isFinite(secondBestEvalCp)
          ? (bestLineEvalCp - secondBestEvalCp)
          : null;
        const onlyMoveGapCp = Number.isFinite(bestLineEvalCp)
          ? bestLineEvalCp - (Number.isFinite(secondBestEvalCp) ? secondBestEvalCp : -Infinity)
          : null;
        let preBestEval = null;
        if (candidateCps.length > 0) {
          const bestCandidate = candidateCps[0];
          if (bestCandidate && bestCandidate.uci && evalByUci.has(bestCandidate.uci)) {
            preBestEval = evalByUci.get(bestCandidate.uci);
          }
        }
        if (!preBestEval && Number.isFinite(bestLineEvalCp)) {
          preBestEval = { cp: bestLineEvalCp };
        }
        let preSecondBestEval = null;
        if (candidateCps.length > 1) {
          const secondCandidate = candidateCps[1];
          if (secondCandidate && secondCandidate.uci && evalByUci.has(secondCandidate.uci)) {
            preSecondBestEval = evalByUci.get(secondCandidate.uci);
          }
        }
        if (!preSecondBestEval && Number.isFinite(secondBestEvalCp)) {
          preSecondBestEval = { cp: secondBestEvalCp };
        }
        const postEval = normalizeEvalForMover(actualEntry ? actualEntry.eval : null, moverIsWhite)
          || (Number.isFinite(postEvalCp) ? { cp: postEvalCp } : null);
        const postEvalCpAfterReReply = Number.isFinite(postEvalCp) ? postEvalCp : null;
        const ourReReplyIsMate = Number.isFinite(postEvalCpAfterReReply)
          && postEvalCpAfterReReply === 10000;

        const epGapToSecond = Number.isFinite(bestMoverEp) && Number.isFinite(EP_secondBest)
          ? bestMoverEp - EP_secondBest
          : null;
        const meetsOnlyMoveGap = (!Number.isFinite(secondBestEvalCp) && !Number.isFinite(EP_secondBest))
          || (Number.isFinite(onlyMoveGapCpFinite) && onlyMoveGapCpFinite >= ONLY_MOVE_GAP_CP)
          || (Number.isFinite(epGapToSecond) && epGapToSecond >= (ONLY_MOVE_GAP_EP - PV_EPSILON));
        const isOnlyWinningMove = mateDistanceTest || meetsOnlyMoveGap;

        const mateSacDepthLimit = BRILLIANT_MATE_SAC_MAX_DEPTH;
        const isDirectSacrifice1Ply = directSacrificeInfo && directSacrificeInfo.isDirectSacrifice === true;
        const opponentCapturedMovedPiece = lostAfterReplyIsMovedPiece
          && Number.isFinite(lostAfterReplyValue)
          && lostAfterReplyValue > 0;
        const isMateNow = Boolean(actualMateForMover);
        const mateDepthAfter = Number.isFinite(actualMateDistance) ? actualMateDistance : null;
        const isFinalMateMove = isMateNow && mateDepthAfter === 1;
        const baselineNearBest = (baseline === 'best') || nearBest;
        const mateSacBrilliant = baselineNearBest
          && isMateNow
          && mateDepthAfter != null
          && mateDepthAfter <= mateSacDepthLimit
          && !isFinalMateMove
          && isDirectSacrifice1Ply
          && opponentCapturedMovedPiece;

        const epNearBestPlayed = Number.isFinite(bestMoverEp)
          && Number.isFinite(actualMoverEp)
          && Math.abs(bestMoverEp - actualMoverEp) <= (0.02 + PV_EPSILON);
        const cpKeepsEval = Number.isFinite(preEvalCp)
          && Number.isFinite(postEvalCpAfterReReply)
          && postEvalCpAfterReReply >= (preEvalCp - 50);
        const hasLargeOnlyMoveGap = onlyMoveGapCp != null && onlyMoveGapCp >= 150;
        const nonMateBrilliant = baselineNearBest
          && !isMateNow
          && isDirectSacrifice2Ply
          && epNearBestPlayed
          && cpKeepsEval
          && hasLargeOnlyMoveGap;

        const replyIsMate = Boolean(actualMateForMover && Number.isFinite(actualMateDistance) && actualMateDistance === 1);
        const greatCandidate = nearBest
          && Number.isFinite(epGapToSecond)
          && epGapToSecond >= (0.20 - PV_EPSILON);

        let overlay = null;
        let brilliantReason = null;
        if (mateSacBrilliant) {
          overlay = 'brilliant';
          brilliantReason = 'mateSac';
        } else if (nonMateBrilliant) {
          overlay = 'brilliant';
          brilliantReason = 'sacrifice2Ply';
        } else if (greatCandidate) {
          overlay = 'great';
        } else if (missCandidate && baseline !== 'blunder') {
          overlay = 'miss';
        }

        const playedUci = actualEntry && actualEntry.uci ? actualEntry.uci : null;
        const bestUci = (bestEntry && bestEntry.uci)
          ? bestEntry.uci
          : (bestDistinctEntry && bestDistinctEntry.entry ? bestDistinctEntry.entry.uci : null);
        const secondBestUci = secondDistinctEntry && secondDistinctEntry.entry
          ? secondDistinctEntry.entry.uci
          : null;

        const overlayCandidate = overlay;

        let promotion = null;
        try {
          promotion = applySpecialPromotions({
            baseLabel: baseline,
            preEvalCp,
            postEvalCp,
            bestLineEvalCp,
            secondBestEvalCp,
            materialDeltaAfterMove: materialDeltaAfterMoveUs,
            materialDeltaAfterReply,
            preEval: { best: preBestEval, secondBest: preSecondBestEval },
            postEval,
            moveSan: actualEntry && (actualEntry.san || actualEntry.uci)
              ? (actualEntry.san || actualEntry.uci)
              : null,
            sacrificeInfo: directSacrificeInfo,
            epBeforeMover: Number.isFinite(beforeMoverEp) ? beforeMoverEp : null,
            postEvalCpAfterReReply,
            bestMoverEp: Number.isFinite(bestMoverEp) ? bestMoverEp : null,
            secondBestMoverEp: Number.isFinite(EP_secondBest) ? EP_secondBest : null,
            playedMoverEp: Number.isFinite(actualMoverEp) ? actualMoverEp : null,
            altMaxMoverEp: Number.isFinite(EP_altMaxOverTopK) ? EP_altMaxOverTopK : null
          });
        } catch (err) {
          console.warn('Failed to apply special promotions', err);
        }

        let finalClassification = baseline;
        if (promotion && promotion.label) {
          finalClassification = promotion.label;
          if (promotion.log && typeof console !== 'undefined' && console && typeof console.info === 'function') {
            try {
              console.info('Special promotion', promotion.log);
            } catch (err) {
              // ignore logging errors
            }
          }
        }

        const promotionPath = promotion && promotion.promotionPath ? promotion.promotionPath : null;
        const sacPath = (() => {
          if (ourReReplyIsMate) return 'terminal';
          if (directSacrificeInfo && directSacrificeInfo.isDirectSacrifice2Ply) return '2ply';
          if (directSacrificeInfo && directSacrificeInfo.isDirectSacrifice) return '1ply';
          return 'none';
        })();
        const mateSacResult = promotionPath === 'mateSac';
        const nonMateBrilliantResult = promotionPath === 'nonMateSac';

        if (typeof console !== 'undefined' && console && typeof console.table === 'function') {
          try {
            const formatEvalForLog = (val) => {
              if (!val) return null;
              if (typeof val.mate === 'number' && Number.isFinite(val.mate)) {
                const prefix = val.mate >= 0 ? '+' : '-';
                return `${prefix}M${Math.abs(val.mate)}`;
              }
              if (typeof val.cp === 'number' && Number.isFinite(val.cp)) {
                const pawns = val.cp / 100;
                const formatted = pawns === 0 ? '0.00' : (pawns > 0 ? `+${pawns.toFixed(2)}` : pawns.toFixed(2));
                return `${formatted}`;
              }
              return null;
            };
            const sfBeforeEval = preBestEval || (Number.isFinite(preEvalCp) ? { cp: preEvalCp } : null);
            const sfBestEval = preBestEval || null;
            const sfPlayedEval = postEval || null;
            const sfSecondEval = preSecondBestEval || (Number.isFinite(secondBestEvalCp) ? { cp: secondBestEvalCp } : null);
            const formatPvPreview = (entry) => {
              if (!entry) return null;
              const pv = Array.isArray(entry.pvSan) ? entry.pvSan : null;
              if (!pv || pv.length === 0) return null;
              return pv.slice(0, 4).join(' ');
            };
            const pvBestEntryForLog = bestEntry || (bestDistinctEntry ? bestDistinctEntry.entry : null);
            const pvSecondEntryForLog = secondDistinctEntry ? secondDistinctEntry.entry : null;
            console.table({
              ply: moveEntry && Number.isFinite(moveEntry.ply) ? moveEntry.ply : null,
              move: actualEntry && (actualEntry.san || actualEntry.uci) ? (actualEntry.san || actualEntry.uci) : null,
              playedUci,
              bestUci,
              secondBestUci,
              pvBestFirst4: formatPvPreview(pvBestEntryForLog),
              pvSecondBestFirst4: formatPvPreview(pvSecondEntryForLog),
              EP_best: Number.isFinite(bestMoverEp) ? bestMoverEp.toFixed(3) : null,
              EP_played: Number.isFinite(actualMoverEp) ? actualMoverEp.toFixed(3) : null,
              EP_secondBest: Number.isFinite(EP_secondBest) ? EP_secondBest.toFixed(3) : null,
              EP_altMaxOverTopK: Number.isFinite(EP_altMaxOverTopK) ? EP_altMaxOverTopK.toFixed(3) : null,
              bandBefore: getOutcomeBand(beforeMoverEp),
              bandPlayed: getOutcomeBand(actualMoverEp),
              bandAltMax: getOutcomeBand(EP_altMaxOverTopK),
              decisiveBefore: isDecisiveEp(beforeMoverEp),
              decisiveAfter: isDecisiveEp(actualMoverEp),
              epGapAlt: (Number.isFinite(actualMoverEp) && Number.isFinite(EP_altMaxOverTopK))
                ? (actualMoverEp - EP_altMaxOverTopK).toFixed(3)
                : null,
              gap: (Number.isFinite(bestMoverEp) && Number.isFinite(actualMoverEp))
                ? (bestMoverEp - actualMoverEp).toFixed(3)
                : null,
              epBeforeMover: Number.isFinite(beforeMoverEp) ? beforeMoverEp.toFixed(3) : null,
              sfBefore: formatEvalForLog(sfBeforeEval),
              sfBest: formatEvalForLog(sfBestEval),
              sfPlayed: formatEvalForLog(sfPlayedEval),
              sfSecondBest: formatEvalForLog(sfSecondEval),
              isMateBefore: Boolean(bestMateForMover),
              mateDepthBefore: bestMateDistance != null ? bestMateDistance : null,
              isMateAfter: Boolean(actualMateForMover),
              mateDepthAfter: actualMateDistance != null ? actualMateDistance : null,
              isFinalMateMove,
              materialBefore,
              materialAfterMove,
              materialAfterReply,
              materialAfterReReply,
              deltaAfterMove: materialDeltaAfterMoveUs,
              deltaAfterReply: materialDeltaAfterReply,
              materialDeltaAfterReply,
              materialDeltaAfterReplyNet,
              deltaAfterReReply: materialDeltaAfterReReplyNet,
              materialDeltaAfterReReply,
              sacrificeValue,
              sacPlyOffset,
              isSacrificeWithin1Ply,
              isSacrifice,
              isOnlyWinningMove,
              nearBest,
              mateSacBrilliant,
              nonMateBrilliant,
              brilliantReason,
              greatCandidate,
              suggestionTag,
              baseline,
              overlayCandidate,
              overlayFinal: overlay,
              vCaptured: Number.isFinite(capturedOnMoveValue) ? capturedOnMoveValue : null,
              'lostAfterReply.value': Number.isFinite(lostAfterReplyValue) ? lostAfterReplyValue : null,
              netLost: Number.isFinite(netLostAfterReplyValue) ? netLostAfterReplyValue : null,
              'lostAfterReply.square': lostAfterReplySquare,
              'lostAfterReply.pieceId': lostAfterReplyPieceId,
              lostIsMovedPiece: lostAfterReplyIsMovedPiece,
              opponentCapturedMovedPiece,
              isDirectSacrifice,
              isDirectSacrifice2Ply,
              ourBestReReplyUci,
              postEvalCpAfterReReply,
              onlyMoveGapCp: Number.isFinite(onlyMoveGapCp) ? onlyMoveGapCp : (onlyMoveGapCp === Infinity ? 'Infinity' : null),
              hasLargeOnlyMoveGap,
              promotionPath,
              terminalFlags: { replyIsMate, ourReReplyIsMate },
              sacPath,
              mateSacResult,
              nonMateBrilliantResult,
              swingUp: promotion && promotion.log ? Boolean(promotion.log.swingUp) : false,
              onlyMoveGreat: promotion && promotion.log ? Boolean(promotion.log.onlyMoveGreat) : false,
              greatReason: promotion && promotion.log ? promotion.log.greatReason : null
            });
          } catch (err) {
            // ignore logging errors
          }
        }

        return { classification: finalClassification, overlay, expectedLoss: loss, suggestionTag, promotion, baseline };
      }

      const engineController = {
        running: null,
        run(config) {
          return new Promise((resolve, reject) => {
            const request = {
              config: {
                fen: config.fen,
                depth: config.depth ?? 20,
                movetime: config.movetime ?? 2000,
                searchMoves: config.searchMoves ? [...config.searchMoves] : [],
                ply: config.ply ?? 0
              },
              resolve,
              reject,
              pv: new Map(),
              depth: 0
            };
            state.engineQueue.push(request);
            engineController.pump();
          });
        },
        pump() {
          if (!state.engineReady) return;
          if (engineController.running || state.engineQueue.length === 0) return;
          engineController.running = state.engineQueue.shift();
          state.currentRequest = engineController.running;
          state.engine.postMessage('stop');
          setTimeout(() => {
            if (!engineController.running) return;
            const { fen, depth, movetime, searchMoves } = engineController.running.config;
            state.engine.postMessage(`position fen ${fen}`);
            const goParts = ['go'];
            if (depth) {
              goParts.push('depth', String(depth));
            }
            if (movetime) {
              goParts.push('movetime', String(movetime));
            }
            if (searchMoves && searchMoves.length) {
              goParts.push('searchmoves', searchMoves.join(' '));
            }
            state.engine.postMessage(goParts.join(' '));
          }, 50);
        },
        handleInfo(line) {
          const req = engineController.running;
          if (!req) return;
          const depthMatch = line.match(/\bdepth (\d+)/);
          if (depthMatch) {
            const depthVal = parseInt(depthMatch[1], 10);
            if (Number.isFinite(depthVal)) {
              req.depth = depthVal;
            }
          }
          const multi = line.match(/\bmultipv (\d+)/);
          const pv = line.match(/\bpv ((?:[a-h][1-8])[a-h][1-8][qrbn]?\b.*)/);
          if (!multi || !pv) return;
          const rank = parseInt(multi[1], 10);
          if (!Number.isFinite(rank) || rank < 1) return;
          const moves = pv[1].trim().split(/\s+/).filter((m) => /^[a-h][1-8][a-h][1-8][qrbn]?$/.test(m));
          if (!moves.length) return;
          let evalStr = '';
          const sideToMove = sideToMoveFromFen(req.config.fen);
          const scoreMate = line.match(/\bscore mate (-?\d+)/);
          const scoreCp = line.match(/\bscore cp (-?\d+)/);
          if (scoreMate) {
            const mate = parseInt(scoreMate[1], 10);
            if (Number.isFinite(mate)) {
              const adjusted = mate * (sideToMove === 'b' ? -1 : 1);
              evalStr = `#${adjusted}`;
            }
          } else if (scoreCp) {
            const cp = parseInt(scoreCp[1], 10);
            if (Number.isFinite(cp)) {
              const adjusted = cp * (sideToMove === 'b' ? -1 : 1);
              evalStr = `${adjusted >= 0 ? '+' : ''}${(adjusted / 100).toFixed(2)}`;
            }
          }
          const wdlMatch = line.match(/\bwdl\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)/);
          const existing = req.pv.get(rank) || {};
          const entry = {
            ...existing,
            rank,
            uci: moves[0],
            eval: evalStr,
            pvMoves: moves.slice(0, 20)
          };
          if (wdlMatch) {
            entry.wdl = {
              w: parseInt(wdlMatch[1], 10),
              d: parseInt(wdlMatch[2], 10),
              l: parseInt(wdlMatch[3], 10)
            };
          }
          entry.san = uciToSan(req.config.fen, entry.uci);
          req.pv.set(rank, entry);
        },
        handleBestMove(line) {
          const req = engineController.running;
          if (!req) return;
          const entries = Array.from(req.pv.values())
            .sort((a, b) => a.rank - b.rank)
            .map((item) => {
              const pvMoves = Array.isArray(item.pvMoves) ? item.pvMoves : [];
              const verbose = convertPvToVerbose(req.config.fen, pvMoves);
              const sanSeq = verbose.map((mv) => mv.san);
              let sanMove = item.san;
              if (!sanMove && verbose[0] && verbose[0].san) {
                sanMove = verbose[0].san;
              } else if (!sanMove) {
                sanMove = uciToSan(req.config.fen, item.uci);
              }
              return {
                rank: item.rank,
                uci: item.uci,
                eval: item.eval,
                san: sanMove,
                wdl: item.wdl ? { ...item.wdl } : null,
                pvMoves,
                pvSan: sanSeq,
                pvVerbose: verbose
              };
            });
          const moverColor = sideToMoveFromFen(req.config && req.config.fen ? req.config.fen : state.initialFen);
          const shortlist = shortlistPvEntries(entries, {
            fen: req.config.fen,
            moverColor,
            keepMargin: PV_KEEP_MARGIN,
            onlyOneMargin: PV_ONLY_ONE_MARGIN,
            maxEntries: MULTIPV_MAX_CANDIDATES,
            mateSlack: PV_MATE_SLACK
          });
          req.resolve({
            entries: shortlist.entries,
            depth: req.depth,
            bestmove: line.split(/\s+/)[1] || null,
            shortlist: shortlist.meta
          });
          if (req.pv && typeof req.pv.clear === 'function') {
            req.pv.clear();
          }
          engineController.running = null;
          state.currentRequest = null;
          engineController.pump();
        },
        reset() {
          if (engineController.running && typeof engineController.running.reject === 'function') {
            engineController.running.reject(new Error('Analysis cancelled'));
          }
          engineController.running = null;
          state.currentRequest = null;
          while (state.engineQueue.length) {
            const pending = state.engineQueue.shift();
            if (pending && typeof pending.reject === 'function') {
              pending.reject(new Error('Analysis cancelled'));
            }
          }
          if (state.engine && state.engineReady) {
            state.engine.postMessage('stop');
          }
        }
      };

      function ensureEngine() {
        if (state.engine) return;
        setStatus('engStatus', 'Loading engine…');
        let worker;
        let engineLabel = 'Stockfish';
        try {
          worker = new Worker('node_modules/stockfish/src/stockfish-17.1-lite-single-03e3232.js');
          engineLabel = 'Stockfish 17.1';
        } catch (e) {
          console.error('Failed to load Stockfish worker:', e);
          setStatus('engStatus', 'Failed to load Stockfish.', 'error');
          return;
        }
        if (!worker) {
          setStatus('engStatus', 'Failed to load Stockfish worker.', 'error');
          return;
        }
        state.engine = worker;
        state.engineReady = false;
        state.engineVersion = 'unknown';

        state.engine.onerror = (err) => {
          console.error('Stockfish worker error:', err);
          setStatus('engStatus', 'Engine error: ' + err.message, 'error');
        };

        state.engine.onmessage = (e) => {
          let line = typeof e.data === 'string' ? e.data : '';
          if (!line && e.data && typeof e.data === 'object') {
            line = e.data.data || e.data.text || '';
          }
          if (!line) return;

          if (line.startsWith('id name')) {
            state.engineVersion = line.substring(8).trim();
            engineLabel = state.engineVersion;
            return;
          }

          if (line.startsWith('uciok')) {
            state.engineReady = true;
            setStatus('engStatus', `Engine ready (${engineLabel})`, 'ok');
            if (!state.engineConfigured) {
              state.engine.postMessage('setoption name Threads value 1');
              state.engine.postMessage(`setoption name MultiPV value ${MULTIPV_MAX_CANDIDATES}`);
              state.engine.postMessage('setoption name UCI_ShowWDL value true');
              state.engineConfigured = true;
            }
            engineController.pump();
            if (state.analysisStatus === 'queued') {
              precomputeFullAnalysis();
            }
            return;
          }

          if (line.startsWith('info')) {
            engineController.handleInfo(line);
            return;
          }

          if (line.startsWith('bestmove')) {
            engineController.handleBestMove(line);
            return;
          }
        };

        state.engine.postMessage('uci');
      }

      function waitForEngineReady() {
        if (state.engineReady) return Promise.resolve();
        return new Promise((resolve) => {
          const check = () => {
            if (state.engineReady) {
              resolve();
            } else {
              setTimeout(check, 50);
            }
          };
          check();
        });
      }

      function nextAnalysisToken() {
        state.analysisToken = (state.analysisToken || 0) + 1;
        return state.analysisToken;
      }

      function resetAnalysisState() {
        nextAnalysisToken();
        state.analysisCache = new Map();
        state.analysisByFen = new Map();
        state.analysisPromises = new Map();
        state.analysisStatus = 'idle';
        state.enginePaused = false;
        engineController.reset();
        clearLineOverlay();
        clearMoveClassifications();
        state.evalChartPoints = [];
        state.evalChartLayout = [];
        state.evalChartDataDirty = true;
        state.evalChartHoverIndex = null;
        state.evalChartHoverPosition = null;
        scheduleEvalChartUpdate();
      }

      function setEnginePaused(paused) {
        const nextPaused = Boolean(paused);
        if (state.enginePaused === nextPaused) return;
        state.enginePaused = nextPaused;
        if (nextPaused) {
          nextAnalysisToken();
          engineController.reset();
          state.analysisStatus = 'paused';
          setStatus('engStatus', 'Analysis paused.');
        } else {
          if (state.verboseHistory.length) {
            state.analysisStatus = 'queued';
            setStatus('engStatus', 'Resuming analysis…');
            precomputeFullAnalysis();
          } else {
            setStatus('engStatus', 'Analysis ready.');
          }
        }
      }

      function engineSignature() {
        const version = state.engineVersion || 'unknown';
        return `depth=${DEFAULT_ANALYSIS_DEPTH}|multipv=${MULTIPV_MAX_CANDIDATES}|wdl=1|movetime=${DEFAULT_ANALYSIS_MOVETIME}|engine=${version}`;
      }

      function getAnalysisCacheKey(fen) {
        return `${fen}|${engineSignature()}`;
      }

      function cloneEngineEntry(entry) {
        if (!entry) return null;
        return {
          ...entry,
          pvMoves: Array.isArray(entry.pvMoves) ? entry.pvMoves.slice() : [],
          pvSan: Array.isArray(entry.pvSan) ? entry.pvSan.slice() : [],
          pvVerbose: Array.isArray(entry.pvVerbose) ? entry.pvVerbose.map((mv) => ({ ...mv })) : []
        };
      }

      function getCachedPositionAnalysis(fen) {
        if (!fen) return null;
        const key = getAnalysisCacheKey(fen);
        return state.analysisByFen.get(key) || null;
      }

      function setCachedPositionAnalysis(fen, analysis) {
        if (!fen || !analysis) return;
        const key = getAnalysisCacheKey(fen);
        state.analysisByFen.set(key, analysis);
      }

      async function ensureAnalysisHasMove(analysis, fen, uci, options = {}) {
        if (!analysis || !uci) return null;
        if (!analysis.entriesByUci) {
          analysis.entriesByUci = new Map();
        }
        if (analysis.entriesByUci.has(uci)) {
          return analysis.entriesByUci.get(uci) || null;
        }
        ensureEngine();
        await waitForEngineReady();
        if (options.token != null && options.token !== state.analysisToken) {
          throw new Error('cancelled');
        }
        let forcedResult = null;
        try {
          forcedResult = await engineController.run({
            fen,
            depth: DEFAULT_ANALYSIS_DEPTH,
            movetime: DEFAULT_ANALYSIS_MOVETIME,
            searchMoves: [uci],
            ply: Number.isFinite(options.ply) ? options.ply : 0
          });
        } catch (err) {
          forcedResult = null;
        }
        if (options.token != null && options.token !== state.analysisToken) {
          throw new Error('cancelled');
        }
        const forcedEntry = forcedResult && Array.isArray(forcedResult.entries)
          ? forcedResult.entries.find((entry) => entry && entry.uci === uci) || forcedResult.entries[0] || null
          : null;
        if (!forcedEntry) {
          return null;
        }
        const cloned = cloneEngineEntry(forcedEntry);
        if (cloned && cloned.uci) {
          analysis.entriesByUci.set(cloned.uci, cloned);
        }
        return cloned;
      }

      async function ensureAnalysisForFen(fen, options = {}) {
        if (!fen) return null;
        const key = getAnalysisCacheKey(fen);
        if (state.analysisByFen.has(key)) {
          const cached = state.analysisByFen.get(key);
          if (options.includeMoveUci) {
            await ensureAnalysisHasMove(cached, fen, options.includeMoveUci, options);
          }
          return cached;
        }
        if (state.analysisPromises.has(key)) {
          const existing = await state.analysisPromises.get(key);
          if (options.includeMoveUci) {
            await ensureAnalysisHasMove(existing, fen, options.includeMoveUci, options);
          }
          return existing;
        }

        const promise = (async () => {
          ensureEngine();
          await waitForEngineReady();
          if (options.token != null && options.token !== state.analysisToken) {
            throw new Error('cancelled');
          }
          const result = await engineController.run({
            fen,
            depth: DEFAULT_ANALYSIS_DEPTH,
            movetime: DEFAULT_ANALYSIS_MOVETIME,
            ply: Number.isFinite(options.ply) ? options.ply : 0
          });
          if (options.token != null && options.token !== state.analysisToken) {
            throw new Error('cancelled');
          }
          const entries = Array.isArray(result.entries) ? result.entries.map((entry) => cloneEngineEntry(entry)) : [];
          const bestEntry = entries.find((entry) => entry && entry.rank === 1) || entries[0] || null;
          const summary = buildPositionSummary(fen, entries);
          const analysis = {
            key,
            fen,
            depth: result && Number.isFinite(result.depth) ? result.depth : DEFAULT_ANALYSIS_DEPTH,
            movetime: DEFAULT_ANALYSIS_MOVETIME,
            pvEntries: entries,
            bestEntry,
            shortlistMeta: result && result.shortlist ? { ...result.shortlist } : null,
            summary,
            entriesByUci: new Map(),
            classifications: new Map()
          };
          entries.forEach((entry) => {
            if (entry && entry.uci) {
              analysis.entriesByUci.set(entry.uci, entry);
            }
          });
          setCachedPositionAnalysis(fen, analysis);
          return analysis;
        })();

        state.analysisPromises.set(key, promise);
        try {
          const analysis = await promise;
          if (options.includeMoveUci) {
            await ensureAnalysisHasMove(analysis, fen, options.includeMoveUci, options);
          }
          return analysis;
        } finally {
          state.analysisPromises.delete(key);
        }
      }

      function formatPositionAnalysis(cached) {
        if (!cached) return null;
        return {
          pvEntries: Array.isArray(cached.pvEntries) ? cached.pvEntries : [],
          bestEntry: cached.bestEntry || null,
          shortlist: cached.shortlistMeta || null,
          depth: cached.depth || 0,
          movetime: cached.movetime || null,
          summary: cached.summary || null,
          classification: null,
          overlay: null,
          suggestionTag: null,
          actualEntry: null,
          beforeEp: null,
          bestEp: null,
          actualEp: null,
          bestCp: null,
          actualCp: null,
          cpLoss: null,
          winPercentBefore: null,
          winPercentAfter: null,
          accuracy: null,
          explanation: null,
          planScenarios: null,
          postAnalysis: cached
        };
      }

      function getAnalysisForCurrentView() {
        if (state.suggestionMode === 'next') {
          if (state.ply >= state.verboseHistory.length) {
            const currentNode = state.ply > 0 ? state.verboseHistory[state.ply - 1] : getRootNode();
            const fen = currentNode && currentNode.fen ? currentNode.fen : effectiveInitialFen();
            const cached = getCachedPositionAnalysis(fen);
            return formatPositionAnalysis(cached);
          }
          const nextNode = state.verboseHistory[state.ply];
          if (!nextNode) {
            const currentNode = state.ply > 0 ? state.verboseHistory[state.ply - 1] : getRootNode();
            const fen = currentNode && currentNode.fen ? currentNode.fen : effectiveInitialFen();
            const cached = getCachedPositionAnalysis(fen);
            return formatPositionAnalysis(cached);
          }
          return nextNode.analysis || state.analysisCache.get(nextNode.id) || null;
        }
        if (state.ply === 0) {
          const cached = getCachedPositionAnalysis(effectiveInitialFen());
          return formatPositionAnalysis(cached);
        }
        const currentNode = state.verboseHistory[state.ply - 1];
        if (!currentNode) return null;
        return currentNode.analysis || state.analysisCache.get(currentNode.id) || null;
      }

      function updateClassificationChips(classification) {
        const container = byId('classificationChipGroup');
        if (!container) return;
        const normalized = classification ? classification.toLowerCase() : '';
        Array.from(container.querySelectorAll('button[data-classification]')).forEach((btn) => {
          const value = (btn.dataset.classification || '').toLowerCase();
          btn.classList.toggle('active', normalized && value === normalized);
        });
      }

      function getEntryClassification(entry) {
        if (!entry) return null;
        const analysis = entry.analysis || (entry.id ? state.analysisCache.get(entry.id) : null);
        if (analysis && (analysis.overlay || analysis.classification)) {
          return (analysis.overlay || analysis.classification || '').toLowerCase();
        }
        return null;
      }

      function jumpToClassification(kind) {
        const normalized = typeof kind === 'string' ? kind.toLowerCase() : '';
        if (!normalized) return;
        const label = normalized.charAt(0).toUpperCase() + normalized.slice(1);
        const total = state.verboseHistory.length;
        if (!total) {
          setStatus('navStatus', `No ${label} moves available.`, 'error');
          return;
        }
        const start = state.ply > 0 ? state.ply - 1 : -1;
        for (let offset = 1; offset <= total; offset++) {
          const idx = (start + offset) % total;
          const entry = state.verboseHistory[idx];
          const classification = getEntryClassification(entry);
          if (classification === normalized) {
            setStatus('navStatus', '');
            goToPly(idx + 1);
            return;
          }
        }
        setStatus('navStatus', `No ${label} moves found.`, 'error');
      }

      function updateExplanationPanel(analysis) {
        const summaryEl = byId('explanationSummary');
        const detailsEl = byId('explanationDetails');
        const cardsEl = byId('explanationCards');
        if (!summaryEl || !detailsEl) return;

        const defaultMessage = state.suggestionMode === 'next'
          ? 'Engine suggestion will appear after analysis finishes.'
          : 'Select a move to see the engine’s commentary.';

        let payload = null;
        let activeClassification = null;
        if (analysis) {
          if (state.suggestionMode === 'played') {
            activeClassification = analysis.overlay || analysis.classification || null;
          }
          const moveEntry = state.ply > 0 ? state.verboseHistory[state.ply - 1] : null;
          if (moveEntry && analysis.explanation) {
            payload = analysis.explanation;
          } else if (moveEntry) {
            payload = buildMoveExplanation({
              moveEntry,
              bestEntry: analysis.bestEntry,
              actualEntry: analysis.actualEntry,
              bestEval: parseEvalString(analysis.bestEntry ? analysis.bestEntry.eval : null),
              actualEval: parseEvalString(analysis.actualEntry ? analysis.actualEntry.eval : null),
              beforeEp: analysis.beforeEp,
              bestEp: analysis.bestEp,
              actualEp: analysis.actualEp,
              cpLoss: analysis.cpLoss,
              classification: analysis.classification,
              overlay: analysis.overlay
            });
          }
        }

        if (!payload) {
          if (state.suggestionMode === 'next' && state.ply >= state.verboseHistory.length) {
            summaryEl.textContent = 'Game complete — no next move to suggest.';
          } else if (state.suggestionMode === 'next' && state.analysisStatus === 'running') {
            summaryEl.textContent = 'Analyzing next move…';
          } else if (state.ply === 0 && state.suggestionMode === 'played') {
            summaryEl.textContent = defaultMessage;
          } else if (!analysis && state.analysisStatus !== 'complete') {
            summaryEl.textContent = 'Engine explanation will appear when analysis is ready.';
          } else {
            summaryEl.textContent = defaultMessage;
          }
          if (cardsEl) cardsEl.innerHTML = '';
          detailsEl.innerHTML = '';
          updateGhostTokenState();
          updateClassificationChips(null);
          return;
        }

        summaryEl.textContent = payload.headline || defaultMessage;
        if (cardsEl) cardsEl.innerHTML = '';
        if (cardsEl && Array.isArray(payload.cards) && payload.cards.length) {
          payload.cards.forEach((card) => {
            if (!card || (!card.headline && (!Array.isArray(card.bullets) || !card.bullets.length))) return;
            const cardEl = document.createElement('div');
            cardEl.className = 'explanation-card';
            if (card.title) {
              const titleEl = document.createElement('div');
              titleEl.className = 'explanation-card-title';
              titleEl.textContent = card.title;
              cardEl.appendChild(titleEl);
            }
            if (card.headline) {
              const headlineRow = document.createElement('div');
              headlineRow.className = 'explanation-card-headline-row';
              const headEl = document.createElement('div');
              headEl.className = 'explanation-card-headline explanation-card-headline-text';
              headEl.textContent = card.headline;
              headlineRow.appendChild(headEl);
              if (card.key && SHOW_LINE_CARD_KEYS.has(card.key)) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'secondary compact';
                btn.dataset.action = 'show-line';
                btn.dataset.kind = card.key;
                btn.setAttribute('aria-pressed', 'false');
                btn.disabled = true;
                btn.textContent = card.key === 'problem' ? 'Show reply' : 'Show line';
                headlineRow.appendChild(btn);
              }
              cardEl.appendChild(headlineRow);
            }
            if (Array.isArray(card.bullets) && card.bullets.length) {
              const listEl = document.createElement('ul');
              listEl.className = 'explanation-card-list';
              card.bullets.forEach((text) => {
                if (!text) return;
                if (isContinuationEntry(text)) {
                  const item = createContinuationListItem(text);
                  if (item) listEl.appendChild(item);
                  return;
                }
                const li = document.createElement('li');
                li.textContent = text;
                listEl.appendChild(li);
              });
              if (listEl.childNodes.length) {
                cardEl.appendChild(listEl);
              }
            }
            cardsEl.appendChild(cardEl);
          });
        }
        refreshShowLineButtons(analysis);
        detailsEl.innerHTML = '';
        if (Array.isArray(payload.details) && payload.details.length) {
          const list = document.createElement('ul');
          payload.details.forEach((line) => {
            if (!line) return;
            if (isContinuationEntry(line)) {
              const item = createContinuationListItem(line);
              if (item) list.appendChild(item);
              return;
            }
            const item = document.createElement('li');
            item.textContent = line;
            list.appendChild(item);
          });
          if (list.childNodes.length) {
            detailsEl.appendChild(list);
          }
        }
        updateGhostTokenState();
        updateClassificationChips(activeClassification);
      }

      function applyAnalysisForCurrentPly() {
        const analysis = getAnalysisForCurrentView();
        if (analysis) {
          redrawAllArrows();
          updatePVDisplay(analysis.pvEntries || []);
          updateExplanationPanel(analysis);
          let evalText = null;
          if (state.suggestionMode === 'played') {
            if (analysis.actualEntry && analysis.actualEntry.eval) {
              evalText = analysis.actualEntry.eval;
            } else if (state.ply > 0 && analysis.bestEntry && analysis.bestEntry.eval) {
              evalText = analysis.bestEntry.eval;
            }
          } else if (analysis.bestEntry && analysis.bestEntry.eval) {
            evalText = analysis.bestEntry.eval;
          }
          updateEvalBar(evalText);
          const baseStatus = `Precomputed (depth ${analysis.depth || 0})`;
          const shortlistMessage = analysis.shortlist && analysis.shortlist.message ? analysis.shortlist.message : null;
          setStatus('engStatus', shortlistMessage ? `${baseStatus} — ${shortlistMessage}` : baseStatus);
          renderBoardStatus();
          scheduleEvalChartUpdate();
          return;
        }

        redrawAllArrows([]);
        updatePVDisplay([]);
        updateExplanationPanel(null);
        if (state.suggestionMode === 'next') {
          updateEvalBar(null);
          if (state.ply >= state.verboseHistory.length) {
            setStatus('engStatus', 'Game complete. No next move to analyze.');
          } else if (state.analysisStatus === 'running' || state.analysisStatus === 'queued') {
            setStatus('engStatus', state.analysisStatus === 'queued' ? 'Preparing analysis…' : 'Analyzing entire game…');
          } else if (state.analysisStatus === 'position') {
            setStatus('engStatus', 'Analyzing position…');
          } else {
            setStatus('engStatus', 'Next-move suggestion not available yet.');
          }
          renderBoardStatus();
          scheduleEvalChartUpdate();
          return;
        }

        if (state.analysisStatus === 'running' || state.analysisStatus === 'queued') {
          setStatus('engStatus', state.analysisStatus === 'queued' ? 'Preparing analysis…' : 'Analyzing entire game…');
        } else if (state.analysisStatus === 'position') {
          setStatus('engStatus', 'Analyzing position…');
        }
        if (state.ply === 0) {
          updateEvalBar(null);
        } else {
          const entry = state.verboseHistory[state.ply - 1];
          let evalText = entry && entry.eval ? entry.eval : null;
          if (!evalText && entry && entry.san && entry.san.includes('#')) {
            evalText = entry.color === 'b' ? '#-1' : '#1';
          }
          updateEvalBar(evalText);
        }
        renderBoardStatus();
        scheduleEvalChartUpdate();
      }
      async function analyzeMoveAtIndex(index, beforeEp, token) {
        const moveEntry = state.verboseHistory[index];
        if (!moveEntry) return { afterEp: beforeEp };
        const result = await analyzeMoveEntry(moveEntry, {
          beforeEp,
          token,
          previousMoveEntry: index > 0 ? state.verboseHistory[index - 1] : null,
          ensurePostAnalysis: true
        });
        if (result && result.cancelled) {
          return { afterEp: beforeEp };
        }
        if (state.ply === index + 1 || (state.suggestionMode === 'next' && state.ply === index)) {
          applyAnalysisForCurrentPly();
        }
        renderMoves();
        updateEloEstimates();
        scheduleEvalChartUpdate({ recomputeData: true });
        return { afterEp: result && Number.isFinite(result.afterEp) ? result.afterEp : beforeEp };
      }
      async function precomputeFullAnalysis() {
        const token = nextAnalysisToken();
        state.analysisCache = new Map();
        state.analysisStatus = state.verboseHistory.length ? 'running' : 'complete';
        renderMoves();
        updatePVDisplay([]);
        redrawAllArrows([]);
        if (!state.verboseHistory.length) {
          updateEvalBar(null);
          setStatus('engStatus', 'No moves to analyze.');
          return;
        }
        setStatus('engStatus', 'Analyzing full game…');
        ensureEngine();
        await waitForEngineReady();
        if (token !== state.analysisToken) return;
        if (state.enginePaused) {
          state.analysisStatus = 'paused';
          setStatus('engStatus', 'Analysis paused.');
          return;
        }
        if (state.engine) {
          state.engine.postMessage('ucinewgame');
        }
        let beforeEp = 0.5;
        for (let i = 0; i < state.verboseHistory.length; i++) {
          if (token !== state.analysisToken) return;
          const result = await analyzeMoveAtIndex(i, beforeEp, token);
          if (token !== state.analysisToken) return;
          // Carry White's expected points forward unchanged so the next
          // iteration receives the same reference frame. Inverting the value
          // incorrectly swaps the perspective between plies and can misclassify
          // moves (e.g., showing "Great" overlays for blunders).
          beforeEp = result.afterEp;
          setStatus('engStatus', `Analyzed ${i + 1}/${state.verboseHistory.length} moves`);
        }
        if (token !== state.analysisToken) return;
        state.analysisStatus = 'complete';
        setStatus('engStatus', `Analysis complete (${state.engineVersion || 'Stockfish'})`);
        applyAnalysisForCurrentPly();
        renderMoves();
      }

      function initializeGame({ headers = {}, verboseHistory = [], initialFen = 'start', source, rawInput, targetPly }) {
        state.initialFen = initialFen || 'start';
        if (typeof source === 'string') state.source = source;
        if (typeof rawInput === 'string') state.rawInput = rawInput;
        resetAnalysisState();
        buildMoveTree(verboseHistory, state.initialFen);
        initializePieceCounts();
        state.game = createBaseGame();
        state.ply = 0;
        state.headers = { ...headers };
        updatePlayerNameDisplays();
        setBoardPosition(state.initialFen);
        populateHeaders(headers);
        renderMoves();
        updateMaterialDiff();
        updateEvalBar(null);
        updatePVDisplay([]);
        updateEloEstimates();
        const destination = typeof targetPly === 'number' ? targetPly : verboseHistory.length;
        redrawAllArrows([]);
        goToPly(destination);
        state.evalChartDataDirty = true;
        scheduleEvalChartUpdate({ recomputeData: true });
        state.analysisStatus = 'queued';
        precomputeFullAnalysis();
        setStatus('loadStatus', 'Game ready.', 'ok');
        updateUrlState();
      }

      async function loadFromPgnString(pgn, options = {}) {
        const trimmed = (pgn || '').trim();
        if (!trimmed) {
          setStatus('loadStatus', 'Please provide PGN text.', 'error');
          return;
        }
        try {
          setStatus('loadStatus', 'Loading PGN…');
          const headers = parseHeaders(trimmed);
          const initialFen = headers.FEN || 'start';
          const parser = initialFen && initialFen !== 'start' ? new Chess(initialFen) : new Chess();
          const ok = parser.loadPgn(trimmed, { sloppy: true });
          if (!ok) throw new Error('Unable to parse PGN.');
          const history = buildHistory(parser, initialFen);
          initializeGame({
            headers,
            verboseHistory: history,
            initialFen,
            source: options.source || 'pgn',
            rawInput: typeof options.rawInput === 'string' ? options.rawInput : trimmed,
            targetPly: options.targetPly
          });
        } catch (err) {
          console.error(err);
          setStatus('loadStatus', err.message || 'Failed to load PGN.', 'error');
        }
      }

      async function loadFromLichessInput(raw, options = {}) {
        const trimmed = (raw || '').trim();
        if (!trimmed) {
          setStatus('loadStatus', 'Please paste a Lichess URL or ID.', 'error');
          return;
        }
        try {
          setStatus('loadStatus', 'Fetching PGN…');
          const pgn = await fetchPGN(trimmed);
          await loadFromPgnString(pgn, {
            source: 'lichess',
            rawInput: trimmed,
            targetPly: options.targetPly
          });
        } catch (err) {
          console.error(err);
          setStatus('loadStatus', err.message || 'Failed to fetch game.', 'error');
        }
      }

      function loadFromFenInput(raw, options = {}) {
        const trimmed = (raw || '').trim();
        if (!trimmed) {
          setStatus('loadStatus', 'Please provide a FEN string.', 'error');
          return;
        }
        const fenGame = new Chess();
        if (!fenGame.load(trimmed)) {
          setStatus('loadStatus', 'Invalid FEN string.', 'error');
          return;
        }
        const headers = {
          White: '—',
          Black: '—',
          Site: 'Custom FEN',
          Result: '*',
          Date: new Date().toISOString().slice(0, 10)
        };
        initializeGame({
          headers,
          verboseHistory: [],
          initialFen: trimmed,
          source: 'fen',
          rawInput: trimmed,
          targetPly: typeof options.targetPly === 'number' ? options.targetPly : 0
        });
        setStatus('loadStatus', 'Position ready.', 'ok');
      }

      async function handleUserLoad(targetPly = null) {
        const mode = byId('inputMode').value;
        const value = byId('gameInput').value;
        if (mode === 'lichess') {
          await loadFromLichessInput(value, { targetPly });
        } else if (mode === 'fen') {
          loadFromFenInput(value, { targetPly });
        } else {
          await loadFromPgnString(value, { source: 'pgn', rawInput: value, targetPly });
        }
      }

      function buildCurrentPgnString() {
        const headers = { ...(state.headers || {}) };
        if (state.initialFen && state.initialFen !== 'start') {
          if (!headers.FEN) headers.FEN = state.initialFen;
          if (!headers.SetUp) headers.SetUp = '1';
        }

        const headerLines = Object.entries(headers)
          .filter(([, value]) => typeof value === 'string' && value.trim().length > 0)
          .map(([key, value]) => `[${key} "${value.replace(/"/g, '\\"')}"]`);

        const moves = [];
        const history = Array.isArray(state.verboseHistory) ? state.verboseHistory : [];
        history.forEach((entry, index) => {
          if (!entry || !entry.san) return;
          const moveNumber = entry.moveNumber || Math.floor(index / 2) + 1;
          const san = entry.san.trim();
          const isWhiteMove = entry.color === 'w' || (entry.color !== 'b' && index % 2 === 0);
          if (isWhiteMove) {
            moves.push(`${moveNumber}. ${san}`);
          } else if (moves.length) {
            moves[moves.length - 1] = `${moves[moves.length - 1]} ${san}`;
          } else {
            moves.push(`${moveNumber}... ${san}`);
          }
        });

        const result = headers.Result && headers.Result.trim() ? headers.Result.trim() : '*';
        const moveSection = moves.length ? `${moves.join(' ')} ${result}`.trim() : result;
        const sections = [];
        if (headerLines.length) {
          sections.push(headerLines.join('\n'));
        }
        sections.push(moveSection);
        return sections.join('\n\n').trim();
      }

      function exportCurrentGame() {
        const hasHistory = Array.isArray(state.verboseHistory) && state.verboseHistory.length > 0;
        const hasHeaders = state.headers && Object.keys(state.headers).length > 0;
        const hasRaw = typeof state.rawInput === 'string' && state.rawInput.trim().length > 0;
        if (!hasHistory && !hasHeaders && !hasRaw) {
          setStatus('loadStatus', 'Load a game before exporting.', 'error');
          return;
        }

        try {
          const pgn = buildCurrentPgnString();
          if (!pgn) {
            setStatus('loadStatus', 'Nothing to export yet.', 'error');
            return;
          }
          const safeToken = (value) => (value || '')
            .toString()
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '');
          const white = safeToken(state.headers && state.headers.White) || 'white';
          const black = safeToken(state.headers && state.headers.Black) || 'black';
          const slug = [white, 'vs', black].filter(Boolean).join('-').replace(/-+/g, '-');
          const filename = slug ? `${slug}.pgn` : 'analysis.pgn';
          const blob = new Blob([`${pgn}\n`], { type: 'application/x-chess-pgn' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          setStatus('loadStatus', `Exported ${filename}.`, 'ok');
        } catch (err) {
          console.error('Failed to export PGN', err);
          setStatus('loadStatus', 'Unable to export PGN.', 'error');
        }
      }

      function handleLoadAffordanceClick(event) {
        const button = event.target.closest('button[data-load-action]');
        if (!button) return;
        const action = button.dataset.loadAction;
        if (action === 'paste') {
          setInputMode('pgn');
          const input = byId('gameInput');
          if (input) input.focus();
        } else if (action === 'upload') {
          const fileInput = byId('pgnFileInput');
          if (fileInput) fileInput.click();
        } else if (action === 'fen') {
          setInputMode('fen');
          const input = byId('gameInput');
          if (input) input.focus();
        } else if (action === 'lichess') {
          setInputMode('lichess');
          const input = byId('gameInput');
          if (input) input.focus();
        } else if (action === 'export') {
          exportCurrentGame();
        }
      }

      function handleFileUpload(fileList) {
        if (!fileList || fileList.length === 0) return;
        const [file] = fileList;
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
          const text = typeof event.target.result === 'string' ? event.target.result : '';
          const trimmed = (text || '').trim();
          if (!trimmed) {
            setStatus('loadStatus', 'File was empty.', 'error');
            return;
          }
          const words = trimmed.split(/\s+/);
          const looksLikeFen = trimmed.includes('/') && words.length >= 6 && words.length <= 8;
          setInputMode(looksLikeFen ? 'fen' : 'pgn');
          const input = byId('gameInput');
          if (input) {
            input.value = trimmed;
            input.focus();
          }
          setStatus('loadStatus', `${file.name} loaded. Press Load to analyze.`, 'ok');
        };
        reader.onerror = () => {
          setStatus('loadStatus', 'Failed to read file.', 'error');
        };
        reader.readAsText(file);
      }

      function bindUi() {
        byId('loadBtn').addEventListener('click', () => handleUserLoad());
        byId('inputMode').addEventListener('change', (event) => {
          setInputMode(event.target.value);
        });
        const input = byId('gameInput');
        input.addEventListener('keydown', (event) => {
          if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            event.preventDefault();
            handleUserLoad();
          }
        });
        byId('firstBtn').addEventListener('click', () => goToPly(0));
        byId('prevBtn').addEventListener('click', () => goToPly(state.ply - 1));
        byId('nextBtn').addEventListener('click', () => goToPly(state.ply + 1));
        byId('lastBtn').addEventListener('click', () => goToPly(state.verboseHistory.length));
        byId('flipBtn').addEventListener('click', () => {
          state.orientation = state.orientation === 'white' ? 'black' : 'white';
          state.board.flip();
          updateEvalBar(state.lastEval);
          updateEvalBarHeight();
          scheduleBoardDecorations();
          requestAnimationFrame(() => {
            const analysis = getAnalysisForCurrentView();
            redrawAllArrows();
            updateBoardClassificationBadge();
          });
        });
        const exploreToggle = byId('exploreToggle');
        if (exploreToggle) {
          exploreToggle.addEventListener('click', () => {
            toggleExploreMode();
          });
        }
        const rejoinBtn = byId('rejoinBtn');
        if (rejoinBtn) {
          rejoinBtn.addEventListener('click', () => {
            rejoinMainLine();
          });
        }
        const resetExplore = byId('exploreResetBtn');
        if (resetExplore) {
          resetExplore.addEventListener('click', () => {
            rejoinMainLine();
          });
        }
        byId('themeToggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          setTheme(newTheme);
        });
        const suggestionToggle = byId('suggestionToggle');
        if (suggestionToggle) {
          suggestionToggle.addEventListener('change', () => {
            setSuggestionMode(suggestionToggle.checked ? 'next' : 'played');
          });
        }
        const suggestionToggleOffLabel = byId('suggestionToggleOffLabel');
        if (suggestionToggleOffLabel) {
          const activatePlayed = () => setSuggestionMode('played');
          suggestionToggleOffLabel.addEventListener('click', activatePlayed);
          suggestionToggleOffLabel.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              activatePlayed();
            }
          });
        }
        const suggestionToggleOnLabel = byId('suggestionToggleOnLabel');
        if (suggestionToggleOnLabel) {
          const activateNext = () => setSuggestionMode('next');
          suggestionToggleOnLabel.addEventListener('click', activateNext);
          suggestionToggleOnLabel.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              activateNext();
            }
          });
        }
        const loadAffordanceGroup = byId('loadAffordanceGroup');
        if (loadAffordanceGroup) {
          loadAffordanceGroup.addEventListener('click', (event) => {
            handleLoadAffordanceClick(event);
          });
        }
        const fileInput = byId('pgnFileInput');
        if (fileInput) {
          fileInput.addEventListener('change', (event) => {
            handleFileUpload(event.target.files);
            event.target.value = '';
          });
        }
        const classificationGroup = byId('classificationChipGroup');
        if (classificationGroup) {
          classificationGroup.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-classification]');
            if (button) {
              jumpToClassification(button.dataset.classification);
            }
          });
        }
        const cardsContainer = byId('explanationCards');
        if (cardsContainer) {
          cardsContainer.addEventListener('click', handleExplanationCardClick);
        }
        const explanationDetails = byId('explanationDetails');
        if (explanationDetails) {
          explanationDetails.addEventListener('click', (event) => {
            handleContinuationTokenInteraction(event);
          });
        }
        const clearOverlayBtn = byId('clearLineOverlayBtn');
        if (clearOverlayBtn) {
          clearOverlayBtn.addEventListener('click', () => clearLineOverlay());
        }
        updateLineOverlayButton();
        updateExploreControls();
        document.addEventListener('keydown', handleDocumentKeydown);
        document.addEventListener('click', handleDocumentClickForGhost);
        updateClassificationChips(null);
      }

      function initCollapsiblePanels() {
        const compactLayout = shouldUseCompactInfoLayout();
        const panelDefaults = {
          engineExplanationCard: true,
          gameInfoPanel: !compactLayout,
          movesPanel: false,
          moveSummaryPanel: false,
          engineSuggestions: true
        };

        function setupPanel(id) {
          const el = byId(id);
          if (!el) return;
          el.open = restorePanelState(id, panelDefaults[id] ?? false);
          el.addEventListener('toggle', () => {
            persistPanelState(id, el.open);
          });
        }

        setupPanel('engineExplanationCard');
        setupPanel('engineSuggestions');
        setupPanel('gameInfoPanel');
        setupPanel('movesPanel');
        setupPanel('moveSummaryPanel');

        const media = window.matchMedia ? window.matchMedia('(max-width: 1199px)') : null;
        if (media) {
          const applyGameInfoDefault = (matches) => {
            if (hasStoredPanelState('gameInfoPanel')) return;
            const panel = byId('gameInfoPanel');
            if (!panel) return;
            panel.open = !matches;
          };

          applyGameInfoDefault(compactLayout);

          if (typeof media.addEventListener === 'function') {
            media.addEventListener('change', (event) => {
              applyGameInfoDefault(event.matches);
            });
          } else if (typeof media.addListener === 'function') {
            media.addListener((event) => {
              applyGameInfoDefault(event.matches);
            });
          }
      }
    }

    function getSavedBoardStyle() {
      return localStorage.getItem(BOARD_STYLE_STORAGE_KEY);
    }

    function normalizeBoardStyle(value) {
      if (!value) return 'glass';
      const lower = value.toLowerCase();
      if (Object.prototype.hasOwnProperty.call(LEGACY_BOARD_STYLE_MAP, lower)) {
        return LEGACY_BOARD_STYLE_MAP[lower];
      }
      return BOARD_STYLES.includes(lower) ? lower : 'glass';
    }

    function applyBoardStyle(style) {
      const normalized = normalizeBoardStyle(style);
      const shell = document.querySelector('.board-shell');
      if (shell) {
        shell.setAttribute('data-board-style', normalized);
      }
      return normalized;
    }

    function persistBoardStyle(style) {
      try {
        localStorage.setItem(BOARD_STYLE_STORAGE_KEY, style);
      } catch (err) {
        console.warn('Unable to persist board style', err);
      }
    }

    function setBoardStyle(style) {
      const normalized = applyBoardStyle(style);
      persistBoardStyle(normalized);
      const select = document.getElementById('boardStyle');
      if (select && select.value !== normalized) {
        select.value = normalized;
      }
      scheduleBoardDecorations();
    }

    function getEffectiveBoardStyle() {
      const saved = getSavedBoardStyle();
      return normalizeBoardStyle(saved);
    }

    function initBoardStyleUI() {
      const select = document.getElementById('boardStyle');
      if (!select) return;

      const initial = getEffectiveBoardStyle();
      if (initial !== getSavedBoardStyle()) {
        persistBoardStyle(initial);
      }
      select.value = initial;
      applyBoardStyle(initial);

      select.addEventListener('change', () => {
        setBoardStyle(select.value);
      });
    }

    function onThemeChanged() {
      applyBoardStyle(getEffectiveBoardStyle());
    }

    function getSystemTheme() {
      return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    function getSavedTheme() {
      return localStorage.getItem('theme');
    }

      function setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        updateThemeButton(theme);
        onThemeChanged(theme);
      }

      function updateThemeButton(theme) {
        const button = byId('themeToggle');
        if (theme === 'dark') {
          button.textContent = '☀️ Light';
          button.title = 'Switch to light theme';
        } else {
          button.textContent = '🌙 Dark';
          button.title = 'Switch to dark theme';
        }
      }

      function initTheme() {
        const savedTheme = getSavedTheme();
        const systemTheme = getSystemTheme();
        const theme = savedTheme || systemTheme;
        setTheme(theme);
        if (window.matchMedia) {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!getSavedTheme()) {
              setTheme(e.matches ? 'dark' : 'light');
            }
          });
        }
      }

      async function loadFromQuery() {
        const params = new URLSearchParams(window.location.search);
        const sourceParam = params.get('source');
        const dataParam = params.get('data');
        const legacyGame = params.get('game');
        const plyParam = parseInt(params.get('ply'), 10);
        const targetPly = Number.isFinite(plyParam) ? plyParam : null;

        try {
          if (!sourceParam && legacyGame) {
            setInputMode('lichess');
            byId('gameInput').value = legacyGame;
            await loadFromLichessInput(legacyGame, { targetPly });
            return;
          }

          if (!sourceParam || !dataParam) {
            setInputMode('pgn');
            return;
          }

          const raw = decodeStateValue(dataParam);
          if (!raw) return;

          setInputMode(sourceParam);
          byId('gameInput').value = raw;

          if (sourceParam === 'pgn') {
            await loadFromPgnString(raw, { source: 'pgn', rawInput: raw, targetPly });
          } else if (sourceParam === 'lichess') {
            await loadFromLichessInput(raw, { targetPly });
          } else if (sourceParam === 'fen') {
            loadFromFenInput(raw, { targetPly });
          }
        } catch (err) {
          console.error(err);
        }
      }

      async function main() {
        if (typeof window.Chessboard === 'undefined') {
          setStatus('loadStatus', 'Failed to load chessboard.js', 'error');
          return;
        }
        if (typeof Chess === 'undefined') {
          setStatus('loadStatus', 'Failed to load chess.js', 'error');
          return;
        }

        initTheme();
        initNavToolbar();
        initBoardStyleUI();
        initBoard();
        initMoveSummary();
        updateMoveSummary();
        setInputMode('pgn');
        bindUi();
        initCollapsiblePanels();
        initSuggestionMode();
        initializePieceCounts();
        state.game = createBaseGame();
        updateMaterialDiff();
        updateEvalBar(null);
        updatePVDisplay([]);
        updateEloEstimates();
        setStatus('engStatus', 'Initializing engine…');
        ensureEngine();

        await loadFromQuery();
      }

      window.addEventListener('load', main);
    })();
  </script>

</body>

</html>