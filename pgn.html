<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lichess PGN Analyzer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111c34;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #38bdf8;
      --accent-strong: #0ea5e9;
      --ok: #22c55e;
      --warn: #facc15;
      --danger: #f87171;
      --panel-border: rgba(148, 163, 184, 0.2);
      --eval-white: #f8fafc;
      --eval-black: #0b1220;
      --eval-border: rgba(148, 163, 184, 0.28);
      --material-positive: #4ade80;
      --material-negative: #f87171;
      --input-bg: rgba(15, 23, 42, 0.75);
      --input-border: rgba(148, 163, 184, 0.3);
      --shadow: 0 18px 48px rgba(8, 15, 35, 0.55);
    }

    [data-theme="light"] {
      --bg: #f1f5f9;
      --panel: #ffffff;
      --text: #0f172a;
      --muted: #475569;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --ok: #15803d;
      --warn: #b45309;
      --danger: #dc2626;
      --panel-border: rgba(15, 23, 42, 0.08);
      --eval-white: #ffffff;
      --eval-black: #1f2937;
      --eval-border: rgba(148, 163, 184, 0.25);
      --material-positive: #15803d;
      --material-negative: #dc2626;
      --input-bg: #f8fafc;
      --input-border: rgba(15, 23, 42, 0.12);
      --shadow: 0 12px 32px rgba(15, 23, 42, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      color: var(--text);
      background: var(--bg);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    h1 {
      margin: 0 0 20px;
      font-size: 26px;
      letter-spacing: 0.4px;
    }

    a {
      color: var(--accent);
    }

    .layout {
      display: grid;
      gap: 18px;
      align-items: start;
      grid-template-columns: minmax(320px, 420px) minmax(340px, 1fr);
      max-width: 1200px;
      margin: 0 auto;
    }

    @media (max-width: 1024px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 18px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: stretch;
    }

    .row+.row {
      margin-top: 12px;
    }

    input[type="text"],
    input[type="number"],
    input[type="password"],
    textarea,
    select {
      flex: 1;
      min-width: 0;
      padding: 10px 12px;
      border: 1px solid var(--input-border);
      border-radius: 10px;
      background: var(--input-bg);
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s ease, background-color 0.2s ease, color 0.2s ease;
    }

    textarea {
      resize: vertical;
      min-height: 140px;
      line-height: 1.45;
    }

    select {
      flex: 0 0 180px;
      cursor: pointer;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    input[type="password"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
    }

    button {
      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-strong) 100%);
      border: 1px solid rgba(15, 23, 42, 0.25);
      color: #f8fafc;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform 0.12s ease, filter 0.2s ease;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--panel-border);
    }

    button:hover {
      filter: brightness(1.05);
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      min-height: 20px;
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .status.error {
      color: var(--danger);
    }

    .status.ok {
      color: var(--ok);
    }

    .board-area {
      display: flex;
      gap: 18px;
      align-items: stretch;
    }

    .board-wrap {
      position: relative;
      flex: 1;
    }

    #board {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
    }

    #arrowLayer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
    }

    .board-badge-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .board-move-badge {
      position: absolute;
      width: 46px;
      height: 46px;
      border-radius: 50%;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.82);
      border: 2px solid transparent;
      box-shadow: 0 12px 30px rgba(8, 15, 35, 0.45);
      transform: translate(-50%, -50%);
    }

    .board-move-badge-icon {
      width: 26px;
      height: 26px;
      object-fit: contain;
      filter: drop-shadow(0 1px 4px rgba(8, 15, 35, 0.45));
    }

    .board-move-badge[data-classification="best"],
    .board-move-badge[data-classification="excellent"],
    .board-move-badge[data-classification="good"],
    .board-move-badge[data-classification="brilliant"],
    .board-move-badge[data-classification="great"] {
      border-color: var(--ok);
      background: rgba(34, 197, 94, 0.2);
    }

    .board-move-badge[data-classification="book"] {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.22);
    }

    .board-move-badge[data-classification="inaccuracy"],
    .board-move-badge[data-classification="miss"] {
      border-color: var(--warn);
      background: rgba(250, 204, 21, 0.24);
    }

    .board-move-badge[data-classification="mistake"],
    .board-move-badge[data-classification="blunder"] {
      border-color: var(--danger);
      background: rgba(248, 113, 113, 0.25);
    }

    .eval-column {
      width: 52px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .eval-vertical {
      position: relative;
      width: 36px;
      flex: 1;
      min-height: 260px;
      background: var(--eval-black);
      border-radius: 18px;
      border: 1px solid var(--eval-border);
      overflow: hidden;
      box-shadow: inset 0 0 20px rgba(8, 15, 35, 0.4);
    }

    .eval-fill {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      height: 50%;
      background: var(--eval-white);
      transition: height 0.25s ease;
    }

    .eval-marker {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
      box-shadow: 0 0 8px rgba(56, 189, 248, 0.5);
      transition: top 0.25s ease;
      pointer-events: none;
    }

    .eval-label {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .eval-label-black {
      opacity: 0.85;
    }

    .material-panel {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 12px;
      margin-top: 14px;
    }

    .material-card {
      background: rgba(148, 163, 184, 0.12);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 4px;
    }

    [data-theme="light"] .material-card {
      background: rgba(37, 99, 235, 0.06);
    }

    .material-player {
      font-size: 13px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .material-score {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 18px;
      font-weight: 600;
      transition: color 0.2s ease;
    }

    .material-score.positive {
      color: var(--material-positive);
    }

    .material-score.negative {
      color: var(--material-negative);
    }

    .material-capture {
      font-size: 12px;
      color: var(--muted);
    }

    .summary-scroll {
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .summary-table {
      display: grid;
      gap: 10px;
      min-width: 640px;
    }

    .summary-row {
      display: grid;
      align-items: center;
      gap: 8px;
    }

    .summary-row.summary-header {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      padding: 0 4px;
    }

    .summary-row[data-color] {
      background: rgba(148, 163, 184, 0.12);
      border-radius: 12px;
      padding: 10px 12px;
    }

    [data-theme="light"] .summary-row[data-color] {
      background: rgba(37, 99, 235, 0.06);
    }

    .summary-cell {
      text-align: center;
      font-weight: 600;
      font-size: 14px;
    }

    .summary-cell-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
    }

    .summary-icon {
      width: 20px;
      height: 20px;
      object-fit: contain;
    }

    .summary-player-cell {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .summary-player-name {
      font-weight: 600;
      font-size: 15px;
    }

    .summary-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 12px;
      color: var(--muted);
    }

    .summary-meta strong {
      font-weight: 600;
      color: var(--text);
    }

    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 14px;
    }

    .kv div:nth-child(odd) {
      color: var(--muted);
    }

    .muted {
      color: var(--muted);
    }

    .moves {
      display: grid;
      grid-template-columns: 40px 1fr 1fr;
      gap: 6px 12px;
      font-size: 14px;
    }

    .mv {
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
      background: rgba(148, 163, 184, 0.12);
      transition: background 0.12s ease, transform 0.12s ease;
      position: relative;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .mv:hover {
      background: rgba(56, 189, 248, 0.18);
    }

    .mv.active {
      background: rgba(56, 189, 248, 0.28);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.4);
    }

    .eval {
      position: absolute;
      top: -12px;
      right: 2px;
      font-size: 10px;
      font-weight: 600;
      color: var(--accent);
      background: rgba(15, 23, 42, 0.75);
      padding: 1px 3px;
      border-radius: 3px;
      white-space: nowrap;
      opacity: 0.85;
    }

    .classification-icon {
      width: 18px;
      height: 18px;
      object-fit: contain;
      filter: drop-shadow(0 0 2px rgba(15, 23, 42, 0.5));
    }

    .pv-list {
      display: grid;
      gap: 8px;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 13px;
    }

    .pv {
      display: grid;
      grid-template-columns: 26px auto auto;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(148, 163, 184, 0.12);
    }

    .pv:nth-child(1) {
      background: rgba(34, 197, 94, 0.15);
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.35);
    }

    .pv:nth-child(2) {
      background: rgba(56, 189, 248, 0.15);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.35);
    }

    .pv:nth-child(3) {
      background: rgba(250, 204, 21, 0.18);
      box-shadow: 0 0 0 1px rgba(250, 204, 21, 0.35);
    }

    .pv .rank {
      font-weight: 700;
    }

    .pv .move {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .pv .eval {
      color: var(--muted);
      position: static;
      background: transparent;
      padding: 0;
      font-size: 12px;
    }

    .suggestions-header {
      margin-top: 22px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .suggestions-header h2 {
      flex: 1;
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .suggestion-mode-label {
      display: inline-flex;
      align-items: center;
      padding: 2px 8px;
      margin-left: 8px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.18);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }

    .mono {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
    }

    @media (max-width: 860px) {
      body {
        padding: 16px;
      }

      .board-area {
        flex-direction: row;
        justify-content: center;
      }

      #board {
        max-width: 360px;
      }
    }

    @media (max-width: 720px) {
      .board-area {
        flex-direction: column;
        align-items: center;
      }

      .eval-column {
        flex-direction: row;
        width: 100%;
        justify-content: center;
      }

      .eval-vertical {
        width: 18px;
        min-height: 180px;
      }

      .material-panel {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1>Lichess PGN Analyzer</h1>
    <button id="themeToggle" class="secondary" style="padding: 8px 12px; font-size: 14px;">🌙 Dark</button>
  </div>
  <div class="layout">
    <div class="card">
      <h2>Load game</h2>
      <div class="row input-controls">
        <select id="inputMode">
          <option value="pgn">PGN</option>
          <option value="lichess">Lichess URL / ID</option>
          <option value="fen">FEN</option>
        </select>
        <button id="loadBtn">Load</button>
      </div>
      <div class="row">
        <textarea id="gameInput" rows="8" placeholder="Paste PGN text" autocomplete="off" spellcheck="false"
          class="mono"></textarea>
      </div>
      <div class="row">
        <label id="inputHint" class="hint">Paste the full PGN for the game you want to analyze.</label>
      </div>
      <div id="loadStatus" class="status"></div>

      <h2>Board</h2>
      <div class="board-area">
        <div class="board-wrap">
          <div id="board"></div>
          <svg id="arrowLayer" viewBox="0 0 800 800" preserveAspectRatio="none"></svg>
          <div class="board-badge-layer">
            <div id="boardMoveBadge" class="board-move-badge" aria-hidden="true">
              <img id="boardMoveBadgeIcon" class="board-move-badge-icon" alt="" />
            </div>
          </div>
        </div>
        <div class="eval-column">
          <div class="eval-label" id="evalWhiteValue">0.00</div>
          <div class="eval-vertical">
            <div class="eval-fill" id="evalFill"></div>
            <div class="eval-marker" id="evalMarker"></div>
          </div>
          <div class="eval-label eval-label-black" id="evalBlackValue">0.00</div>
        </div>
      </div>
      <div class="material-panel">
        <div class="material-card">
          <div class="material-player">White</div>
          <div class="material-score" id="materialWhite">0</div>
          <div class="material-capture" id="materialWhiteCapture">—</div>
        </div>
        <div class="material-card">
          <div class="material-player">Black</div>
          <div class="material-score" id="materialBlack">0</div>
          <div class="material-capture" id="materialBlackCapture">—</div>
        </div>
      </div>

      <div class="row" style="margin-top:14px; align-items:center;">
        <button id="firstBtn" class="secondary">⏮ First</button>
        <button id="prevBtn" class="secondary">◀ Prev</button>
        <button id="nextBtn">Next ▶</button>
        <button id="lastBtn">Last ⏭</button>
        <button id="flipBtn" class="secondary">Flip</button>
      </div>
      <div id="navStatus" class="status"></div>
    </div>

    <div class="card">
      <h2>Game info</h2>
      <div class="kv" id="tagBox">
        <div>White</div>
        <div id="tagWhite">—</div>
        <div>Black</div>
        <div id="tagBlack">—</div>
        <div>Event</div>
        <div id="tagEvent">—</div>
        <div>Site</div>
        <div id="tagSite">—</div>
        <div>Date</div>
        <div id="tagDate">—</div>
        <div>Result</div>
        <div id="tagResult">—</div>
        <div>Opening</div>
        <div id="tagOpening">—</div>
      </div>

      <h2 style="margin-top:22px;">Elo estimates</h2>
      <div class="kv">
        <div>White</div>
        <div id="eloWhite">—</div>
        <div>Black</div>
        <div id="eloBlack">—</div>
      </div>

      <h2 style="margin-top:22px;">Move summary</h2>
      <div class="summary-scroll">
        <div id="moveSummaryTable" class="summary-table"></div>
      </div>

      <div class="suggestions-header">
        <h2>Engine suggestions <span id="suggestionModeLabel" class="suggestion-mode-label">Played move review</span> <span style="font-size:12px; font-weight:400; color:var(--muted);">(eval ± rating change vs best)</span></h2>
        <button id="suggestionToggle" class="secondary">Show next move advice</button>
      </div>
      <div class="pv-list">
        <div class="pv"><span class="rank">1</span><span class="move" id="pv1">—</span><span class="eval"
            id="ev1"></span></div>
        <div class="pv"><span class="rank">2</span><span class="move" id="pv2">—</span><span class="eval"
            id="ev2"></span></div>
        <div class="pv"><span class="rank">3</span><span class="move" id="pv3">—</span><span class="eval"
            id="ev3"></span></div>
        <div id="engStatus" class="status"></div>
      </div>

      <h2 style="margin-top:22px;">Moves</h2>
      <div id="moves" class="moves"></div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  
  <script type="module">
    import { Chess } from './chess.js';
    (function () {
      const byId = (id) => document.getElementById(id);
      const encoder = new TextEncoder();
      const decoder = new TextDecoder();

      const state = {
        board: null,
        orientation: 'white',
        game: new Chess(),
        verboseHistory: [],
        ply: 0,
        engine: null,
        engineReady: false,
        engineConfigured: false,
        engineVersion: 'unknown',
        initialFen: 'start',
        initialPieceCounts: null,
        source: 'pgn',
        rawInput: '',
        analysisCache: new Map(),
        analysisStatus: 'idle',
        engineQueue: [],
        currentRequest: null,
        analysisToken: 0,
        suggestionMode: 'played',
        badgeRaf: null
      };

      const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      const pieceOrder = ['q', 'r', 'b', 'n', 'p'];
      const pieceLabels = { p: 'P', n: 'N', b: 'B', r: 'R', q: 'Q' };
      const inputHints = {
        pgn: 'Paste the full PGN for the game you want to analyze.',
        lichess: 'Paste a public Lichess game URL or ID. For best results run this page from http://localhost/.',
        fen: 'Paste a FEN string to analyze a specific position.'
      };
      const suggestionModeOptions = {
        played: {
          label: 'Played move review',
          button: 'Show next move advice',
          title: 'Switch to next-move advice'
        },
        next: {
          label: 'Next move advice',
          button: 'Show move review',
          title: 'Switch to played-move review'
        }
      };
      const classificationIconSet = new Set(['best', 'excellent', 'good', 'inaccuracy', 'mistake', 'blunder', 'brilliant', 'great', 'miss', 'book']);
      const moveSummaryCategories = [
        { key: 'brilliant', label: 'Brilliant', icon: './move-classifications/brilliant.png' },
        { key: 'great', label: 'Great', icon: './move-classifications/great.png' },
        { key: 'best', label: 'Best', icon: './move-classifications/best.png' },
        { key: 'excellent', label: 'Excellent', icon: './move-classifications/excellent.png' },
        { key: 'good', label: 'Good', icon: './move-classifications/good.png' },
        { key: 'inaccuracy', label: 'Inaccuracy', icon: './move-classifications/inaccuracy.png' },
        { key: 'mistake', label: 'Mistake', icon: './move-classifications/mistake.png' },
        { key: 'blunder', label: 'Blunder', icon: './move-classifications/blunder.png' },
        { key: 'miss', label: 'Miss', icon: './move-classifications/miss.png' }
      ];

      function initMoveSummary() {
        const table = byId('moveSummaryTable');
        if (!table) return;
        table.innerHTML = '';
        const columnTemplate = `minmax(150px, 1.3fr) repeat(${moveSummaryCategories.length}, minmax(60px, 1fr))`;

        const headerRow = document.createElement('div');
        headerRow.className = 'summary-row summary-header';
        headerRow.style.gridTemplateColumns = columnTemplate;
        const playerHeader = document.createElement('div');
        playerHeader.className = 'summary-player-cell';
        playerHeader.textContent = 'Player';
        headerRow.appendChild(playerHeader);
        moveSummaryCategories.forEach((category) => {
          const cell = document.createElement('div');
          cell.className = 'summary-cell summary-cell-header';
          if (category.icon) {
            const icon = document.createElement('img');
            icon.src = category.icon;
            icon.alt = category.label;
            icon.className = 'summary-icon';
            cell.appendChild(icon);
          }
          const label = document.createElement('span');
          label.textContent = category.label;
          cell.appendChild(label);
          headerRow.appendChild(cell);
        });
        table.appendChild(headerRow);

        const players = [
          { name: 'White', color: 'w' },
          { name: 'Black', color: 'b' }
        ];
        players.forEach((player) => {
          const row = document.createElement('div');
          row.className = 'summary-row';
          row.dataset.color = player.color;
          row.style.gridTemplateColumns = columnTemplate;

          const playerCell = document.createElement('div');
          playerCell.className = 'summary-player-cell';
          const playerName = document.createElement('div');
          playerName.className = 'summary-player-name';
          playerName.textContent = player.name;
          playerCell.appendChild(playerName);

          const meta = document.createElement('div');
          meta.className = 'summary-meta';

          const accuracySpan = document.createElement('span');
          accuracySpan.textContent = 'Accuracy ';
          const accuracyValue = document.createElement('strong');
          accuracyValue.dataset.role = 'accuracy';
          accuracyValue.textContent = '—';
          accuracySpan.appendChild(accuracyValue);
          meta.appendChild(accuracySpan);

          const cpLossSpan = document.createElement('span');
          cpLossSpan.textContent = 'Avg CPL ';
          const cpLossValue = document.createElement('strong');
          cpLossValue.dataset.role = 'cpLoss';
          cpLossValue.textContent = '—';
          cpLossSpan.appendChild(cpLossValue);
          meta.appendChild(cpLossSpan);

          playerCell.appendChild(meta);
          row.appendChild(playerCell);

          moveSummaryCategories.forEach((category) => {
            const cell = document.createElement('div');
            cell.className = 'summary-cell';
            cell.dataset.key = category.key;
            cell.textContent = '—';
            row.appendChild(cell);
          });

          table.appendChild(row);
        });
      }

      function createSummaryBucket() {
        const counts = {};
        moveSummaryCategories.forEach((category) => {
          counts[category.key] = 0;
        });
        return {
          counts,
          moves: 0,
          analyzedMoves: 0,
          accuracySum: 0,
          accuracyCount: 0,
          cpLossSum: 0,
          cpLossCount: 0
        };
      }

      function computeCpLoss(bestCp, actualCp, color) {
        if (!Number.isFinite(bestCp) || !Number.isFinite(actualCp)) return null;
        const clamp = (cp) => Math.max(-1000, Math.min(1000, cp));
        const best = clamp(bestCp);
        const actual = clamp(actualCp);
        if (color === 'b') {
          return Math.max(0, actual - best);
        }
        return Math.max(0, best - actual);
      }

      function computeMoveSummary() {
        const summary = {
          w: createSummaryBucket(),
          b: createSummaryBucket()
        };
        state.verboseHistory.forEach((entry) => {
          if (!entry) return;
          const color = entry.color === 'b' ? 'b' : 'w';
          const bucket = summary[color];
          bucket.moves++;
          if (!entry.analysis) return;
          bucket.analyzedMoves++;
          const classification = entry.analysis.classification;
          if (classification && Object.prototype.hasOwnProperty.call(bucket.counts, classification)) {
            bucket.counts[classification] += 1;
          }
          const moveAccuracy = entry.analysis.accuracy;
          if (Number.isFinite(moveAccuracy)) {
            bucket.accuracySum += moveAccuracy;
            bucket.accuracyCount++;
          }
          const cpLoss = entry.analysis.cpLoss;
          if (Number.isFinite(cpLoss)) {
            bucket.cpLossSum += cpLoss;
            bucket.cpLossCount++;
          }
        });
        return summary;
      }

      function updateMoveSummary() {
        const table = byId('moveSummaryTable');
        if (!table) return;
        const summary = computeMoveSummary();
        ['w', 'b'].forEach((color) => {
          const row = table.querySelector(`.summary-row[data-color="${color}"]`);
          if (!row) return;
          const bucket = summary[color];
          const hasAnalysis = bucket.analyzedMoves > 0;
          moveSummaryCategories.forEach((category) => {
            const cell = row.querySelector(`.summary-cell[data-key="${category.key}"]`);
            if (!cell) return;
            if (!hasAnalysis) {
              cell.textContent = '—';
            } else {
              cell.textContent = bucket.counts[category.key] || 0;
            }
          });

          const accuracyEl = row.querySelector('[data-role="accuracy"]');
          if (accuracyEl) {
            if (bucket.accuracyCount > 0) {
              const avgAccuracy = bucket.accuracySum / bucket.accuracyCount;
              accuracyEl.textContent = `${avgAccuracy.toFixed(1)}%`;
            } else {
              accuracyEl.textContent = '—';
            }
          }

          const cpLossEl = row.querySelector('[data-role="cpLoss"]');
          if (cpLossEl) {
            if (bucket.cpLossCount > 0) {
              const avgCpLoss = bucket.cpLossSum / bucket.cpLossCount;
              const formatted = Math.abs(avgCpLoss) < 1 ? avgCpLoss.toFixed(1) : avgCpLoss.toFixed(0);
              cpLossEl.textContent = formatted;
            } else {
              cpLossEl.textContent = '—';
            }
          }
        });
      }

      function createBaseGame(fen = state.initialFen) {
        if (fen && fen !== 'start') {
          return new Chess(fen);
        }
        return new Chess();
      }

      function effectiveInitialFen() {
        return state.initialFen && state.initialFen !== 'start'
          ? state.initialFen
          : createBaseGame().fen();
      }

      function countPiecesOnBoard(boardMatrix) {
        const counts = {
          w: { p: 0, n: 0, b: 0, r: 0, q: 0, k: 0 },
          b: { p: 0, n: 0, b: 0, r: 0, q: 0, k: 0 }
        };
        for (const row of boardMatrix) {
          for (const piece of row) {
            if (!piece) continue;
            counts[piece.color][piece.type]++;
          }
        }
        return counts;
      }

      function initializePieceCounts() {
        const baseGame = createBaseGame();
        state.initialPieceCounts = countPiecesOnBoard(baseGame.board());
      }

      function setBoardPosition(fen) {
        if (!state.board) return;
        if (!fen || fen === 'start') {
          state.board.position('start');
        } else {
          state.board.position(fen);
        }
        scheduleBoardBadgeUpdate();
      }

      function updateBoardClassificationBadge() {
        const badge = byId('boardMoveBadge');
        const icon = byId('boardMoveBadgeIcon');
        const boardEl = byId('board');
        if (!badge || !icon || !boardEl) return;

        badge.style.display = 'none';
        badge.removeAttribute('data-classification');
        icon.removeAttribute('src');
        icon.alt = '';

        if (state.ply === 0) {
          return;
        }

        const entry = state.verboseHistory[state.ply - 1];
        if (!entry || !entry.analysis || !entry.analysis.classification || !entry.to) {
          return;
        }

        const iconPath = classificationToIcon(entry.analysis.classification);
        if (!iconPath) {
          return;
        }

        const squareEl = boardEl.querySelector(`[data-square="${entry.to}"]`);
        if (!squareEl) {
          return;
        }

        const boardRect = boardEl.getBoundingClientRect();
        const squareRect = squareEl.getBoundingClientRect();
        const left = squareRect.left - boardRect.left + squareRect.width / 2;
        const top = squareRect.top - boardRect.top + squareRect.height / 2;

        const normalizedClass = entry.analysis.classification.toLowerCase().replace(/\s+/g, '-');
        badge.style.left = `${left}px`;
        badge.style.top = `${top}px`;
        badge.setAttribute('data-classification', normalizedClass);
        icon.src = iconPath;
        icon.alt = entry.analysis.classification;
        badge.style.display = 'flex';
      }

      function scheduleBoardBadgeUpdate() {
        if (state.badgeRaf != null) {
          cancelAnimationFrame(state.badgeRaf);
        }
        state.badgeRaf = requestAnimationFrame(() => {
          state.badgeRaf = null;
          updateBoardClassificationBadge();
        });
      }

      function formatMaterialScore(score) {
        if (score === 0) return '0';
        return score > 0 ? `+${score}` : `${score}`;
      }

      function sumMaterial(counts) {
        return (
          pieceValues.p * counts.p +
          pieceValues.n * counts.n +
          pieceValues.b * counts.b +
          pieceValues.r * counts.r +
          pieceValues.q * counts.q
        );
      }

      function findTopCapture(initialCounts, currentCounts) {
        if (!initialCounts || !currentCounts) return null;
        for (const type of pieceOrder) {
          const missing = (initialCounts[type] || 0) - (currentCounts[type] || 0);
          if (missing > 0) {
            const value = pieceValues[type];
            return `${pieceLabels[type]} (+${value})`;
          }
        }
        return null;
      }

      function updateMaterialDiff() {
        if (!state.game || !state.initialPieceCounts) return;
        const counts = countPiecesOnBoard(state.game.board());
        const whiteTotal = sumMaterial(counts.w);
        const blackTotal = sumMaterial(counts.b);
        const diff = whiteTotal - blackTotal;

        const whiteScoreEl = byId('materialWhite');
        const blackScoreEl = byId('materialBlack');
        if (whiteScoreEl) {
          whiteScoreEl.textContent = formatMaterialScore(diff);
          whiteScoreEl.classList.toggle('positive', diff > 0);
          whiteScoreEl.classList.toggle('negative', diff < 0);
        }
        if (blackScoreEl) {
          const blackScore = -diff;
          blackScoreEl.textContent = formatMaterialScore(blackScore);
          blackScoreEl.classList.toggle('positive', blackScore > 0);
          blackScoreEl.classList.toggle('negative', blackScore < 0);
        }

        const whiteCaptureEl = byId('materialWhiteCapture');
        const blackCaptureEl = byId('materialBlackCapture');
        if (whiteCaptureEl) {
          const capture = findTopCapture(state.initialPieceCounts.b, counts.b);
          whiteCaptureEl.textContent = capture ? `Top capture: ${capture}` : '—';
        }
        if (blackCaptureEl) {
          const capture = findTopCapture(state.initialPieceCounts.w, counts.w);
          blackCaptureEl.textContent = capture ? `Top capture: ${capture}` : '—';
        }
      }

      function encodeStateValue(value) {
        try {
          const bytes = encoder.encode(value);
          let binary = '';
          bytes.forEach((b) => { binary += String.fromCharCode(b); });
          return btoa(binary);
        } catch (err) {
          console.error('Failed to encode state', err);
          return '';
        }
      }

      function decodeStateValue(value) {
        try {
          const binary = atob(value);
          const bytes = Uint8Array.from(binary, (c) => c.charCodeAt(0));
          return decoder.decode(bytes);
        } catch (err) {
          console.error('Failed to decode state', err);
          return '';
        }
      }

      function updateUrlState() {
        const url = new URL(window.location);
        if (state.source) {
          url.searchParams.set('source', state.source);
        } else {
          url.searchParams.delete('source');
        }

        if (state.rawInput) {
          const encoded = encodeStateValue(state.rawInput);
          if (encoded) {
            url.searchParams.set('data', encoded);
          }
        } else {
          url.searchParams.delete('data');
        }

        if (state.ply > 0) {
          url.searchParams.set('ply', String(state.ply));
        } else {
          url.searchParams.delete('ply');
        }

        url.searchParams.delete('game');
        window.history.replaceState({}, '', url);
      }

      function setInputMode(mode) {
        const select = byId('inputMode');
        if (select && select.value !== mode) {
          select.value = mode;
        }
        updateInputModeUI(mode);
      }

      function updateInputModeUI(mode) {
        const input = byId('gameInput');
        const hint = byId('inputHint');
        if (!input) return;

        if (mode === 'lichess') {
          input.placeholder = 'https://lichess.org/abcdefg';
          input.rows = 2;
          input.classList.remove('mono');
        } else if (mode === 'fen') {
          input.placeholder = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
          input.rows = 3;
          input.classList.add('mono');
        } else {
          input.placeholder = 'Paste PGN text';
          input.rows = 8;
          input.classList.add('mono');
        }

        input.spellcheck = false;
        input.autocomplete = 'off';

        if (hint) {
          hint.textContent = inputHints[mode] || '';
        }
      }

      function getSavedSuggestionMode() {
        if (typeof localStorage === 'undefined') {
          return 'played';
        }
        try {
          const saved = localStorage.getItem('suggestionMode');
          return saved === 'next' ? 'next' : 'played';
        } catch (err) {
          return 'played';
        }
      }

      function updateSuggestionModeUI() {
        const label = byId('suggestionModeLabel');
        const button = byId('suggestionToggle');
        const config = suggestionModeOptions[state.suggestionMode] || suggestionModeOptions.played;
        if (label) {
          label.textContent = config.label;
        }
        if (button) {
          button.textContent = config.button;
          button.title = config.title;
          button.setAttribute('aria-pressed', state.suggestionMode === 'next' ? 'true' : 'false');
        }
      }

      function setSuggestionMode(mode) {
        const nextMode = suggestionModeOptions[mode] ? mode : 'played';
        state.suggestionMode = nextMode;
        updateSuggestionModeUI();
        try {
          if (typeof localStorage !== 'undefined') {
            localStorage.setItem('suggestionMode', nextMode);
          }
        } catch (err) {
          // ignore storage errors
        }
        applyAnalysisForCurrentPly();
      }

      function toggleSuggestionMode() {
        const nextMode = state.suggestionMode === 'next' ? 'played' : 'next';
        setSuggestionMode(nextMode);
      }

      function initSuggestionMode() {
        state.suggestionMode = getSavedSuggestionMode();
        updateSuggestionModeUI();
      }

      function initBoard() {
        state.board = Chessboard('board', {
          position: 'start',
          draggable: false,
          pieceTheme: 'chesspieces/wikipedia/{piece}.png'
        });
        syncArrowLayer();
        window.addEventListener('resize', () => {
          state.board.resize();
          syncArrowLayer();
          scheduleBoardBadgeUpdate();
        });
      }

      function syncArrowLayer() {
        const boardEl = byId('board');
        const svg = byId('arrowLayer');
        const rect = boardEl.getBoundingClientRect();
        svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.width}`);
        svg.setAttribute('width', rect.width);
        svg.setAttribute('height', rect.width);
      }

      function setStatus(id, msg, type) {
        const el = byId(id);
        if (!el) return;
        el.textContent = msg || '';
        el.classList.remove('error', 'ok');
        if (type === 'error') el.classList.add('error');
        if (type === 'ok') el.classList.add('ok');
      }

      function extractGameId(input) {
        if (!input) return '';
        try {
          const url = new URL(input.trim());
          return url.pathname.split('/').filter(Boolean)[0] || '';
        } catch (e) {
          return input.trim();
        }
      }

      async function fetchPGN(input) {
        const id = extractGameId(input);
        if (!id) throw new Error('Please provide a Lichess URL or game ID.');
        const params = new URLSearchParams({
          moves: '1',
          tags: '1',
          clocks: '1',
          opening: '1',
          evals: '0',
          literate: '0'
        });
        const headers = { Accept: 'application/x-chess-pgn' };
        const res = await fetch(`https://lichess.org/game/export/${id}.pgn?${params.toString()}`, { headers });
        if (!res.ok) throw new Error(`HTTP ${res.status} – ${res.statusText}`);
        return res.text();
      }

      function populateHeaders(headers) {
        byId('tagWhite').textContent = headers.White || '—';
        byId('tagBlack').textContent = headers.Black || '—';
        byId('tagEvent').textContent = headers.Event || '—';
        byId('tagSite').textContent = headers.Site || '—';
        byId('tagDate').textContent = headers.Date || '—';
        byId('tagResult').textContent = headers.Result || '—';
        byId('tagOpening').textContent = headers.Opening || headers.ECO || '—';
      }

      function parseHeaders(pgn) {
        const out = {};
        const regex = /\[(\w+)\s+"([^"]*)"\]/g;
        let match;
        while ((match = regex.exec(pgn)) !== null) {
          out[match[1]] = match[2];
        }
        return out;
      }

      function buildHistory(game, initialFen) {
        const verbose = [];
        const temp = initialFen && initialFen !== 'start' ? new Chess(initialFen) : new Chess();
        const moves = game.history();
        for (const mv of moves) {
          const preFen = temp.fen();
          const played = temp.move(mv);
          if (played) {
            verbose.push({ ...played, fen: temp.fen(), preFen, eval: null, analysis: null });
          }
        }
        return verbose;
      }

      function classificationToIcon(classification) {
        if (!classification) return null;
        const file = classification.toLowerCase().replace(/\s+/g, '-');
        return classificationIconSet.has(file) ? `./move-classifications/${file}.png` : null;
      }

      function createMoveCell(entry, plyIndex) {
        const cell = document.createElement('div');
        cell.className = 'mv';
        const label = document.createElement('span');
        label.textContent = entry ? entry.san : '';
        cell.appendChild(label);

        if (entry && entry.analysis && entry.analysis.classification) {
          const iconPath = classificationToIcon(entry.analysis.classification);
          if (iconPath) {
            const icon = document.createElement('img');
            icon.src = iconPath;
            icon.alt = entry.analysis.classification;
            icon.className = 'classification-icon';
            cell.appendChild(icon);
          }
        }

        const evalBadge = document.createElement('div');
        evalBadge.className = 'eval';
        evalBadge.textContent = entry && entry.eval ? entry.eval : '';
        cell.appendChild(evalBadge);

        cell.addEventListener('click', () => goToPly(plyIndex));
        return cell;
      }

      function renderMoves() {
        const container = byId('moves');
        if (!container) return;
        container.innerHTML = '';
        const h = state.verboseHistory;
        for (let i = 0; i < h.length; i += 2) {
          const moveNo = document.createElement('div');
          moveNo.textContent = `${Math.floor(i / 2) + 1}.`;
          moveNo.className = 'muted';

          const white = createMoveCell(h[i], i + 1);
          const black = createMoveCell(h[i + 1], i + 2);

          container.appendChild(moveNo);
          container.appendChild(white);
          container.appendChild(black);
        }
        highlightActive();
        updateMoveSummary();
      }

      function highlightActive() {
        Array.from(document.querySelectorAll('.mv')).forEach((el) => el.classList.remove('active'));
        const idx = state.ply - 1;
        if (idx < 0) return;
        const row = Math.floor(idx / 2);
        const col = idx % 2;
        const container = byId('moves');
        if (!container) return;
        const cell = container.children[row * 3 + 1 + col];
        if (cell) cell.classList.add('active');
      }

      function goToPly(ply) {
        const max = state.verboseHistory.length;
        state.ply = Math.max(0, Math.min(max, ply));
        const baseGame = createBaseGame();
        state.game = baseGame;

        if (state.ply === 0) {
          setBoardPosition(state.initialFen);
        } else {
          for (let i = 0; i < state.ply; i++) {
            const mv = state.verboseHistory[i];
            state.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion });
          }
          const fen = state.verboseHistory[state.ply - 1].fen;
          setBoardPosition(fen);
        }

        highlightActive();
        updateMaterialDiff();
        applyAnalysisForCurrentPly();

        setStatus('navStatus', `Move ${state.ply} / ${max}`);
        updateUrlState();
      }

      function drawArrows(list) {
        const svg = byId('arrowLayer');
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
        <marker id="m1" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="5" markerHeight="5" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z" fill="#22c55e" />
        </marker>
        <marker id="m2" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="5" markerHeight="5" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z" fill="#38bdf8" />
        </marker>
        <marker id="m3" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="5" markerHeight="5" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z" fill="#f87171" />
        </marker>`;
        svg.appendChild(defs);
        if (!list || !list.length) return;
        const boardRect = byId('board').getBoundingClientRect();
        const squareSize = boardRect.width / 8;
        function squareCenter(sq) {
          const file = sq.charCodeAt(0) - 97;
          const rank = parseInt(sq[1], 10) - 1;
          if (state.orientation === 'white') {
            return {
              x: (file + 0.5) * squareSize,
              y: ((7 - rank) + 0.5) * squareSize
            };
          }
          return {
            x: ((7 - file) + 0.5) * squareSize,
            y: (rank + 0.5) * squareSize
          };
        }
        const colors = ['#22c55e', '#38bdf8', '#f87171'];
        const opacities = [1.0, 0.25, 0.25];
        list.forEach((entry, i) => {
          if (!entry || !entry.uci) return;
          const from = squareCenter(entry.uci.slice(0, 2));
          const to = squareCenter(entry.uci.slice(2, 4));
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const len = Math.hypot(dx, dy);
          if (!len) return;
          const shorten = Math.min(12, len * 0.15);
          const startOffset = Math.min(12, len * 0.1);
          const sx = from.x + (dx / len) * startOffset;
          const sy = from.y + (dy / len) * startOffset;
          const ex = to.x - (dx / len) * shorten;
          const ey = to.y - (dy / len) * shorten;
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', sx);
          line.setAttribute('y1', sy);
          line.setAttribute('x2', ex);
          line.setAttribute('y2', ey);
          line.setAttribute('stroke', colors[i] || colors[2]);
          line.setAttribute('stroke-width', Math.max(4, 6 - i * 0.8));
          line.setAttribute('stroke-linecap', 'round');
          line.setAttribute('marker-end', `url(#m${i + 1})`);
          line.setAttribute('opacity', opacities[i] || opacities[2]);
          svg.appendChild(line);
        });
      }

      function uciToSan(fen, uci) {
        try {
          const game = new Chess(fen);
          const move = {
            from: uci.slice(0, 2),
            to: uci.slice(2, 4),
            promotion: uci.length > 4 ? uci[4] : undefined
          };
          const played = game.move(move);
          return played && played.san ? played.san : uci;
        } catch (e) {
          return uci;
        }
      }

      function parseEvalString(evalStr) {
        if (!evalStr) return null;
        if (evalStr.startsWith('#')) {
          const mate = parseInt(evalStr.slice(1), 10);
          if (Number.isNaN(mate)) return null;
          return { type: 'mate', value: mate };
        }
        const pawns = parseFloat(evalStr);
        if (Number.isNaN(pawns)) return null;
        return { type: 'cp', pawns, cp: pawns * 100 };
      }

      function evalStringToCentipawns(evalStr) {
        const parsed = parseEvalString(evalStr);
        if (!parsed) return null;
        if (parsed.type === 'mate') {
          return parsed.value > 0 ? 10000 : -10000;
        }
        return parsed.cp;
      }

      function formatEval(pawns) {
        if (!Number.isFinite(pawns)) return '0.00';
        if (pawns === 0) return '0.00';
        return pawns > 0 ? `+${pawns.toFixed(2)}` : pawns.toFixed(2);
      }

      function updateEvalBar(evalStr) {
        const whiteEl = byId('evalWhiteValue');
        const blackEl = byId('evalBlackValue');
        const fillEl = byId('evalFill');
        const markerEl = byId('evalMarker');

        let normalized = 0.5;
        let whiteDisplay = '0.00';
        let blackDisplay = '0.00';

        if (evalStr) {
          const parsed = parseEvalString(evalStr);
          if (parsed) {
            if (parsed.type === 'mate') {
              const mate = parsed.value;
              if (mate > 0) {
                whiteDisplay = `M${mate}`;
                blackDisplay = '—';
                normalized = 0.98;
              } else if (mate < 0) {
                whiteDisplay = '—';
                blackDisplay = `M${Math.abs(mate)}`;
                normalized = 0.02;
              }
            } else {
              const pawns = parsed.pawns;
              whiteDisplay = formatEval(pawns);
              blackDisplay = formatEval(-pawns);
              const cp = parsed.cp;
              const clamped = Math.max(-800, Math.min(800, cp));
              normalized = 0.5 + Math.tanh(clamped / 200) / 2;
            }
          }
        }

        if (whiteEl) whiteEl.textContent = whiteDisplay;
        if (blackEl) blackEl.textContent = blackDisplay;
        const percentage = Math.min(0.98, Math.max(0.02, normalized));
        if (fillEl) fillEl.style.height = `${(percentage * 100).toFixed(1)}%`;
        if (markerEl) markerEl.style.top = `${(percentage * 100).toFixed(1)}%`;
      }

      function updatePVDisplay(entries) {
        const ids = [1, 2, 3];
        const bestEval = entries[0] && entries[0].eval ? parseFloat(entries[0].eval) || 0 : 0;

        ids.forEach((idx, i) => {
          const moveEl = byId(`pv${idx}`);
          const evalEl = byId(`ev${idx}`);
          const entry = entries[i] || null;
          if (entry) {
            moveEl.textContent = entry.san || entry.uci;
            let evalText = entry.eval || '';
            const moveEval = parseFloat(entry.eval) || 0;
            const ratingChange = (moveEval - bestEval) * 100;
            if (!Number.isNaN(ratingChange) && Math.abs(ratingChange) > 1) {
              const sign = ratingChange > 0 ? '+' : '';
              evalText = `${entry.eval} (${sign}${ratingChange.toFixed(0)})`;
            }
            evalEl.textContent = evalText;
          } else {
            moveEl.textContent = '—';
            evalEl.textContent = '';
          }
        });

        updateEvalBar(entries[0] && entries[0].eval ? entries[0].eval : null);
      }

      function estimateEloFromHistory(history) {
        if (!history || history.length === 0) {
          return { white: null, black: null };
        }
        const stats = {
          white: { moves: 0, swingSum: 0, mistakes: 0 },
          black: { moves: 0, swingSum: 0, mistakes: 0 }
        };
        const evals = history.map((entry) => evalStringToCentipawns(entry.eval));
        let prev = null;
        for (let i = 0; i < evals.length; i++) {
          const current = evals[i];
          if (current == null) continue;
          if (prev != null) {
            const color = i % 2 === 0 ? 'white' : 'black';
            const swing = current - prev;
            stats[color].moves++;
            stats[color].swingSum += Math.abs(swing);
            if (color === 'white' && swing < -150) stats[color].mistakes++;
            if (color === 'black' && swing > 150) stats[color].mistakes++;
          }
          prev = current;
        }
        const compute = (stat) => {
          if (stat.moves < 3) return null;
          const avgSwing = stat.swingSum / stat.moves;
          const stability = Math.max(0, 220 - Math.min(220, avgSwing));
          const base = 900 + Math.min(stat.moves, 60) * 6;
          const rating = base + stability * 1.4 - stat.mistakes * 40;
          return Math.max(700, Math.min(2800, rating));
        };
        return { white: compute(stats.white), black: compute(stats.black) };
      }

      function updateEloEstimates() {
        const estimates = estimateEloFromHistory(state.verboseHistory);
        const whiteEl = byId('eloWhite');
        const blackEl = byId('eloBlack');
        if (whiteEl) {
          whiteEl.textContent = Number.isFinite(estimates.white) ? Math.round(estimates.white) : '—';
        }
        if (blackEl) {
          blackEl.textContent = Number.isFinite(estimates.black) ? Math.round(estimates.black) : '—';
        }
      }

      function centipawnsToWinPercent(cp) {
        if (cp == null || Number.isNaN(cp)) return null;
        const capped = Math.max(-1000, Math.min(1000, cp));
        const expTerm = Math.exp(-0.00368208 * capped);
        const ratio = 2 / (1 + expTerm) - 1;
        const winPercent = 50 + 50 * ratio;
        return Math.max(0, Math.min(100, winPercent));
      }

      function cpToExpectedPoints(cp) {
        const winPercent = centipawnsToWinPercent(cp);
        if (winPercent == null) return 0.5;
        return winPercent / 100;
      }

      function computeMoveAccuracy(winPercentBefore, winPercentAfter) {
        if (!Number.isFinite(winPercentBefore) || !Number.isFinite(winPercentAfter)) {
          return null;
        }
        const delta = winPercentBefore - winPercentAfter;
        const raw = 103.1668 * Math.exp(-0.04354 * delta) - 3.1669;
        return Math.max(0, Math.min(100, raw));
      }

      function detectSacrifice(moveEntry) {
        if (!moveEntry || !moveEntry.preFen || !moveEntry.fen) return false;
        try {
          const beforeGame = new Chess(moveEntry.preFen);
          const afterGame = new Chess(moveEntry.fen);
          const beforeCounts = countPiecesOnBoard(beforeGame.board());
          const afterCounts = countPiecesOnBoard(afterGame.board());
          const mover = moveEntry.color;
          const opponent = mover === 'w' ? 'b' : 'w';
          const beforeMaterial = sumMaterial(beforeCounts[mover]);
          const afterMaterial = sumMaterial(afterCounts[mover]);
          const beforeOpponent = sumMaterial(beforeCounts[opponent]);
          const afterOpponent = sumMaterial(afterCounts[opponent]);
          const materialLost = beforeMaterial - afterMaterial;
          const materialTaken = beforeOpponent - afterOpponent;
          return materialLost >= 3 && materialTaken <= 1;
        } catch (err) {
          console.warn('Failed to evaluate sacrifice', err);
          return false;
        }
      }

      function classifyMoveContext({
        bestEp,
        actualEp,
        beforeEp,
        moveEntry,
        bestEntry,
        actualEntry,
        winPercentBefore,
        winPercentAfter,
        pvEntries
      }) {
        const safeBefore = Number.isFinite(beforeEp) ? beforeEp : null;
        const sameAsBest = Boolean(bestEntry && actualEntry && bestEntry.uci === actualEntry.uci);
        const loss = Math.max(0, bestEp - actualEp);
        let classification;
        if (loss < 0.0005 && sameAsBest) {
          classification = 'best';
        } else if (loss <= 0.02) {
          classification = sameAsBest ? 'best' : 'excellent';
        } else if (loss <= 0.05) {
          classification = 'good';
        } else if (loss <= 0.1) {
          classification = 'inaccuracy';
        } else if (loss <= 0.2) {
          classification = 'mistake';
        } else {
          classification = 'blunder';
        }

        const baseline = classification;
        const winBefore = Number.isFinite(winPercentBefore) ? winPercentBefore : null;
        const winAfter = Number.isFinite(winPercentAfter) ? winPercentAfter : null;
        const winDelta = winBefore != null && winAfter != null ? winAfter - winBefore : null;

        let secondBestWin = null;
        if (pvEntries && pvEntries.length) {
          const secondEntry = pvEntries.find((entry) => entry.rank === 2);
          if (secondEntry) {
            const secondCp = evalStringToCentipawns(secondEntry.eval);
            const win = centipawnsToWinPercent(secondCp);
            if (Number.isFinite(win)) {
              secondBestWin = win;
            }
          }
        }

        let greatCandidate = false;
        if ((baseline === 'best' || baseline === 'excellent' || baseline === 'good') && winBefore != null && winAfter != null) {
          const savedFromLosing = winBefore < 35 && winAfter >= 45 && winDelta >= 10;
          const convertedToWin = winBefore >= 35 && winBefore <= 60 && winAfter >= 65 && winDelta >= 10;
          const onlyMove = sameAsBest && secondBestWin != null && winAfter - secondBestWin >= 12;
          if (savedFromLosing || convertedToWin || onlyMove) {
            greatCandidate = true;
          }
        }

        let brilliantCandidate = false;
        if ((baseline === 'best' || baseline === 'excellent') && detectSacrifice(moveEntry) && winAfter != null) {
          const notAlreadyWinning = !(winBefore != null && winBefore >= 80);
          const keepsPositionPlayable = winAfter >= 40;
          const maintainsStrength = winBefore == null || winAfter >= winBefore - 5;
          if (notAlreadyWinning && keepsPositionPlayable && maintainsStrength) {
            brilliantCandidate = true;
          }
        }

        let finalClassification = classification;
        if (brilliantCandidate) {
          finalClassification = 'brilliant';
        } else if (greatCandidate) {
          finalClassification = 'great';
        }

        if (safeBefore != null && safeBefore >= 0.65 && bestEp >= 0.85 && actualEp <= 0.55) {
          finalClassification = 'miss';
        }

        return { classification: finalClassification, expectedLoss: loss };
      }

      const engineController = {
        running: null,
        run(config) {
          return new Promise((resolve, reject) => {
            const request = {
              config: {
                fen: config.fen,
                depth: config.depth ?? 20,
                movetime: config.movetime ?? 2000,
                searchMoves: config.searchMoves ? [...config.searchMoves] : [],
                ply: config.ply ?? 0
              },
              resolve,
              reject,
              pv: new Map(),
              depth: 0
            };
            state.engineQueue.push(request);
            engineController.pump();
          });
        },
        pump() {
          if (!state.engineReady) return;
          if (engineController.running || state.engineQueue.length === 0) return;
          engineController.running = state.engineQueue.shift();
          state.currentRequest = engineController.running;
          state.engine.postMessage('stop');
          setTimeout(() => {
            if (!engineController.running) return;
            const { fen, depth, movetime, searchMoves } = engineController.running.config;
            state.engine.postMessage(`position fen ${fen}`);
            const goParts = ['go'];
            if (depth) {
              goParts.push('depth', String(depth));
            }
            if (movetime) {
              goParts.push('movetime', String(movetime));
            }
            if (searchMoves && searchMoves.length) {
              goParts.push('searchmoves', searchMoves.join(' '));
            }
            state.engine.postMessage(goParts.join(' '));
          }, 50);
        },
        handleInfo(line) {
          const req = engineController.running;
          if (!req) return;
          const depthMatch = line.match(/\bdepth (\d+)/);
          if (depthMatch) {
            const depthVal = parseInt(depthMatch[1], 10);
            if (Number.isFinite(depthVal)) {
              req.depth = depthVal;
            }
          }
          const multi = line.match(/\bmultipv (\d+)/);
          const pv = line.match(/\bpv ((?:[a-h][1-8]){2}[qrbn]?\b.*)/);
          if (!multi || !pv) return;
          const rank = parseInt(multi[1], 10);
          if (!Number.isFinite(rank) || rank < 1) return;
          const moves = pv[1].trim().split(/\s+/);
          if (!moves.length) return;
          let evalStr = '';
          const scoreMate = line.match(/\bscore mate (-?\d+)/);
          const scoreCp = line.match(/\bscore cp (-?\d+)/);
          if (scoreMate) {
            evalStr = `#${scoreMate[1]}`;
          } else if (scoreCp) {
            const cp = parseInt(scoreCp[1], 10);
            if (Number.isFinite(cp)) {
              evalStr = `${cp >= 0 ? '+' : ''}${(cp / 100).toFixed(2)}`;
            }
          }
          const entry = {
            rank,
            uci: moves[0],
            eval: evalStr
          };
          entry.san = uciToSan(req.config.fen, entry.uci);
          req.pv.set(rank, entry);
        },
        handleBestMove(line) {
          const req = engineController.running;
          if (!req) return;
          const entries = Array.from(req.pv.values())
            .sort((a, b) => a.rank - b.rank)
            .map((item) => ({ ...item }));
          req.resolve({
            entries,
            depth: req.depth,
            bestmove: line.split(/\s+/)[1] || null
          });
          engineController.running = null;
          state.currentRequest = null;
          engineController.pump();
        },
        reset() {
          if (engineController.running && typeof engineController.running.reject === 'function') {
            engineController.running.reject(new Error('Analysis cancelled'));
          }
          engineController.running = null;
          state.currentRequest = null;
          while (state.engineQueue.length) {
            const pending = state.engineQueue.shift();
            if (pending && typeof pending.reject === 'function') {
              pending.reject(new Error('Analysis cancelled'));
            }
          }
          if (state.engine && state.engineReady) {
            state.engine.postMessage('stop');
          }
        }
      };

      function ensureEngine() {
        if (state.engine) return;
        setStatus('engStatus', 'Loading engine…');
        let worker;
        let engineLabel = 'Stockfish';
        try {
          worker = new Worker('node_modules/stockfish/src/stockfish-17.1-lite-single-03e3232.js');
          engineLabel = 'Stockfish 17.1';
        } catch (e) {
          console.error('Failed to load Stockfish worker:', e);
          setStatus('engStatus', 'Failed to load Stockfish.', 'error');
          return;
        }
        if (!worker) {
          setStatus('engStatus', 'Failed to load Stockfish worker.', 'error');
          return;
        }
        state.engine = worker;
        state.engineReady = false;
        state.engineVersion = 'unknown';

        state.engine.onerror = (err) => {
          console.error('Stockfish worker error:', err);
          setStatus('engStatus', 'Engine error: ' + err.message, 'error');
        };

        state.engine.onmessage = (e) => {
          let line = typeof e.data === 'string' ? e.data : '';
          if (!line && e.data && typeof e.data === 'object') {
            line = e.data.data || e.data.text || '';
          }
          if (!line) return;

          if (line.startsWith('id name')) {
            state.engineVersion = line.substring(8).trim();
            engineLabel = state.engineVersion;
            return;
          }

          if (line.startsWith('uciok')) {
            state.engineReady = true;
            setStatus('engStatus', `Engine ready (${engineLabel})`, 'ok');
            if (!state.engineConfigured) {
              state.engine.postMessage('setoption name Threads value 1');
              state.engine.postMessage('setoption name MultiPV value 3');
              state.engineConfigured = true;
            }
            engineController.pump();
            if (state.analysisStatus === 'queued') {
              precomputeFullAnalysis();
            }
            return;
          }

          if (line.startsWith('info')) {
            engineController.handleInfo(line);
            return;
          }

          if (line.startsWith('bestmove')) {
            engineController.handleBestMove(line);
            return;
          }
        };

        state.engine.postMessage('uci');
      }

      function waitForEngineReady() {
        if (state.engineReady) return Promise.resolve();
        return new Promise((resolve) => {
          const check = () => {
            if (state.engineReady) {
              resolve();
            } else {
              setTimeout(check, 50);
            }
          };
          check();
        });
      }

      function nextAnalysisToken() {
        state.analysisToken = (state.analysisToken || 0) + 1;
        return state.analysisToken;
      }

      function resetAnalysisState() {
        nextAnalysisToken();
        state.analysisCache = new Map();
        state.analysisStatus = 'idle';
        engineController.reset();
      }

      function getAnalysisForCurrentView() {
        if (state.suggestionMode === 'next') {
          if (state.ply >= state.verboseHistory.length) {
            return null;
          }
          return state.analysisCache.get(state.ply + 1) || null;
        }
        return state.analysisCache.get(state.ply) || null;
      }

      function applyAnalysisForCurrentPly() {
        const analysis = getAnalysisForCurrentView();
        if (analysis) {
          drawArrows(analysis.pvEntries || []);
          updatePVDisplay(analysis.pvEntries || []);
          const evalText = state.suggestionMode === 'played'
            ? (analysis.actualEntry && analysis.actualEntry.eval
              ? analysis.actualEntry.eval
              : analysis.bestEntry && analysis.bestEntry.eval
                ? analysis.bestEntry.eval
                : null)
            : analysis.bestEntry && analysis.bestEntry.eval
              ? analysis.bestEntry.eval
              : null;
          updateEvalBar(evalText);
          setStatus('engStatus', `Precomputed (depth ${analysis.depth || 0})`);
          return;
        }

        drawArrows([]);
        updatePVDisplay([]);
        if (state.suggestionMode === 'next') {
          updateEvalBar(null);
          if (state.ply >= state.verboseHistory.length) {
            setStatus('engStatus', 'Game complete. No next move to analyze.');
          } else if (state.analysisStatus === 'running' || state.analysisStatus === 'queued') {
            setStatus('engStatus', state.analysisStatus === 'queued' ? 'Preparing analysis…' : 'Analyzing entire game…');
          } else {
            setStatus('engStatus', 'Next-move suggestion not available yet.');
          }
          return;
        }

        if (state.analysisStatus === 'running' || state.analysisStatus === 'queued') {
          setStatus('engStatus', state.analysisStatus === 'queued' ? 'Preparing analysis…' : 'Analyzing entire game…');
        }
        if (state.ply === 0) {
          updateEvalBar(null);
        } else {
          const entry = state.verboseHistory[state.ply - 1];
          updateEvalBar(entry && entry.eval ? entry.eval : null);
        }
      }

      async function analyzeMoveAtIndex(index, beforeEp, token, depth, movetime) {
        const moveEntry = state.verboseHistory[index];
        if (!moveEntry) return { afterEp: beforeEp };
        const fen = moveEntry.preFen || effectiveInitialFen();
        const actualUci = `${moveEntry.from}${moveEntry.to}${moveEntry.promotion || ''}`;
        const baseConfig = { fen, depth, movetime, ply: index + 1 };
        let multiResult;
        try {
          multiResult = await engineController.run(baseConfig);
        } catch (err) {
          return { afterEp: beforeEp };
        }
        if (token !== state.analysisToken) return { afterEp: beforeEp };
        const pvEntries = multiResult.entries.map((entry) => ({ ...entry }));
        const bestEntry = pvEntries.find((entry) => entry.rank === 1) || pvEntries[0] || null;
        let actualEntry = pvEntries.find((entry) => entry.uci === actualUci);
        if (!actualEntry) {
          let forcedResult;
          try {
            forcedResult = await engineController.run({ ...baseConfig, searchMoves: [actualUci] });
          } catch (err) {
            forcedResult = null;
          }
          if (token !== state.analysisToken) return { afterEp: beforeEp };
          const forcedEntries = forcedResult ? forcedResult.entries.map((entry) => ({ ...entry })) : [];
          actualEntry = forcedEntries.find((entry) => entry.uci === actualUci) || forcedEntries[0] || null;
        }
        const bestCp = evalStringToCentipawns(bestEntry ? bestEntry.eval : null);
        const actualCp = evalStringToCentipawns(actualEntry ? actualEntry.eval : null);
        const bestEp = cpToExpectedPoints(bestCp);
        const actualEp = cpToExpectedPoints(actualCp);
        let winPercentBefore = centipawnsToWinPercent(bestCp);
        if (winPercentBefore == null && Number.isFinite(beforeEp)) {
          winPercentBefore = beforeEp * 100;
        }
        let winPercentAfter = centipawnsToWinPercent(actualCp);
        if (winPercentAfter == null && Number.isFinite(actualEp)) {
          winPercentAfter = actualEp * 100;
        }
        const accuracyPercent = computeMoveAccuracy(winPercentBefore, winPercentAfter);
        const cpLoss = computeCpLoss(bestCp, actualCp, moveEntry.color);
        const classificationData = classifyMoveContext({
          bestEp,
          actualEp,
          beforeEp,
          moveEntry,
          bestEntry,
          actualEntry,
          winPercentBefore,
          winPercentAfter,
          pvEntries
        });
        moveEntry.eval = actualEntry && actualEntry.eval ? actualEntry.eval : (bestEntry ? bestEntry.eval : null);
        moveEntry.analysis = {
          pvEntries,
          bestEntry,
          actualEntry,
          bestEp,
          actualEp,
          beforeEp,
          expectedLoss: classificationData.expectedLoss,
          classification: classificationData.classification,
          bestCp,
          actualCp,
          cpLoss,
          winPercentBefore,
          winPercentAfter,
          accuracy: accuracyPercent,
          depth: multiResult.depth || depth || 0,
          movetime
        };
        if (state.ply === index + 1) {
          scheduleBoardBadgeUpdate();
        }
        state.analysisCache.set(index + 1, moveEntry.analysis);
        if (state.ply === index + 1 || (state.suggestionMode === 'next' && state.ply === index)) {
          applyAnalysisForCurrentPly();
        }
        renderMoves();
        updateEloEstimates();
        return { afterEp: actualEp };
      }

      async function precomputeFullAnalysis() {
        const token = nextAnalysisToken();
        state.analysisCache = new Map();
        state.analysisStatus = state.verboseHistory.length ? 'running' : 'complete';
        renderMoves();
        updatePVDisplay([]);
        drawArrows([]);
        if (!state.verboseHistory.length) {
          updateEvalBar(null);
          setStatus('engStatus', 'No moves to analyze.');
          return;
        }
        setStatus('engStatus', 'Analyzing full game…');
        ensureEngine();
        await waitForEngineReady();
        if (token !== state.analysisToken) return;
        if (state.engine) {
          state.engine.postMessage('ucinewgame');
        }
        const fixedDepth = 20;
        const fixedMovetime = 2000;
        let beforeEp = 0.5;
        for (let i = 0; i < state.verboseHistory.length; i++) {
          if (token !== state.analysisToken) return;
          const result = await analyzeMoveAtIndex(i, beforeEp, token, fixedDepth, fixedMovetime);
          if (token !== state.analysisToken) return;
          beforeEp = 1 - result.afterEp;
          setStatus('engStatus', `Analyzed ${i + 1}/${state.verboseHistory.length} moves`);
        }
        if (token !== state.analysisToken) return;
        state.analysisStatus = 'complete';
        setStatus('engStatus', `Analysis complete (${state.engineVersion || 'Stockfish'})`);
        applyAnalysisForCurrentPly();
        renderMoves();
      }

      function initializeGame({ headers = {}, verboseHistory = [], initialFen = 'start', source, rawInput, targetPly }) {
        state.initialFen = initialFen || 'start';
        state.verboseHistory = verboseHistory;
        if (typeof source === 'string') state.source = source;
        if (typeof rawInput === 'string') state.rawInput = rawInput;
        resetAnalysisState();
        initializePieceCounts();
        state.game = createBaseGame();
        state.ply = 0;
        setBoardPosition(state.initialFen);
        populateHeaders(headers);
        renderMoves();
        updateMaterialDiff();
        updateEvalBar(null);
        updatePVDisplay([]);
        updateEloEstimates();
        const destination = typeof targetPly === 'number' ? targetPly : verboseHistory.length;
        drawArrows([]);
        goToPly(destination);
        state.analysisStatus = 'queued';
        precomputeFullAnalysis();
        setStatus('loadStatus', 'Game ready.', 'ok');
        updateUrlState();
      }

      async function loadFromPgnString(pgn, options = {}) {
        const trimmed = (pgn || '').trim();
        if (!trimmed) {
          setStatus('loadStatus', 'Please provide PGN text.', 'error');
          return;
        }
        try {
          setStatus('loadStatus', 'Loading PGN…');
          const headers = parseHeaders(trimmed);
          const initialFen = headers.FEN || 'start';
          const parser = initialFen && initialFen !== 'start' ? new Chess(initialFen) : new Chess();
          const ok = parser.loadPgn(trimmed, { sloppy: true });
          if (!ok) throw new Error('Unable to parse PGN.');
          const history = buildHistory(parser, initialFen);
          initializeGame({
            headers,
            verboseHistory: history,
            initialFen,
            source: options.source || 'pgn',
            rawInput: typeof options.rawInput === 'string' ? options.rawInput : trimmed,
            targetPly: options.targetPly
          });
        } catch (err) {
          console.error(err);
          setStatus('loadStatus', err.message || 'Failed to load PGN.', 'error');
        }
      }

      async function loadFromLichessInput(raw, options = {}) {
        const trimmed = (raw || '').trim();
        if (!trimmed) {
          setStatus('loadStatus', 'Please paste a Lichess URL or ID.', 'error');
          return;
        }
        try {
          setStatus('loadStatus', 'Fetching PGN…');
          const pgn = await fetchPGN(trimmed);
          await loadFromPgnString(pgn, {
            source: 'lichess',
            rawInput: trimmed,
            targetPly: options.targetPly
          });
        } catch (err) {
          console.error(err);
          setStatus('loadStatus', err.message || 'Failed to fetch game.', 'error');
        }
      }

      function loadFromFenInput(raw, options = {}) {
        const trimmed = (raw || '').trim();
        if (!trimmed) {
          setStatus('loadStatus', 'Please provide a FEN string.', 'error');
          return;
        }
        const fenGame = new Chess();
        if (!fenGame.load(trimmed)) {
          setStatus('loadStatus', 'Invalid FEN string.', 'error');
          return;
        }
        const headers = {
          White: '—',
          Black: '—',
          Site: 'Custom FEN',
          Result: '*',
          Date: new Date().toISOString().slice(0, 10)
        };
        initializeGame({
          headers,
          verboseHistory: [],
          initialFen: trimmed,
          source: 'fen',
          rawInput: trimmed,
          targetPly: typeof options.targetPly === 'number' ? options.targetPly : 0
        });
        setStatus('loadStatus', 'Position ready.', 'ok');
      }

      async function handleUserLoad(targetPly = null) {
        const mode = byId('inputMode').value;
        const value = byId('gameInput').value;
        if (mode === 'lichess') {
          await loadFromLichessInput(value, { targetPly });
        } else if (mode === 'fen') {
          loadFromFenInput(value, { targetPly });
        } else {
          await loadFromPgnString(value, { source: 'pgn', rawInput: value, targetPly });
        }
      }

      function bindUi() {
        byId('loadBtn').addEventListener('click', () => handleUserLoad());
        byId('inputMode').addEventListener('change', (event) => {
          setInputMode(event.target.value);
        });
        const input = byId('gameInput');
        input.addEventListener('keydown', (event) => {
          if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
            event.preventDefault();
            handleUserLoad();
          }
        });
        byId('firstBtn').addEventListener('click', () => goToPly(0));
        byId('prevBtn').addEventListener('click', () => goToPly(state.ply - 1));
        byId('nextBtn').addEventListener('click', () => goToPly(state.ply + 1));
        byId('lastBtn').addEventListener('click', () => goToPly(state.verboseHistory.length));
        byId('flipBtn').addEventListener('click', () => {
          state.orientation = state.orientation === 'white' ? 'black' : 'white';
          state.board.flip();
          requestAnimationFrame(() => {
            const analysis = getAnalysisForCurrentView();
            drawArrows(analysis ? analysis.pvEntries || [] : []);
            updateBoardClassificationBadge();
          });
        });
        byId('themeToggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          setTheme(newTheme);
        });
        const suggestionToggle = byId('suggestionToggle');
        if (suggestionToggle) {
          suggestionToggle.addEventListener('click', () => {
            toggleSuggestionMode();
          });
        }
      }

      function getSystemTheme() {
        return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }

      function getSavedTheme() {
        return localStorage.getItem('theme');
      }

      function setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        updateThemeButton(theme);
      }

      function updateThemeButton(theme) {
        const button = byId('themeToggle');
        if (theme === 'dark') {
          button.textContent = '☀️ Light';
          button.title = 'Switch to light theme';
        } else {
          button.textContent = '🌙 Dark';
          button.title = 'Switch to dark theme';
        }
      }

      function initTheme() {
        const savedTheme = getSavedTheme();
        const systemTheme = getSystemTheme();
        const theme = savedTheme || systemTheme;
        setTheme(theme);
        if (window.matchMedia) {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!getSavedTheme()) {
              setTheme(e.matches ? 'dark' : 'light');
            }
          });
        }
      }

      async function loadFromQuery() {
        const params = new URLSearchParams(window.location.search);
        const sourceParam = params.get('source');
        const dataParam = params.get('data');
        const legacyGame = params.get('game');
        const plyParam = parseInt(params.get('ply'), 10);
        const targetPly = Number.isFinite(plyParam) ? plyParam : null;

        try {
          if (!sourceParam && legacyGame) {
            setInputMode('lichess');
            byId('gameInput').value = legacyGame;
            await loadFromLichessInput(legacyGame, { targetPly });
            return;
          }

          if (!sourceParam || !dataParam) {
            setInputMode('pgn');
            return;
          }

          const raw = decodeStateValue(dataParam);
          if (!raw) return;

          setInputMode(sourceParam);
          byId('gameInput').value = raw;

          if (sourceParam === 'pgn') {
            await loadFromPgnString(raw, { source: 'pgn', rawInput: raw, targetPly });
          } else if (sourceParam === 'lichess') {
            await loadFromLichessInput(raw, { targetPly });
          } else if (sourceParam === 'fen') {
            loadFromFenInput(raw, { targetPly });
          }
        } catch (err) {
          console.error(err);
        }
      }

      async function main() {
        if (typeof window.Chessboard === 'undefined') {
          setStatus('loadStatus', 'Failed to load chessboard.js', 'error');
          return;
        }
        if (typeof Chess === 'undefined') {
          setStatus('loadStatus', 'Failed to load chess.js', 'error');
          return;
        }

        initTheme();
        initBoard();
        initMoveSummary();
        updateMoveSummary();
        setInputMode('pgn');
        bindUi();
        initSuggestionMode();
        initializePieceCounts();
        state.game = createBaseGame();
        updateMaterialDiff();
        updateEvalBar(null);
        updatePVDisplay([]);
        updateEloEstimates();
        setStatus('engStatus', 'Initializing engine…');
        ensureEngine();

        await loadFromQuery();
      }

      window.addEventListener('load', main);
    })();
  </script>

</body>

</html>
