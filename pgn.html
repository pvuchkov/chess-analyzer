<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lichess PGN Analyzer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
  <style>
    :root {
      --bg: #0e101d;
      --panel: #15192b;
      --text: #f3f6ff;
      --muted: #8891b0;
      --accent: #70a7ff;
      --ok: #3fd086;
      --warn: #ffc867;
      --danger: #ff708a;
    }

    [data-theme="light"] {
      --bg: #ffffff;
      --panel: #f8f9fa;
      --text: #212529;
      --muted: #6c757d;
      --accent: #007bff;
      --ok: #28a745;
      --warn: #ffc107;
      --danger: #dc3545;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      color: var(--text);
      background: var(--bg);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    [data-theme="dark"] body {
      background: radial-gradient(1200px 800px at 10% -10%, #1b2141, #090c18);
    }

    [data-theme="light"] body {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }

    h1 {
      margin: 0 0 20px;
      font-size: 26px;
      letter-spacing: 0.4px;
    }

    a {
      color: var(--accent);
    }

    .layout {
      display: grid;
      gap: 18px;
      align-items: start;
      grid-template-columns: minmax(320px, 420px) minmax(340px, 1fr);
      max-width: 1200px;
      margin: 0 auto;
    }

    @media (max-width:1024px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    [data-theme="light"] .card {
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 18px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .row+.row {
      margin-top: 12px;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"] {
      flex: 1;
      min-width: 0;
      padding: 10px 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      background: var(--panel);
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="password"],
    [data-theme="dark"] input[type="number"] {
      background: #0b1024;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    [data-theme="light"] input[type="text"],
    [data-theme="light"] input[type="password"],
    [data-theme="light"] input[type="number"] {
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.15);
      color: #212529;
    }

    input[type="text"]:focus,
    input[type="password"]:focus,
    input[type="number"]:focus {
      border-color: var(--accent);
    }

    button {
      background: linear-gradient(180deg, #27386a, #213159);
      border: 1px solid rgba(255, 255, 255, 0.18);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform .1s ease, filter .2s;
    }

    button.secondary {
      background: #161d35;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .status {
      min-height: 20px;
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .status.error {
      color: var(--danger);
    }

    .status.ok {
      color: var(--ok);
    }

    .board-wrap {
      position: relative;
    }

    #board {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
    }

    #arrowLayer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
    }

    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 14px;
    }

    .kv div:nth-child(odd) {
      color: var(--muted);
    }

    .muted {
      color: var(--muted);
    }

    .moves {
      display: grid;
      grid-template-columns: 40px 1fr 1fr;
      gap: 6px 12px;
      font-size: 14px;
    }

    .mv {
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
      background: rgba(15, 20, 40, 0.6);
      transition: background .12s, transform .12s;
    }

    .mv {
      position: relative;
    }

    .mv:hover {
      background: rgba(112, 167, 255, 0.16);
    }

    .mv.active {
      background: rgba(112, 167, 255, 0.28);
      box-shadow: 0 0 0 1px rgba(112, 167, 255, 0.5);
    }

    .eval {
      position: absolute;
      top: -12px;
      right: 2px;
      font-size: 10px;
      font-weight: 600;
      color: var(--accent);
      background: rgba(0, 0, 0, 0.7);
      padding: 1px 3px;
      border-radius: 3px;
      white-space: nowrap;
      opacity: 0.8;
    }

    .pv-list {
      display: grid;
      gap: 8px;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 13px;
    }

    .pv {
      display: grid;
      grid-template-columns: 26px auto auto;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
    }

    .pv:nth-child(1) {
      background: rgba(63, 208, 134, 0.12);
      box-shadow: 0 0 0 1px rgba(63, 208, 134, 0.35);
    }

    .pv:nth-child(2) {
      background: rgba(112, 167, 255, 0.12);
      box-shadow: 0 0 0 1px rgba(112, 167, 255, 0.35);
    }

    .pv:nth-child(3) {
      background: rgba(255, 200, 103, 0.12);
      box-shadow: 0 0 0 1px rgba(255, 200, 103, 0.35);
    }

    .pv .rank {
      font-weight: 700;
    }

    .pv .move {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .pv .eval {
      color: var(--muted);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .eval-bar-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }

    .eval-bar {
      flex: 1;
      height: 8px;
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }

    .eval-fill {
      height: 100%;
      background: linear-gradient(to right, #dc3545 0%, #ffc867 50%, #28a745 100%);
      width: 50%;
      transform: translateX(-50%);
      transition: transform 0.3s ease;
    }

    .eval-zero-line {
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 1px;
      background: var(--text);
      opacity: 0.5;
    }

    .eval-value {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      min-width: 45px;
      text-align: right;
    }
  </style>
</head>

<body>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1>Lichess PGN Analyzer</h1>
    <button id="themeToggle" class="secondary" style="padding: 8px 12px; font-size: 14px;">üåô Dark</button>
  </div>
  <div class="layout">
    <div class="card">
      <h2>Load game</h2>
      <div class="row">
        <input id="lichessUrl" type="text" placeholder="Paste Lichess URL or game ID" autocomplete="off" />
      </div>
      <div class="row">
        <input id="token" type="password" placeholder="Optional: API token for private games" autocomplete="off" />
        <button id="loadBtn">Fetch PGN</button>
      </div>
      <div class="row">
        <label class="hint">Tip: run from http://localhost (e.g. python -m http.server). file:// may block network
          requests.</label>
      </div>
      <div id="loadStatus" class="status"></div>

      <h2>Board</h2>
      <div class="board-wrap">
        <div id="board"></div>
        <svg id="arrowLayer" viewBox="0 0 800 800" preserveAspectRatio="none"></svg>
      </div>

      <h3 style="margin:18px 0 8px; font-size:14px; color:var(--muted);">Evaluation</h3>
      <div class="eval-bar-container">
        <div class="eval-bar">
          <div class="eval-fill" id="evalFill"></div>
          <div class="eval-zero-line"></div>
        </div>
        <div class="eval-value" id="evalValue">0.00</div>
      </div>

      <div class="row" style="margin-top:14px; align-items:center;">
        <button id="firstBtn" class="secondary">‚èÆ First</button>
        <button id="prevBtn" class="secondary">‚óÄ Prev</button>
        <button id="nextBtn">Next ‚ñ∂</button>
        <button id="lastBtn">Last ‚è≠</button>
        <button id="flipBtn" class="secondary">Flip</button>
      </div>
      <div class="row" style="margin-top:12px; align-items:center;">
        <label style="font-size:13px; color:var(--muted);">Engine: time (ms)</label>
        <input id="timeMs" type="number" min="100" max="10000" step="100" value="1500" style="width:120px;" />
        <label style="font-size:13px; color:var(--muted);">Depth</label>
        <input id="depth" type="number" min="1" max="40" step="1" value="20" style="width:100px;" />
      </div>
      <div id="navStatus" class="status"></div>
    </div>

    <div class="card">
      <h2>Game info</h2>
      <div class="kv" id="tagBox">
        <div>White</div>
        <div id="tagWhite">‚Äî</div>
        <div>Black</div>
        <div id="tagBlack">‚Äî</div>
        <div>Event</div>
        <div id="tagEvent">‚Äî</div>
        <div>Site</div>
        <div id="tagSite">‚Äî</div>
        <div>Date</div>
        <div id="tagDate">‚Äî</div>
        <div>Result</div>
        <div id="tagResult">‚Äî</div>
        <div>Opening</div>
        <div id="tagOpening">‚Äî</div>
      </div>

      <h2 style="margin-top:22px;">Engine suggestions <span style="font-size:12px; font-weight:400; color:var(--muted);">(eval ¬± rating change vs best)</span></h2>
      <div class="pv-list">
        <div class="pv"><span class="rank">1</span><span class="move" id="pv1">‚Äî</span><span class="eval"
            id="ev1"></span></div>
        <div class="pv"><span class="rank">2</span><span class="move" id="pv2">‚Äî</span><span class="eval"
            id="ev2"></span></div>
        <div class="pv"><span class="rank">3</span><span class="move" id="pv3">‚Äî</span><span class="eval"
            id="ev3"></span></div>
        <div id="engStatus" class="status"></div>
      </div>

      <h2 style="margin-top:22px;">Moves</h2>
      <div id="moves" class="moves"></div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script type="module">
    import { Chess } from './chess.js';
    (function () {
      const byId = (id) => document.getElementById(id);
      const state = {
        board: null,
        orientation: 'white',
        game: new Chess(),
        verboseHistory: [],
        ply: 0,
        engine: null,
        engineReady: false,
        engineConfigured: false,
        engineVersion: 'unknown',
        pendingAnalysis: null,
        multiPv: new Map()
      };

      function initBoard() {
        const box = byId('board');
        state.board = Chessboard('board', {
          position: 'start', draggable: false,
          pieceTheme: 'chesspieces/wikipedia/{piece}.png'
        });
        syncArrowLayer();
        const handleResize = () => { state.board.resize(); syncArrowLayer(); };
        window.addEventListener('resize', handleResize);
      }

      function syncArrowLayer() {
        const boardEl = byId('board');
        const svg = byId('arrowLayer');
        const rect = boardEl.getBoundingClientRect();
        svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.width}`);
        svg.setAttribute('width', rect.width);
        svg.setAttribute('height', rect.width);
      }

      function setStatus(id, msg, type) {
        const el = byId(id); if (!el) return;
        el.textContent = msg || '';
        el.classList.remove('error', 'ok');
        if (type === 'error') el.classList.add('error');
        if (type === 'ok') el.classList.add('ok');
      }

      function extractGameId(input) {
        if (!input) return '';
        try {
          const url = new URL(input.trim());
          return url.pathname.split('/').filter(Boolean)[0] || '';
        } catch (e) {
          return input.trim();
        }
      }

      async function fetchPGN(input, token) {
        const id = extractGameId(input);
        if (!id) throw new Error('Please provide a Lichess URL or game ID.');
        const params = new URLSearchParams({ moves: '1', tags: '1', clocks: '1', opening: '1', evals: '0', literate: '0' });
        const headers = { 'Accept': 'application/x-chess-pgn' };
        if (token) headers['Authorization'] = `Bearer ${token}`;
        const res = await fetch(`https://lichess.org/game/export/${id}.pgn?${params.toString()}`, { headers });
        if (!res.ok) throw new Error(`HTTP ${res.status} ‚Äì ${res.statusText}`);
        return res.text();
      }

      function populateHeaders(headers) {
        byId('tagWhite').textContent = headers.White || '‚Äî';
        byId('tagBlack').textContent = headers.Black || '‚Äî';
        byId('tagEvent').textContent = headers.Event || '‚Äî';
        byId('tagSite').textContent = headers.Site || '‚Äî';
        byId('tagDate').textContent = headers.Date || '‚Äî';
        byId('tagResult').textContent = headers.Result || '‚Äî';
        byId('tagOpening').textContent = headers.Opening || headers.ECO || '‚Äî';
      }

      function parseHeaders(pgn) {
        const out = {};
        const regex = /\[(\w+)\s+"([^\"]*)"\]/g;
        let match;
        while ((match = regex.exec(pgn)) !== null) {
          out[match[1]] = match[2];
        }
        return out;
      }

      function buildHistory(game) {
        const verbose = [];
        const temp = new Chess();
        const moves = game.history();
        temp.reset();
        for (const mv of moves) {
          const played = temp.move(mv);
          verbose.push({ ...played, fen: temp.fen(), eval: null });
        }
        return verbose;
      }

      function renderMoves() {
        const container = byId('moves');
        container.innerHTML = '';
        const h = state.verboseHistory;
        for (let i = 0; i < h.length; i += 2) {
          const moveNo = document.createElement('div');
          moveNo.textContent = `${Math.floor(i / 2) + 1}.`;
          moveNo.className = 'muted';

          const white = document.createElement('div');
          white.className = 'mv';
          white.textContent = h[i] ? h[i].san : '';

          const whiteEval = document.createElement('div');
          whiteEval.className = 'eval';
          whiteEval.textContent = h[i] && h[i].eval ? h[i].eval : '';
          white.appendChild(whiteEval);

          const black = document.createElement('div');
          black.className = 'mv';
          black.textContent = h[i + 1] ? h[i + 1].san : '';

          const blackEval = document.createElement('div');
          blackEval.className = 'eval';
          blackEval.textContent = h[i + 1] && h[i + 1].eval ? h[i + 1].eval : '';
          black.appendChild(blackEval);

          white.addEventListener('click', () => goToPly(i + 1));
          black.addEventListener('click', () => goToPly(i + 2));
          container.appendChild(moveNo);
          container.appendChild(white);
          container.appendChild(black);
        }
        highlightActive();
      }

      function highlightActive() {
        Array.from(document.querySelectorAll('.mv')).forEach(el => el.classList.remove('active'));
        const idx = state.ply - 1;
        if (idx < 0) return;
        const row = Math.floor(idx / 2);
        const col = idx % 2;
        const container = byId('moves');
        const cell = container.children[row * 3 + 1 + col];
        if (cell) cell.classList.add('active');
      }

      function goToPly(ply) {
        const max = state.verboseHistory.length;
        state.ply = Math.max(0, Math.min(max, ply));
        if (state.ply === 0) {
          state.board.position('start');
          state.game.reset();
        } else {
          state.board.position(state.verboseHistory[state.ply - 1].fen);
          state.game.reset();
          for (let i = 0; i < state.ply; i++) {
            const mv = state.verboseHistory[i];
            state.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion });
          }
        }
        highlightActive();
        analyzeCurrent();

        // Update evaluation bar with stored evaluation for this position
        if (state.ply > 0 && state.verboseHistory[state.ply - 1].eval) {
          updateEvalBar(state.verboseHistory[state.ply - 1].eval);
        } else {
          updateEvalBar(null); // Reset to neutral
        }

        setStatus('navStatus', `Move ${state.ply} / ${max}`);
      }

      function drawArrows(list) {
        const svg = byId('arrowLayer');
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        defs.innerHTML = `
        <marker id="m1" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="5" markerHeight="5" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z" fill="#28a745" />
        </marker>
        <marker id="m2" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="5" markerHeight="5" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z" fill="#007bff" />
        </marker>
        <marker id="m3" viewBox="0 0 8 8" refX="7" refY="4" markerWidth="5" markerHeight="5" orient="auto">
          <path d="M0,0 L8,4 L0,8 Z" fill="#dc3545" />
        </marker>`;
        svg.appendChild(defs);
        if (!list || !list.length) return;
        const boardRect = byId('board').getBoundingClientRect();
        const squareSize = boardRect.width / 8;
        function squareCenter(sq) {
          const file = sq.charCodeAt(0) - 97;
          const rank = parseInt(sq[1], 10) - 1;
          if (state.orientation === 'white') {
            return {
              x: (file + 0.5) * squareSize,
              y: ((7 - rank) + 0.5) * squareSize
            };
          } else {
            return {
              x: ((7 - file) + 0.5) * squareSize,
              y: (rank + 0.5) * squareSize
            };
          }
        }
        const colors = ['#28a745', '#007bff', '#dc3545']; // Green, Blue, Red - distinct colors
        const opacities = [1.0, 0.25, 0.25]; // Best solid, 2nd more transparent, 3rd medium
        list.forEach((entry, i) => {
          if (!entry || !entry.uci) return;
          const from = squareCenter(entry.uci.slice(0, 2));
          const to = squareCenter(entry.uci.slice(2, 4));
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const len = Math.hypot(dx, dy);
          if (!len) return;
          // Make arrows smaller - reduce the shorten amount and starting offset
          const shorten = Math.min(12, len * 0.15); // Reduced from 20 to 12, 0.2 to 0.15
          const startOffset = Math.min(12, len * 0.1); // Start closer to the piece
          const sx = from.x + (dx / len) * startOffset;
          const sy = from.y + (dy / len) * startOffset;
          const ex = to.x - (dx / len) * shorten;
          const ey = to.y - (dy / len) * shorten;
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', sx);
          line.setAttribute('y1', sy);
          line.setAttribute('x2', ex);
          line.setAttribute('y2', ey);
          line.setAttribute('stroke', colors[i] || colors[2]);
          line.setAttribute('stroke-width', Math.max(4, 6 - i * 0.8)); // Smaller base width, progressive reduction
          line.setAttribute('stroke-linecap', 'round');
          line.setAttribute('marker-end', `url(#m${i + 1})`);
          line.setAttribute('opacity', opacities[i] || opacities[2]);
          svg.appendChild(line);
        });
      }

      function uciToSan(fen, uci) {
        try {
          const game = new Chess(fen);
          const move = {
            from: uci.slice(0, 2),
            to: uci.slice(2, 4),
            promotion: uci.length > 4 ? uci[4] : undefined
          };
          const played = game.move(move);
          return played && played.san ? played.san : uci;
        } catch (e) {
          return uci;
        }
      }

      function updatePVDisplay(entries) {
        const ids = [1, 2, 3];

        // Get the best move's evaluation as baseline
        const bestEval = entries[0] && entries[0].eval ? parseFloat(entries[0].eval) || 0 : 0;

        ids.forEach((idx, i) => {
          const moveEl = byId(`pv${idx}`);
          const evalEl = byId(`ev${idx}`);
          const entry = entries[i] || null;
          if (entry) {
            moveEl.textContent = entry.san || entry.uci;
            evalEl.textContent = entry.eval || '';

            // Add rating change info (difference from best move)
            const moveEval = parseFloat(entry.eval) || 0;
            const ratingChange = (moveEval - bestEval) * 100; // Convert to rating points

            // Update the display to include rating change
            if (!isNaN(ratingChange) && Math.abs(ratingChange) > 1) { // Only show if significant difference
              const sign = ratingChange > 0 ? '+' : '';
              evalEl.textContent = `${entry.eval} (${sign}${ratingChange.toFixed(0)})`;
            } else {
              evalEl.textContent = entry.eval || '';
            }
          } else {
            moveEl.textContent = '‚Äî';
            evalEl.textContent = '';
          }
        });

        // Update evaluation bar with the best move's evaluation
        if (entries[0] && entries[0].eval) {
          updateEvalBar(entries[0].eval);
        }
      }

      function updateEvalBar(evalStr) {
        const evalValueEl = byId('evalValue');
        const evalFillEl = byId('evalFill');

        if (!evalStr) {
          evalValueEl.textContent = '0.00';
          evalFillEl.style.transform = 'translateX(-50%)';
          return;
        }

        // Handle mate scores
        if (evalStr.startsWith('#')) {
          const mateIn = parseInt(evalStr.substring(1));
          evalValueEl.textContent = evalStr;
          // Position bar based on mate score (very positive or negative)
          const position = mateIn > 0 ? 100 : 0;
          evalFillEl.style.transform = `translateX(${position - 50}%)`;
          return;
        }

        // Handle centipawn scores
        const cp = parseFloat(evalStr);
        evalValueEl.textContent = evalStr;

        // Convert centipawn to percentage (clamp between -300 to +300 cp for display)
        const clampedCp = Math.max(-300, Math.min(300, cp));
        const percentage = (clampedCp + 300) / 600; // 0 to 1 range
        const position = percentage * 100; // 0 to 100%

        evalFillEl.style.transform = `translateX(${position - 50}%)`;
      }

      function ensureEngine() {
        if (state.engine) return;
        setStatus('engStatus', 'Loading engine‚Ä¶');
        let worker;
        let engineLabel = 'Stockfish';
        try {
          worker = new Worker('node_modules/stockfish/src/stockfish-17.1-lite-single-03e3232.js');
          engineLabel = 'Stockfish 17.1';
        } catch (e) {
          console.error('Failed to load Stockfish worker:', e);
          setStatus('engStatus', 'Failed to load Stockfish.', 'error');
          return;
        }
        if (!worker) {
          setStatus('engStatus', 'Failed to load Stockfish worker.', 'error');
          return;
        }
        state.engine = worker;
        state.engineReady = false;
        state.engineVersion = 'unknown';
        
        state.engine.onerror = (err) => {
          console.error('Stockfish worker error:', err);
          setStatus('engStatus', 'Engine error: ' + err.message, 'error');
        };
        
        state.engine.onmessage = (e) => {
          let line = typeof e.data === 'string' ? e.data : '';
          if (!line && e.data && typeof e.data === 'object') {
            line = e.data.data || e.data.text || '';
          }
          if (!line) {
            console.warn('Engine sent empty message:', e);
            return;
          }
          
          console.log('Engine:', line);
          
          // Detect version from id command response
          if (line.startsWith('id name')) {
            state.engineVersion = line.substring(8).trim();
            engineLabel = state.engineVersion;
          }
          
          if (line.startsWith('uciok')) {
            state.engineReady = true;
            console.log('Engine is ready, configuring options...');
            state.engine.postMessage('setoption name MultiPV value 3');
            state.engine.postMessage('setoption name Threads value 1');
            state.engine.postMessage('setoption name Ponder value false');
            state.engine.postMessage('isready');
            return;
          }

          if (line.startsWith('readyok')) {
            console.log('Engine confirmed ready');
            state.engineConfigured = true;
            setStatus('engStatus', `${engineLabel} ready`, 'ok');
            if (state.pendingAnalysis) {
              console.log('Running pending analysis...');
              analyzeCurrent();
            }
            return;
          }
          
          if (line.startsWith('info')) {
            handleInfo(line);
            return;
          }
          
          if (line.startsWith('bestmove')) {
            // Store the current position's evaluation in history
            if (state.ply > 0 && state.multiPv && state.multiPv.has(1)) {
              const bestMove = state.multiPv.get(1);
              if (bestMove && bestMove.eval) {
                state.verboseHistory[state.ply - 1].eval = bestMove.eval;
                renderMoves(); // Re-render to show the evaluation
              }
            }
            setStatus('engStatus', `Analysis complete (${engineLabel})`);
          }
        };
        
        // Initialize UCI
        console.log('Sending UCI command to engine...');
        state.engine.postMessage('uci');
      }

      function handleInfo(line) {
        const multi = line.match(/\bmultipv (\d+)/);
        const pv = line.match(/\bpv ((?:[a-h][1-8]){2}[qrbn]?\b.*)/);
        const scoreMate = line.match(/\bscore mate (-?\d+)/);
        const scoreCp = line.match(/\bscore cp (-?\d+)/);
        if (!multi || !pv) return;
        const rank = parseInt(multi[1], 10);
        if (rank < 1 || rank > 3) return;
        const moves = pv[1].trim().split(/\s+/);
        let evalStr = '';
        if (scoreMate) {
          evalStr = `#${scoreMate[1]}`;
        } else if (scoreCp) {
          const cp = parseInt(scoreCp[1], 10);
          evalStr = `${cp >= 0 ? '+' : ''}${(cp / 100).toFixed(2)}`;
        }
        const entry = {
          rank,
          uci: moves[0],
          eval: evalStr
        };
        const baseFen = state.ply === 0 ? new Chess().fen() : state.verboseHistory[state.ply - 1].fen;
        entry.san = uciToSan(baseFen, entry.uci);
        state.multiPv = state.multiPv || new Map();
        state.multiPv.set(rank, entry);
        const list = [1, 2, 3].map(r => state.multiPv.get(r) || null);
        drawArrows(list);
        updatePVDisplay(list);
        setStatus('engStatus', `Analyzing‚Ä¶ depth ${line.match(/\bdepth (\d+)/)?.[1] || ''}`);
      }

      function analyzeCurrent() {
        ensureEngine();
        if (!state.engineConfigured) {
          state.pendingAnalysis = true;
          setStatus('engStatus', 'Waiting for engine‚Ä¶');
          return;
        }

        state.pendingAnalysis = false;
        state.multiPv = new Map();
        drawArrows([]);
        updatePVDisplay([]);
        setStatus('engStatus', 'Analyzing‚Ä¶');

        const fen = state.ply === 0 ? new Chess().fen() : state.verboseHistory[state.ply - 1].fen;

        // Stop any previous analysis
        state.engine.postMessage('stop');

        // Small delay to ensure stop is processed
        setTimeout(() => {
          state.engine.postMessage(`position fen ${fen}`);

          const depthVal = parseInt(byId('depth').value, 10);
          const timeVal = parseInt(byId('timeMs').value, 10) || 300;

          if (depthVal && depthVal > 0) {
            state.engine.postMessage(`go depth ${depthVal}`);
          } else {
            state.engine.postMessage(`go movetime ${timeVal}`);
          }
        }, 50);
      }

      function getUrlParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
      }

      function setUrlParam(name, value) {
        const url = new URL(window.location);
        if (value) {
          url.searchParams.set(name, value);
        } else {
          url.searchParams.delete(name);
        }
        window.history.replaceState({}, '', url);
      }

      function extractGameId(input) {
        if (!input) return null;
        try {
          const url = new URL(input);
          const pathSegments = url.pathname.split('/').filter(Boolean);
          return pathSegments[0] || input;
        } catch (e) {
          return input; // Assume it's already a game ID
        }
      }

      async function loadGame(gameId, token = '') {
        if (!gameId) return;
        try {
          setStatus('loadStatus', 'Fetching PGN‚Ä¶');
          const pgn = await fetchPGN(gameId, token);
          state.game.loadPgn(pgn);
          state.verboseHistory = buildHistory(state.game);
          state.game.reset();
          state.ply = 0;
          state.board.position('start');
          populateHeaders(parseHeaders(pgn));
          renderMoves();
          if (state.engineReady) state.engine.postMessage('ucinewgame');
          goToPly(state.verboseHistory.length);
          setStatus('loadStatus', 'Game ready.', 'ok');
        } catch (err) {
          console.error(err);
          setStatus('loadStatus', err.message || 'Failed to load game.', 'error');
        }
      }

      function bindUi() {
        byId('loadBtn').addEventListener('click', async () => {
          const input = byId('lichessUrl').value.trim();
          const token = byId('token').value;
          if (!input) return setStatus('loadStatus', 'Please paste a Lichess URL or ID.', 'error');

          const gameId = extractGameId(input);
          setUrlParam('game', gameId);
          await loadGame(gameId, token);
        });

        byId('lichessUrl').addEventListener('input', () => {
          const input = byId('lichessUrl').value.trim();
          const gameId = extractGameId(input);
          setUrlParam('game', gameId || null);
        });

        byId('firstBtn').addEventListener('click', () => goToPly(0));
        byId('prevBtn').addEventListener('click', () => goToPly(state.ply - 1));
        byId('nextBtn').addEventListener('click', () => goToPly(state.ply + 1));
        byId('lastBtn').addEventListener('click', () => goToPly(state.verboseHistory.length));
        byId('flipBtn').addEventListener('click', () => {
          state.orientation = state.orientation === 'white' ? 'black' : 'white';
          state.board.flip();
          requestAnimationFrame(() => drawArrows(state.multiPv ? [1, 2, 3].map(r => state.multiPv.get(r) || null) : []));
        });
        byId('timeMs').addEventListener('change', analyzeCurrent);
        byId('depth').addEventListener('change', analyzeCurrent);

        byId('themeToggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          setTheme(newTheme);
        });
      }

      // Theme management
      function getSystemTheme() {
        return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }

      function getSavedTheme() {
        return localStorage.getItem('theme');
      }

      function setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        updateThemeButton(theme);
      }

      function updateThemeButton(theme) {
        const button = byId('themeToggle');
        if (theme === 'dark') {
          button.textContent = '‚òÄÔ∏è Light';
          button.title = 'Switch to light theme';
        } else {
          button.textContent = 'üåô Dark';
          button.title = 'Switch to dark theme';
        }
      }

      function initTheme() {
        const savedTheme = getSavedTheme();
        const systemTheme = getSystemTheme();
        const theme = savedTheme || systemTheme;
        setTheme(theme);

        // Listen for system theme changes
        if (window.matchMedia) {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!getSavedTheme()) {
              setTheme(e.matches ? 'dark' : 'light');
            }
          });
        }
      }

      function main() {
        if (typeof window.Chessboard === 'undefined') {
          setStatus('loadStatus', 'Failed to load chessboard.js', 'error');
          return;
        }
        if (typeof Chess === 'undefined') {
          setStatus('loadStatus', 'Failed to load chess.js', 'error');
          return;
        }

        initTheme();
        initBoard();
        bindUi();
        updateEvalBar(null); // Initialize evaluation bar to neutral
        setStatus('engStatus', 'Initializing engine‚Ä¶');
        ensureEngine();

        // Check for game parameter in URL and auto-load
        const gameParam = getUrlParam('game');
        if (gameParam) {
          byId('lichessUrl').value = gameParam;
          setUrlParam('game', gameParam); // Ensure it's in URL
          // Auto-load after a short delay to ensure engine is ready
          setTimeout(() => loadGame(gameParam), 1000);
        }
      }

      window.addEventListener('load', main);
    })();
  </script>
</body>

</html>