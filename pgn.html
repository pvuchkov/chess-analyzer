<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lichess PGN Analyzer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(18, 24, 46, 0.92);
      --text: #f5f7ff;
      --muted: #94a3c4;
      --accent: #7dc4ff;
      --ok: #5ee1a3;
      --warn: #ffd480;
      --danger: #ff7aa5;
      --eval-black: #1f2338;
      --eval-white: #f7f9ff;
      --eval-border: rgba(255, 255, 255, 0.12);
      --eval-zero: rgba(148, 163, 196, 0.5);
      --eval-pointer: #facc15;
      --badge-best: #38bdf8;
      --badge-excellent: #4ade80;
      --badge-good: #a855f7;
      --badge-inaccuracy: #f97316;
      --badge-mistake: #fb7185;
      --badge-blunder: #ef4444;
      --badge-brilliant: #eab308;
    }

    [data-theme="light"] {
      --bg: #f3f6fb;
      --panel: rgba(255, 255, 255, 0.92);
      --text: #1f2937;
      --muted: #6b7280;
      --accent: #2563eb;
      --ok: #16a34a;
      --warn: #f59e0b;
      --danger: #dc2626;
      --eval-black: #111827;
      --eval-white: #ffffff;
      --eval-border: rgba(15, 23, 42, 0.15);
      --eval-zero: rgba(107, 114, 128, 0.45);
      --eval-pointer: #0ea5e9;
      --badge-best: #2563eb;
      --badge-excellent: #16a34a;
      --badge-good: #7c3aed;
      --badge-inaccuracy: #d97706;
      --badge-mistake: #f97316;
      --badge-blunder: #dc2626;
      --badge-brilliant: #ca8a04;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      color: var(--text);
      background: var(--bg);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    [data-theme="dark"] body {
      background: radial-gradient(1200px 800px at 10% -10%, #131b34, #080b17);
    }

    [data-theme="light"] body {
      background: linear-gradient(135deg, #f9fbff 0%, #dbe7ff 100%);
    }

    h1 {
      margin: 0 0 20px;
      font-size: 26px;
      letter-spacing: 0.4px;
    }

    a {
      color: var(--accent);
    }

    .layout {
      display: grid;
      gap: 18px;
      align-items: start;
      grid-template-columns: minmax(320px, 420px) minmax(340px, 1fr);
      max-width: 1200px;
      margin: 0 auto;
    }

    @media (max-width:1024px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    [data-theme="light"] .card {
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 18px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .row+.row {
      margin-top: 12px;
    }

    input[type="text"],
    input[type="password"],
    input[type="number"],
    textarea,
    select {
      flex: 1;
      min-width: 0;
      padding: 10px 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      background: var(--panel);
      color: var(--text);
      font-size: 14px;
      outline: none;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="password"],
    [data-theme="dark"] input[type="number"],
    [data-theme="dark"] textarea,
    [data-theme="dark"] select {
      background: #0b1024;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    [data-theme="light"] input[type="text"],
    [data-theme="light"] input[type="password"],
    [data-theme="light"] input[type="number"],
    [data-theme="light"] textarea,
    [data-theme="light"] select {
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.15);
      color: #212529;
    }

    input[type="text"]:focus,
    input[type="password"]:focus,
    input[type="number"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent);
    }

    button {
      background: linear-gradient(180deg, rgba(80, 120, 255, 0.95), rgba(46, 84, 214, 0.95));
      border: 1px solid rgba(125, 196, 255, 0.45);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      transition: transform .12s ease, filter .18s ease;
    }

    button:hover {
      filter: brightness(1.06);
      transform: translateY(-1px);
    }

    button.secondary {
      background: rgba(125, 196, 255, 0.12);
      border: 1px solid rgba(125, 196, 255, 0.25);
      color: var(--text);
    }

    [data-theme="light"] button.secondary {
      background: rgba(37, 99, 235, 0.08);
      border: 1px solid rgba(37, 99, 235, 0.18);
      color: #1f2937;
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .toggle-row {
      margin-top: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      color: var(--muted);
    }

    .toggle-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }

    .load-controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: stretch;
    }

    .input-switch {
      display: grid;
      gap: 10px;
    }

    .input-switch select {
      max-width: 220px;
      flex: none;
    }

    textarea {
      resize: vertical;
      line-height: 1.5;
    }

    .game-input {
      width: 100%;
      min-height: 120px;
    }

    .game-input.compact {
      min-height: 54px;
      max-height: 120px;
    }

    .material-panel {
      margin-top: 18px;
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid rgba(125, 196, 255, 0.18);
      background: rgba(125, 196, 255, 0.08);
      display: grid;
      gap: 10px;
    }

    [data-theme="light"] .material-panel {
      border-color: rgba(37, 99, 235, 0.18);
      background: rgba(37, 99, 235, 0.08);
    }

    .material-header {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--muted);
    }

    .material-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .material-side {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .material-side-label {
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .material-icons {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      flex-wrap: wrap;
      min-height: 24px;
    }

    .material-icons img {
      width: 22px;
      height: 22px;
      object-fit: contain;
      filter: drop-shadow(0 2px 5px rgba(0, 0, 0, 0.35));
    }

    .material-score {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-weight: 600;
      min-width: 44px;
      text-align: right;
    }

    .status {
      min-height: 20px;
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .status.error {
      color: var(--danger);
    }

    .status.ok {
      color: var(--ok);
    }

    .board-wrap {
      position: relative;
      width: min(100%, 420px);
    }

    #board {
      width: 100%;
      max-width: 420px;
    }

    #arrowLayer {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
      z-index: 2;
    }

    #arrowLayer text {
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      font-size: 12px;
      font-weight: 600;
      fill: var(--text);
      stroke: rgba(0, 0, 0, 0.55);
      stroke-width: 3px;
      paint-order: stroke fill;
      pointer-events: none;
    }

    #board .square-55d63 {
      position: relative;
      overflow: hidden;
    }

    #board .square-55d63::after {
      content: '';
      position: absolute;
      inset: 8px;
      border-radius: 10px;
      opacity: 0;
      transition: opacity 0.18s ease, transform 0.18s ease;
    }

    #board .highlight-last-from::after {
      background: rgba(56, 189, 248, 0.3);
      box-shadow: 0 0 18px rgba(56, 189, 248, 0.45);
      opacity: 1;
    }

    #board .highlight-last-to::after {
      background: rgba(94, 225, 163, 0.32);
      box-shadow: 0 0 18px rgba(94, 225, 163, 0.45);
      opacity: 1;
    }

    #board .highlight-next-from::after,
    #board .highlight-next-to::after {
      opacity: 1;
      border: 1px solid rgba(148, 163, 196, 0.4);
      transform: scale(0.95);
    }

    #board .highlight-next-from::after {
      background: rgba(250, 204, 21, 0.18);
      box-shadow: 0 0 14px rgba(250, 204, 21, 0.35);
    }

    #board .highlight-next-to::after {
      background: rgba(125, 196, 255, 0.18);
      box-shadow: 0 0 14px rgba(125, 196, 255, 0.32);
    }

    #arrowLayer text {
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, 'Segoe UI', sans-serif;
      font-size: 12px;
      font-weight: 600;
      fill: var(--text);
      stroke: rgba(0, 0, 0, 0.55);
      stroke-width: 3px;
      paint-order: stroke fill;
      pointer-events: none;
    }

    .kv {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 6px 10px;
      font-size: 14px;
    }

    .kv div:nth-child(odd) {
      color: var(--muted);
    }

    .muted {
      color: var(--muted);
    }

    .moves {
      display: grid;
      grid-template-columns: 44px 1fr 1fr;
      gap: 8px 12px;
      font-size: 14px;
    }

    .mv {
      padding: 8px 12px;
      border-radius: 12px;
      cursor: pointer;
      background: rgba(125, 196, 255, 0.08);
      transition: background 0.15s ease, transform 0.12s ease;
      display: flex;
      flex-direction: column;
      gap: 4px;
      position: relative;
      border: 1px solid transparent;
    }

    .mv.empty {
      opacity: 0.4;
      cursor: default;
    }

    [data-theme="light"] .mv {
      background: rgba(37, 99, 235, 0.06);
    }

    .mv:hover {
      background: rgba(125, 196, 255, 0.18);
    }

    .mv.active {
      background: rgba(125, 196, 255, 0.28);
      border-color: rgba(125, 196, 255, 0.4);
      box-shadow: 0 10px 25px rgba(18, 24, 46, 0.25);
    }

    .mv-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .mv-san {
      font-weight: 600;
      letter-spacing: 0.2px;
    }

    .mv-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .mv-eval {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
    }

    .mv-loss {
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
    }

    .mv-loss.loss {
      color: var(--danger);
    }

    .mv-loss.gain {
      color: var(--ok);
    }

    .mv-badge {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(125, 196, 255, 0.16);
      color: var(--badge-best);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .mv-badge img {
      width: 16px;
      height: 16px;
      object-fit: contain;
    }

    .mv-badge[data-grade="Brilliant"] {
      background: rgba(234, 179, 8, 0.18);
      color: var(--badge-brilliant);
    }

    .mv-badge[data-grade="Great"] {
      background: rgba(59, 130, 246, 0.18);
      color: var(--badge-best);
    }

    .mv-badge[data-grade="Best"] {
      background: rgba(59, 130, 246, 0.18);
      color: var(--badge-best);
    }

    .mv-badge[data-grade="Excellent"] {
      background: rgba(74, 222, 128, 0.18);
      color: var(--badge-excellent);
    }

    .mv-badge[data-grade="Good"] {
      background: rgba(168, 85, 247, 0.18);
      color: var(--badge-good);
    }

    .mv-badge[data-grade="Inaccuracy"] {
      background: rgba(249, 115, 22, 0.18);
      color: var(--badge-inaccuracy);
    }

    .mv-badge[data-grade="Mistake"] {
      background: rgba(251, 113, 133, 0.18);
      color: var(--badge-mistake);
    }

    .mv-badge[data-grade="Blunder"] {
      background: rgba(239, 68, 68, 0.18);
      color: var(--badge-blunder);
    }

    .mv-badge[data-grade="Missed Win"] {
      background: rgba(249, 115, 22, 0.18);
      color: var(--badge-inaccuracy);
    }

    .pv-list {
      display: grid;
      gap: 8px;
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 13px;
    }

    .pv {
      display: grid;
      grid-template-columns: 26px auto auto;
      gap: 8px;
      align-items: center;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
    }

    .pv:nth-child(1) {
      background: rgba(63, 208, 134, 0.12);
      box-shadow: 0 0 0 1px rgba(63, 208, 134, 0.35);
    }

    .pv:nth-child(2) {
      background: rgba(112, 167, 255, 0.12);
      box-shadow: 0 0 0 1px rgba(112, 167, 255, 0.35);
    }

    .pv:nth-child(3) {
      background: rgba(255, 200, 103, 0.12);
      box-shadow: 0 0 0 1px rgba(255, 200, 103, 0.35);
    }

    .pv .rank {
      font-weight: 700;
    }

    .pv .move {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .pv .eval {
      color: var(--muted);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .board-eval-wrap {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 18px;
      align-items: stretch;
    }

    @media (max-width:640px) {
      .board-eval-wrap {
        grid-template-columns: 1fr;
      }

      .eval-column {
        order: -1;
      }

      .eval-column .eval-bar {
        height: min(220px, 60vw) !important;
        width: 24px;
      }

      .eval-scale {
        flex-direction: row;
        justify-content: space-between;
        margin-top: 0;
        width: 100%;
      }
    }

    .eval-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .eval-bar {
      position: relative;
      width: 26px;
      border-radius: 18px;
      background: rgba(15, 23, 42, 0.35);
      border: 1px solid var(--eval-border);
      overflow: hidden;
      min-height: 320px;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }

    .eval-fill {
      position: absolute;
      left: 0;
      right: 0;
      transition: height 0.18s ease;
    }

    .eval-fill.eval-black {
      top: 0;
      background: linear-gradient(to bottom, rgba(17, 24, 39, 0.95), rgba(17, 24, 39, 0.75));
    }

    .eval-fill.eval-white {
      bottom: 0;
      background: linear-gradient(to top, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.78));
    }

    .eval-zero-line {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--eval-zero);
      z-index: 1;
    }

    .eval-pointer {
      position: absolute;
      left: calc(100% + 14px);
      transform: translateY(-50%);
      background: var(--panel);
      color: var(--text);
      font-family: 'JetBrains Mono', 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: 12px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
      transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
      z-index: 2;
      min-width: 54px;
      text-align: center;
    }

    .eval-pointer::before {
      content: '';
      position: absolute;
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      border: 6px solid transparent;
      border-right-color: var(--panel);
    }

    .eval-pointer.adv-white {
      background: linear-gradient(135deg, #fef9c3, #fde68a);
      color: #92400e;
    }

    .eval-pointer.adv-white::before {
      border-right-color: #fde68a;
    }

    .eval-pointer.adv-black {
      background: linear-gradient(135deg, #1f2937, #111827);
      color: #e5e7eb;
    }

    .eval-pointer.adv-black::before {
      border-right-color: #1f2937;
    }

    .eval-scale {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
      gap: 4px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
    }
  </style>
</head>

<body>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
    <h1>Lichess PGN Analyzer</h1>
    <button id="themeToggle" class="secondary" style="padding: 8px 12px; font-size: 14px;">🌙 Dark</button>
  </div>
  <div class="layout">
    <div class="card">
      <h2>Load game</h2>
      <div class="load-controls">
        <div class="input-switch">
          <select id="inputType">
            <option value="pgn">Paste PGN</option>
            <option value="lichess">Lichess URL / ID</option>
            <option value="fen">FEN</option>
          </select>
          <textarea id="gameInput" class="game-input" placeholder="Paste a PGN" autocomplete="off" spellcheck="false"></textarea>
        </div>
        <button id="loadBtn">Load</button>
      </div>
      <div class="hint">Tip: run from http://localhost (e.g. python -m http.server). file:// may block network requests.</div>
      <div id="loadStatus" class="status"></div>

      <h2>Board</h2>
      <div class="board-eval-wrap">
        <div class="eval-column">
          <div class="eval-bar" id="evalBar">
            <div class="eval-fill eval-black" id="evalBlackFill"></div>
            <div class="eval-fill eval-white" id="evalWhiteFill"></div>
            <div class="eval-zero-line"></div>
            <div class="eval-pointer" id="evalPointer">
              <span class="eval-value" id="evalValue">0.00</span>
            </div>
          </div>
          <div class="eval-scale">
            <span>Black</span>
            <span>White</span>
          </div>
        </div>
        <div class="board-wrap">
          <div id="board"></div>
          <svg id="arrowLayer" viewBox="0 0 8 8" preserveAspectRatio="none"></svg>
        </div>
      </div>

      <div class="material-panel">
        <div class="material-header">Material balance</div>
        <div class="material-row" data-side="white">
          <div class="material-side">
            <span class="material-side-label">White</span>
            <div class="material-icons" id="materialWhiteIcons"></div>
          </div>
          <span class="material-score" id="materialWhiteScore">0</span>
        </div>
        <div class="material-row" data-side="black">
          <div class="material-side">
            <span class="material-side-label">Black</span>
            <div class="material-icons" id="materialBlackIcons"></div>
          </div>
          <span class="material-score" id="materialBlackScore">0</span>
        </div>
      </div>

      <label class="toggle-row">
        <input type="checkbox" id="toggleArrowRatings" checked>
        <span>Show rating delta on arrows</span>
      </label>

      <div class="row" style="margin-top:14px; align-items:center;">
        <button id="firstBtn" class="secondary">⏮ First</button>
        <button id="prevBtn" class="secondary">◀ Prev</button>
        <button id="nextBtn">Next ▶</button>
        <button id="lastBtn">Last ⏭</button>
        <button id="flipBtn" class="secondary">Flip</button>
      </div>
      <div class="row" style="margin-top:12px; align-items:center;">
        <label style="font-size:13px; color:var(--muted);">Engine: time (ms)</label>
        <input id="timeMs" type="number" min="100" max="10000" step="100" value="1500" style="width:120px;" />
        <label style="font-size:13px; color:var(--muted);">Depth</label>
        <input id="depth" type="number" min="1" max="40" step="1" value="20" style="width:100px;" />
      </div>
      <div id="navStatus" class="status"></div>
    </div>

    <div class="card">
      <h2>Game info</h2>
      <div class="kv" id="tagBox">
        <div>White</div>
        <div id="tagWhite">—</div>
        <div>Black</div>
        <div id="tagBlack">—</div>
        <div>Event</div>
        <div id="tagEvent">—</div>
        <div>Site</div>
        <div id="tagSite">—</div>
        <div>Date</div>
        <div id="tagDate">—</div>
        <div>Result</div>
        <div id="tagResult">—</div>
        <div>Opening</div>
        <div id="tagOpening">—</div>
      </div>

      <div class="rating-guess">
        <button id="guessEloBtn" class="secondary">Guess player ratings</button>
        <div class="rating-guess-values">
          <span>White: <span id="whiteEloGuess">—</span></span>
          <span>Black: <span id="blackEloGuess">—</span></span>
        </div>
      </div>

      <h2 style="margin-top:22px;">Engine suggestions <span style="font-size:12px; font-weight:400; color:var(--muted);">(eval ± rating change vs best)</span></h2>
      <div class="pv-list">
        <div class="pv"><span class="rank">1</span><span class="move" id="pv1">—</span><span class="eval"
            id="ev1"></span></div>
        <div class="pv"><span class="rank">2</span><span class="move" id="pv2">—</span><span class="eval"
            id="ev2"></span></div>
        <div class="pv"><span class="rank">3</span><span class="move" id="pv3">—</span><span class="eval"
            id="ev3"></span></div>
        <div id="engStatus" class="status"></div>
      </div>

      <h2 style="margin-top:22px;">Moves</h2>
      <div id="moves" class="moves"></div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script type="module">
    import { Chess } from './chess.js';
    (function () {
      const byId = (id) => document.getElementById(id);
      const START_FEN = new Chess().fen();
      const state = {
        board: null,
        orientation: 'white',
        game: new Chess(),
        fullGame: null,
        verboseHistory: [],
        initialFen: START_FEN,
        initialPositionKey: 'start',
        headers: {},
        ratingGuess: {
          white: null,
          black: null
        },
        lastHighlightedMove: null,
        currentSource: null,
        ply: 0,
        engine: null,
        engineReady: false,
        engineConfigured: false,
        engineVersion: 'unknown',
        pendingAnalysis: null,
        multiPv: new Map(),
        bestEvalByPly: [],
        settings: {
          showArrowRatings: true
        }
      };

      const INPUT_TYPES = {
        PGN: 'pgn',
        LICHESS: 'lichess',
        FEN: 'fen'
      };

      const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9 };
      const PIECE_NAMES = { p: 'Pawn', n: 'Knight', b: 'Bishop', r: 'Rook', q: 'Queen' };

      const MATERIAL_ICONS = {
        white: {
          p: 'chesspieces/wikipedia/bP.png',
          n: 'chesspieces/wikipedia/bN.png',
          b: 'chesspieces/wikipedia/bB.png',
          r: 'chesspieces/wikipedia/bR.png',
          q: 'chesspieces/wikipedia/bQ.png'
        },
        black: {
          p: 'chesspieces/wikipedia/wP.png',
          n: 'chesspieces/wikipedia/wN.png',
          b: 'chesspieces/wikipedia/wB.png',
          r: 'chesspieces/wikipedia/wR.png',
          q: 'chesspieces/wikipedia/wQ.png'
        }
      };

      const CLASSIFICATION_ICONS = {
        'Brilliant': 'brilliant.png',
        'Great': 'great.png',
        'Best': 'best.png',
        'Excellent': 'excellent.png',
        'Good': 'good.png',
        'Inaccuracy': 'inaccuracy.png',
        'Mistake': 'mistake.png',
        'Blunder': 'blunder.png',
        'Missed Win': 'miss.png'
      };

      const ELO_PER_PAWN = 60;
      const MAX_CP = 4000;

      function mateToCp(mate) {
        const base = 10000;
        return mate > 0 ? base - mate * 100 : -base - mate * 100;
      }

      function clampCp(cp) {
        return Math.max(-MAX_CP, Math.min(MAX_CP, cp));
      }

      function formatRatingDelta(value) {
        if (typeof value !== 'number' || Number.isNaN(value)) return 'Δ —';
        if (value === 0) return 'Δ 0';
        const sign = value > 0 ? '+' : '';
        return `Δ ${sign}${value}`;
      }

      function formatEvalDisplay(entry) {
        if (!entry) return '—';
        if (entry.mate !== undefined && entry.mate !== null) {
          return `#${entry.mate}`;
        }
        if (typeof entry.cp === 'number') {
          return `${entry.cp >= 0 ? '+' : ''}${(entry.cp / 100).toFixed(2)}`;
        }
        return entry.eval || '—';
      }

      function squareToDisplayCoords(square) {
        if (!square || square.length < 2) return null;
        const file = square.charCodeAt(0) - 97;
        const rank = parseInt(square[1], 10) - 1;
        if (file < 0 || file > 7 || Number.isNaN(rank) || rank < 0 || rank > 7) {
          return null;
        }
        let col = file;
        let row = 7 - rank;
        if (state.orientation === 'black') {
          col = 7 - col;
          row = 7 - row;
        }
        return { col, row };
      }

      function refreshBoardHighlights() {
        const boardEl = byId('board');
        if (!boardEl) return;
        const classes = ['highlight-last-from', 'highlight-last-to', 'highlight-next-from', 'highlight-next-to'];
        boardEl.querySelectorAll('.square-55d63').forEach((el) => {
          classes.forEach(cls => el.classList.remove(cls));
        });

        const highlightSquare = (square, className) => {
          if (!square) return;
          const target = boardEl.querySelector(`.square-55d63[data-square="${square}"]`);
          if (target) target.classList.add(className);
        };

        if (state.lastHighlightedMove) {
          highlightSquare(state.lastHighlightedMove.from, 'highlight-last-from');
          highlightSquare(state.lastHighlightedMove.to, 'highlight-last-to');
        }

        const upcoming = state.verboseHistory[state.ply] || null;
        if (upcoming) {
          highlightSquare(upcoming.from, 'highlight-next-from');
          highlightSquare(upcoming.to, 'highlight-next-to');
        }
      }

      function formatMaterialScore(score) {
        if (!Number.isFinite(score) || score === 0) return '0';
        return score > 0 ? `+${score}` : `${score}`;
      }

      function updateMaterialBalance() {
        const whiteIcons = byId('materialWhiteIcons');
        const blackIcons = byId('materialBlackIcons');
        const whiteScoreEl = byId('materialWhiteScore');
        const blackScoreEl = byId('materialBlackScore');
        if (!whiteIcons || !blackIcons || !whiteScoreEl || !blackScoreEl) return;

        whiteIcons.innerHTML = '';
        blackIcons.innerHTML = '';

        const counts = {
          w: { p: 0, n: 0, b: 0, r: 0, q: 0 },
          b: { p: 0, n: 0, b: 0, r: 0, q: 0 }
        };

        if (state.game && typeof state.game.board === 'function') {
          const board = state.game.board();
          board.forEach(row => {
            row.forEach(piece => {
              if (!piece || piece.type === 'k') return;
              counts[piece.color][piece.type] += 1;
            });
          });
        }

        let whiteMaterial = 0;
        Object.keys(PIECE_VALUES).forEach((type) => {
          const diff = counts.w[type] - counts.b[type];
          whiteMaterial += diff * PIECE_VALUES[type];
          if (diff > 0) {
            for (let i = 0; i < diff; i++) {
              const img = document.createElement('img');
              img.src = MATERIAL_ICONS.white[type];
              img.alt = `${PIECE_NAMES[type] || type.toUpperCase()} captured by White`;
              whiteIcons.appendChild(img);
            }
          } else if (diff < 0) {
            for (let i = 0; i < Math.abs(diff); i++) {
              const img = document.createElement('img');
              img.src = MATERIAL_ICONS.black[type];
              img.alt = `${PIECE_NAMES[type] || type.toUpperCase()} captured by Black`;
              blackIcons.appendChild(img);
            }
          }
        });

        if (!whiteIcons.childElementCount) {
          const span = document.createElement('span');
          span.className = 'muted';
          span.textContent = '—';
          whiteIcons.appendChild(span);
        }

        if (!blackIcons.childElementCount) {
          const span = document.createElement('span');
          span.className = 'muted';
          span.textContent = '—';
          blackIcons.appendChild(span);
        }

        const whiteScore = Math.round(whiteMaterial);
        const blackScore = -whiteScore;
        whiteScoreEl.textContent = formatMaterialScore(whiteScore);
        blackScoreEl.textContent = formatMaterialScore(blackScore);
      }

      function updateEloGuessDisplay() {
        const whiteEl = byId('whiteEloGuess');
        const blackEl = byId('blackEloGuess');
        if (!whiteEl || !blackEl) return;

        const applyGuess = (el, guess) => {
          if (!guess || !Number.isFinite(guess.value)) {
            el.textContent = '—';
            el.removeAttribute('title');
            return;
          }
          const prefix = guess.source === 'tag' ? '' : '≈ ';
          el.textContent = `${prefix}${guess.value}`;
          if (guess.description) {
            el.title = guess.description;
          } else {
            el.removeAttribute('title');
          }
        };

        applyGuess(whiteEl, state.ratingGuess.white);
        applyGuess(blackEl, state.ratingGuess.black);
      }

      function clearRatingGuess() {
        state.ratingGuess = { white: null, black: null };
        updateEloGuessDisplay();
      }

      function estimateRatingFromGame(color) {
        const headerKey = color === 'white' ? 'WhiteElo' : 'BlackElo';
        const rated = parseInt(state.headers?.[headerKey], 10);
        if (Number.isFinite(rated)) {
          return {
            value: rated,
            source: 'tag',
            description: 'Provided by PGN tags'
          };
        }

        const moves = state.verboseHistory.filter((_, idx) => idx % 2 === (color === 'white' ? 0 : 1));
        const annotations = { brilliant: 0, good: 0, mistake: 0, blunder: 0 };
        moves.forEach((mv) => {
          if (!mv || !mv.san) return;
          const san = mv.san;
          if (san.includes('!!')) annotations.brilliant += 1;
          else if (san.includes('!')) annotations.good += 1;
          if (san.includes('??')) annotations.blunder += 1;
          else if (san.includes('?')) annotations.mistake += 1;
        });

        let rating = 1100 + Math.min(moves.length, 80) * 6;
        rating += annotations.brilliant * 25 + annotations.good * 10;
        rating -= annotations.mistake * 25 + annotations.blunder * 45;

        const result = state.headers?.Result || '';
        if ((color === 'white' && result === '1-0') || (color === 'black' && result === '0-1')) {
          rating += 30;
        } else if (result === '1/2-1/2') {
          rating += 10;
        }

        const checkmates = moves.filter(mv => mv && typeof mv.san === 'string' && mv.san.includes('#')).length;
        rating += checkmates * 15;

        const evalMoves = moves.filter(mv => mv && typeof mv.lossCp === 'number');
        if (evalMoves.length) {
          const avgLoss = evalMoves.reduce((sum, mv) => sum + Math.max(0, mv.lossCp), 0) / evalMoves.length;
          const pawnLoss = avgLoss / 100;
          rating += Math.max(-240, Math.min(240, (3 - pawnLoss) * 60));
        }

        const termination = state.headers?.Termination || '';
        if (/time forfeit/i.test(termination)) {
          rating -= 20;
        }

        rating = Math.round(Math.max(600, Math.min(2800, rating)));
        return {
          value: rating,
          source: 'estimate',
          description: 'Heuristic estimate from move annotations and engine loss'
        };
      }

      function guessPlayerRatings() {
        state.ratingGuess = {
          white: estimateRatingFromGame('white'),
          black: estimateRatingFromGame('black')
        };
        updateEloGuessDisplay();
      }

      function gradeMove(lossPawns, whiteBefore, whiteAfter, moverIsWhite) {
        if (lossPawns <= -1.5) return 'Brilliant';
        if (lossPawns <= -0.75) return 'Great';
        if (Math.abs(lossPawns) <= 0.05) return 'Best';
        if (lossPawns <= 0.2) return 'Excellent';
        if (lossPawns <= 0.5) return 'Good';
        if (lossPawns <= 1.0) return 'Inaccuracy';
        if (lossPawns <= 2.5) return 'Mistake';

        const winningThreshold = 250; // centipawns
        const safeThreshold = 100;
        if (moverIsWhite) {
          if (whiteBefore >= winningThreshold && whiteAfter <= safeThreshold) {
            return 'Missed Win';
          }
        } else {
          if (whiteBefore <= -winningThreshold && whiteAfter >= -safeThreshold) {
            return 'Missed Win';
          }
        }
        return 'Blunder';
      }

      function computeMoveImpact(plyIndex, currentEntry) {
        if (!currentEntry) return null;
        const prevCp = state.bestEvalByPly[plyIndex];
        const currentCp = typeof currentEntry.cp === 'number'
          ? currentEntry.cp
          : typeof currentEntry.mate === 'number'
            ? mateToCp(currentEntry.mate)
            : null;
        if (prevCp === null || prevCp === undefined || currentCp === null) {
          return null;
        }

        const moverIsWhite = plyIndex % 2 === 0;
        const whiteBefore = moverIsWhite ? prevCp : -prevCp;
        const whiteAfter = (plyIndex + 1) % 2 === 0 ? currentCp : -currentCp;
        const lossCp = moverIsWhite
          ? whiteBefore - whiteAfter
          : whiteAfter - whiteBefore;

        const lossPawns = lossCp / 100;
        const classification = gradeMove(lossPawns, whiteBefore, whiteAfter, moverIsWhite);

        return {
          lossCp: Math.round(lossCp),
          classification
        };
      }

      function loadSettings() {
        try {
          const raw = localStorage.getItem('analyzerSettings');
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (typeof parsed.showArrowRatings === 'boolean') {
            state.settings.showArrowRatings = parsed.showArrowRatings;
          }
        } catch (err) {
          console.warn('Failed to load settings', err);
        }
      }

      function saveSettings() {
        try {
          localStorage.setItem('analyzerSettings', JSON.stringify(state.settings));
        } catch (err) {
          console.warn('Failed to save settings', err);
        }
      }

      function applySettingsToUi() {
        const toggle = byId('toggleArrowRatings');
        if (toggle) {
          toggle.checked = !!state.settings.showArrowRatings;
        }
      }

      function initBoard() {
        const box = byId('board');
        state.board = Chessboard('board', {
          position: 'start', draggable: false,
          pieceTheme: 'chesspieces/wikipedia/{piece}.png'
        });
        syncArrowLayer();
        const handleResize = () => { state.board.resize(); syncArrowLayer(); };
        window.addEventListener('resize', handleResize);
      }

      function syncArrowLayer() {
        const boardEl = byId('board');
        const svg = byId('arrowLayer');
        if (!boardEl || !svg) return;
        const rect = boardEl.getBoundingClientRect();
        svg.setAttribute('viewBox', '0 0 8 8');
        svg.setAttribute('width', rect.width);
        svg.setAttribute('height', rect.width);
        const evalBar = byId('evalBar');
        if (evalBar) {
          evalBar.style.height = `${rect.width}px`;
        }
      }

      function setStatus(id, msg, type) {
        const el = byId(id); if (!el) return;
        el.textContent = msg || '';
        el.classList.remove('error', 'ok');
        if (type === 'error') el.classList.add('error');
        if (type === 'ok') el.classList.add('ok');
      }

      function extractGameId(input) {
        if (!input) return '';
        try {
          const url = new URL(input.trim());
          return url.pathname.split('/').filter(Boolean)[0] || '';
        } catch (e) {
          return input.trim();
        }
      }

      async function fetchPGN(input) {
        const id = extractGameId(input);
        if (!id) throw new Error('Please provide a Lichess URL or game ID.');
        const params = new URLSearchParams({ moves: '1', tags: '1', clocks: '1', opening: '1', evals: '0', literate: '0' });
        const headers = { 'Accept': 'application/x-chess-pgn' };
        const res = await fetch(`https://lichess.org/game/export/${id}.pgn?${params.toString()}`, { headers });
        if (!res.ok) throw new Error(`HTTP ${res.status} – ${res.statusText}`);
        return res.text();
      }

      function populateHeaders(headers) {
        const safe = headers || {};
        state.headers = safe;
        byId('tagWhite').textContent = safe.White || '—';
        byId('tagBlack').textContent = safe.Black || '—';
        byId('tagEvent').textContent = safe.Event || '—';
        byId('tagSite').textContent = safe.Site || '—';
        byId('tagDate').textContent = safe.Date || '—';
        byId('tagResult').textContent = safe.Result || '—';
        byId('tagOpening').textContent = safe.Opening || safe.ECO || '—';
      }

      function parseHeaders(pgn) {
        const out = {};
        const regex = /\[(\w+)\s+"([^\"]*)"\]/g;
        let match;
        while ((match = regex.exec(pgn)) !== null) {
          out[match[1]] = match[2];
        }
        return out;
      }

      function buildHistory(game, initialFen) {
        const verbose = [];
        const startFen = initialFen || START_FEN;
        const temp = new Chess(startFen);
        const moves = game.history({ verbose: true });
        for (let idx = 0; idx < moves.length; idx++) {
          const mv = moves[idx];
          const played = temp.move(mv);
          if (!played) continue;
          verbose.push({
            ...played,
            ply: idx + 1,
            fen: temp.fen(),
            eval: null,
            evalCp: null,
            evalMate: null,
            classification: null,
            lossCp: null
          });
        }
        return verbose;
      }

      function determineInitialFen(headers) {
        if (headers && headers.SetUp === '1' && headers.FEN) {
          return headers.FEN;
        }
        return START_FEN;
      }

      function determineInitialPositionKey(initialFen) {
        return !initialFen || initialFen === START_FEN ? 'start' : initialFen;
      }

      function resetCurrentGame() {
        state.game = new Chess(state.initialFen || START_FEN);
      }

      function getFenForPly(ply) {
        if (ply <= 0) {
          return state.initialFen || START_FEN;
        }
        const entry = state.verboseHistory[ply - 1];
        return entry ? entry.fen : (state.initialFen || START_FEN);
      }

      function renderMoves() {
        const container = byId('moves');
        container.innerHTML = '';
        const history = state.verboseHistory;
        for (let i = 0; i < history.length; i += 2) {
          const moveNo = document.createElement('div');
          moveNo.textContent = `${Math.floor(i / 2) + 1}.`;
          moveNo.className = 'muted';
          container.appendChild(moveNo);

          container.appendChild(createMoveCell(history[i], i));
          container.appendChild(createMoveCell(history[i + 1], i + 1));
        }
        if (!history.length) {
          const placeholder = document.createElement('div');
          placeholder.className = 'muted';
          placeholder.textContent = 'No moves available for this position.';
          container.appendChild(placeholder);
        }
        highlightActive();
      }

      function createMoveCell(move, idx) {
        const cell = document.createElement('div');
        cell.className = 'mv';
        if (!move) {
          cell.classList.add('empty');
          return cell;
        }

        const header = document.createElement('div');
        header.className = 'mv-header';
        const san = document.createElement('span');
        san.className = 'mv-san';
        san.textContent = move.san || '';
        header.appendChild(san);

        if (move.classification) {
          const badge = document.createElement('span');
          badge.className = 'mv-badge';
          badge.dataset.grade = move.classification;
          const iconFile = CLASSIFICATION_ICONS[move.classification];
          if (iconFile) {
            const img = document.createElement('img');
            img.src = `move-classifications/${iconFile}`;
            img.alt = move.classification;
            badge.appendChild(img);
          }
          const label = document.createElement('span');
          label.textContent = move.classification;
          badge.appendChild(label);
          header.appendChild(badge);
        }

        cell.appendChild(header);

        const meta = document.createElement('div');
        meta.className = 'mv-meta';
        const evalSpan = document.createElement('span');
        evalSpan.className = 'mv-eval';
        evalSpan.textContent = move.eval && move.eval.trim() ? move.eval : '—';
        meta.appendChild(evalSpan);

        const lossSpan = document.createElement('span');
        lossSpan.className = 'mv-loss';
        if (typeof move.lossCp === 'number') {
          const delta = -move.lossCp / 100;
          if (delta > 0.01) {
            lossSpan.textContent = `Δ +${delta.toFixed(2)}`;
            lossSpan.classList.add('gain');
          } else if (delta < -0.01) {
            lossSpan.textContent = `Δ ${delta.toFixed(2)}`;
            lossSpan.classList.add('loss');
          } else {
            lossSpan.textContent = 'Δ 0.00';
          }
        } else {
          lossSpan.textContent = 'Δ —';
        }
        meta.appendChild(lossSpan);

        cell.appendChild(meta);

        cell.addEventListener('click', () => goToPly(idx + 1));
        return cell;
      }

      function highlightActive() {
        Array.from(document.querySelectorAll('.mv')).forEach(el => el.classList.remove('active'));
        const idx = state.ply - 1;
        if (idx < 0) return;
        const row = Math.floor(idx / 2);
        const col = idx % 2;
        const container = byId('moves');
        const cell = container.children[row * 3 + 1 + col];
        if (cell) cell.classList.add('active');
      }

      function goToPly(ply) {
        const max = state.verboseHistory.length;
        state.ply = Math.max(0, Math.min(max, ply));
        resetCurrentGame();

        if (state.board) {
          if (state.ply === 0) {
            state.board.position(state.initialPositionKey);
          } else {
            for (let i = 0; i < state.ply; i++) {
              const mv = state.verboseHistory[i];
              state.game.move({ from: mv.from, to: mv.to, promotion: mv.promotion });
            }
            state.board.position(state.game.fen());
          }
        }

        updateMaterialBalance();
        state.lastHighlightedMove = state.ply > 0 ? state.verboseHistory[state.ply - 1] : null;
        refreshBoardHighlights();
        highlightActive();
        analyzeCurrent();

        // Update evaluation bar with stored evaluation for this position
        if (state.ply > 0) {
          const last = state.verboseHistory[state.ply - 1];
          const entry = last && (last.eval || typeof last.evalCp === 'number' || typeof last.evalMate === 'number')
            ? { eval: last.eval, cp: last.evalCp, mate: last.evalMate ?? null }
            : null;
          updateEvalBar(entry, { ply: state.ply });
        } else {
          updateEvalBar(null); // Reset to neutral
        }

        setStatus('navStatus', `Move ${state.ply} / ${max}`);
        setUrlParam('ply', state.ply > 0 ? state.ply : null);
      }

      function drawArrows(list) {
        const svg = byId('arrowLayer');
        if (!svg) return;
        while (svg.firstChild) svg.removeChild(svg.firstChild);
        if (!list || !list.length) return;

        const squareCenter = (sq) => {
          const coords = squareToDisplayCoords(sq);
          if (!coords) return null;
          return {
            x: coords.col + 0.5,
            y: coords.row + 0.5
          };
        };

        const palette = [
          { color: '#22c55e', width: 0.3 },
          { color: '#0ea5e9', width: 0.27 },
          { color: '#f97316', width: 0.25 }
        ];

        const MIN_ARROW_ALPHA = 0.25;
        const MAX_ARROW_ALPHA = 0.8;

        const getScore = (entry) => {
          if (!entry) return null;
          if (typeof entry.cp === 'number') return entry.cp;
          if (typeof entry.mate === 'number') return mateToCp(entry.mate);
          return null;
        };

        const scored = list.slice(0, 3).map((entry) => ({
          entry,
          score: getScore(entry)
        }));

        if (!scored.length) return;

        const bestScore = scored[0].score;
        const scoreDiffs = scored.map(({ score }) => {
          if (bestScore === null || score === null) return null;
          return Math.abs(score - bestScore);
        });
        const maxDiff = scoreDiffs.reduce((acc, diff) => (diff !== null ? Math.max(acc, diff) : acc), 0);

        scored.forEach(({ entry }, i) => {
          if (!entry || !entry.uci) return;
          const from = squareCenter(entry.uci.slice(0, 2));
          const to = squareCenter(entry.uci.slice(2, 4));
          if (!from || !to) return;

          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const len = Math.hypot(dx, dy);
          if (len < 1e-3) return;

          const nx = dx / len;
          const ny = dy / len;
          const px = -ny;
          const py = nx;

          const headLength = Math.min(Math.max(len * 0.45, 0.35), len - 0.1);
          const tailPadding = Math.min(Math.max(len * 0.2, 0.25), len - headLength - 0.05);
          if (headLength <= 0 || tailPadding < 0) return;

          const tipX = to.x;
          const tipY = to.y;
          const baseX = tipX - nx * headLength;
          const baseY = tipY - ny * headLength;
          const startX = from.x + nx * tailPadding;
          const startY = from.y + ny * tailPadding;

          let opacity = 1;
          if (i > 0) {
            const diff = scoreDiffs[i];
            if (diff === null || maxDiff === 0) {
              opacity = MAX_ARROW_ALPHA;
            } else {
              const closeness = 1 - diff / maxDiff;
              opacity = MIN_ARROW_ALPHA + Math.max(0, Math.min(1, closeness)) * (MAX_ARROW_ALPHA - MIN_ARROW_ALPHA);
            }
          }

          const paletteEntry = palette[i] || palette[palette.length - 1];

          const shaft = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          shaft.setAttribute('x1', startX);
          shaft.setAttribute('y1', startY);
          shaft.setAttribute('x2', baseX);
          shaft.setAttribute('y2', baseY);
          shaft.setAttribute('stroke', paletteEntry.color);
          shaft.setAttribute('stroke-width', paletteEntry.width);
          shaft.setAttribute('stroke-linecap', 'round');
          shaft.setAttribute('opacity', opacity);
          svg.appendChild(shaft);

          const headWidth = headLength * 0.55;
          const leftX = baseX + px * headWidth;
          const leftY = baseY + py * headWidth;
          const rightX = baseX - px * headWidth;
          const rightY = baseY - py * headWidth;

          const head = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          head.setAttribute('d', `M ${tipX} ${tipY} L ${leftX} ${leftY} L ${rightX} ${rightY} Z`);
          head.setAttribute('fill', paletteEntry.color);
          head.setAttribute('opacity', opacity);
          svg.appendChild(head);

          if (state.settings.showArrowRatings && typeof entry.ratingChange === 'number' && !Number.isNaN(entry.ratingChange)) {
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const labelAlong = Math.min(len - headLength * 0.5, Math.max(len * 0.55, headLength + 0.2));
            const labelPerp = 0.35;
            const tx = from.x + nx * labelAlong + px * labelPerp;
            const ty = from.y + ny * labelAlong + py * labelPerp;
            label.setAttribute('x', tx);
            label.setAttribute('y', ty);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('dominant-baseline', 'middle');
            label.setAttribute('fill', paletteEntry.color);
            label.setAttribute('opacity', Math.min(1, opacity + 0.1));
            label.textContent = formatRatingDelta(entry.ratingChange);
            svg.appendChild(label);
          }
        });
      }

      function uciToSan(fen, uci) {
        try {
          const game = new Chess(fen);
          const move = {
            from: uci.slice(0, 2),
            to: uci.slice(2, 4),
            promotion: uci.length > 4 ? uci[4] : undefined
          };
          const played = game.move(move);
          return played && played.san ? played.san : uci;
        } catch (e) {
          return uci;
        }
      }

      function updatePVDisplay(entries) {
        const ids = [1, 2, 3];

        if (!entries || entries.length === 0) {
          ids.forEach((idx) => {
            const moveEl = byId(`pv${idx}`);
            const evalEl = byId(`ev${idx}`);
            if (moveEl) moveEl.textContent = '—';
            if (evalEl) evalEl.textContent = '';
          });
          return;
        }

        const bestEntry = entries[0] || null;
        const bestCp = bestEntry
          ? (typeof bestEntry.cp === 'number'
            ? bestEntry.cp
            : typeof bestEntry.mate === 'number'
              ? mateToCp(bestEntry.mate)
              : null)
          : null;

        if (bestCp !== null) {
          state.bestEvalByPly[state.ply] = bestCp;
        }

        ids.forEach((idx, i) => {
          const moveEl = byId(`pv${idx}`);
          const evalEl = byId(`ev${idx}`);
          const entry = entries[i] || null;
          if (!moveEl || !evalEl) return;
          if (entry) {
            moveEl.textContent = entry.san || entry.uci;
            const evalText = entry.eval && entry.eval.trim() ? entry.eval : formatEvalDisplay(entry);

            const entryCp = typeof entry.cp === 'number'
              ? entry.cp
              : typeof entry.mate === 'number'
                ? mateToCp(entry.mate)
                : null;

            if (bestCp !== null && entryCp !== null) {
              const diffCp = entryCp - bestCp;
              const ratingChange = Math.round((diffCp / 100) * ELO_PER_PAWN);
              const clampedRating = Math.max(-600, Math.min(600, ratingChange));
              entry.ratingChange = clampedRating;
              if (Math.abs(clampedRating) >= 1) {
                const sign = clampedRating > 0 ? '+' : '';
                evalEl.textContent = `${evalText} (${sign}${clampedRating})`;
              } else {
                evalEl.textContent = evalText;
              }
            } else {
              entry.ratingChange = null;
              evalEl.textContent = evalText;
            }
          } else {
            if (moveEl) moveEl.textContent = '—';
            if (evalEl) evalEl.textContent = '';
          }
        });

        if (bestEntry) {
          updateEvalBar(bestEntry, { ply: state.ply });
        }
      }

      function updateEvalBar(entry, opts = {}) {
        const evalValueEl = byId('evalValue');
        const pointerEl = byId('evalPointer');
        const barEl = byId('evalBar');
        const whiteFill = byId('evalWhiteFill');
        const blackFill = byId('evalBlackFill');
        if (!evalValueEl || !pointerEl || !barEl) return;

        const setNeutralFill = () => {
          if (whiteFill) whiteFill.style.height = '50%';
          if (blackFill) blackFill.style.height = '50%';
        };

        if (!entry) {
          evalValueEl.textContent = '0.00';
          pointerEl.style.top = '50%';
          pointerEl.classList.remove('adv-white', 'adv-black');
          setNeutralFill();
          return;
        }

        const displayText = entry.eval && entry.eval.trim() ? entry.eval : formatEvalDisplay(entry);
        evalValueEl.textContent = displayText;

        const ply = typeof opts.ply === 'number' ? opts.ply : state.ply;

        let cpValue = null;
        if (typeof entry.cp === 'number') {
          cpValue = entry.cp;
        } else if (typeof entry.mate === 'number') {
          cpValue = mateToCp(entry.mate);
        } else if (entry.eval && entry.eval.startsWith('#')) {
          const mateVal = parseInt(entry.eval.substring(1), 10);
          if (!Number.isNaN(mateVal)) {
            cpValue = mateToCp(mateVal);
          }
        } else if (entry.eval) {
          const parsed = parseFloat(entry.eval);
          if (!Number.isNaN(parsed)) cpValue = parsed * 100;
        }

        if (cpValue === null) {
          pointerEl.style.top = '50%';
          pointerEl.classList.remove('adv-white', 'adv-black');
          setNeutralFill();
          return;
        }

        const cpWhite = ply % 2 === 0 ? cpValue : -cpValue;
        const clamped = clampCp(cpWhite);
        const percentWhite = (clamped + MAX_CP) / (2 * MAX_CP);
        const boundedWhite = Math.max(0, Math.min(1, percentWhite));
        pointerEl.style.top = `${(1 - boundedWhite) * 100}%`;
        if (whiteFill) whiteFill.style.height = `${boundedWhite * 100}%`;
        if (blackFill) blackFill.style.height = `${(1 - boundedWhite) * 100}%`;

        pointerEl.classList.remove('adv-white', 'adv-black');
        if (cpWhite > 80) {
          pointerEl.classList.add('adv-white');
        } else if (cpWhite < -80) {
          pointerEl.classList.add('adv-black');
        }
      }

      function ensureEngine() {
        if (state.engine) return;
        setStatus('engStatus', 'Loading engine…');
        let worker;
        let engineLabel = 'Stockfish';
        try {
          worker = new Worker('node_modules/stockfish/src/stockfish-17.1-lite-single-03e3232.js');
          engineLabel = 'Stockfish 17.1';
        } catch (e) {
          console.error('Failed to load Stockfish worker:', e);
          setStatus('engStatus', 'Failed to load Stockfish.', 'error');
          return;
        }
        if (!worker) {
          setStatus('engStatus', 'Failed to load Stockfish worker.', 'error');
          return;
        }
        state.engine = worker;
        state.engineReady = false;
        state.engineVersion = 'unknown';
        
        state.engine.onerror = (err) => {
          console.error('Stockfish worker error:', err);
          setStatus('engStatus', 'Engine error: ' + err.message, 'error');
        };
        
        state.engine.onmessage = (e) => {
          let line = typeof e.data === 'string' ? e.data : '';
          if (!line && e.data && typeof e.data === 'object') {
            line = e.data.data || e.data.text || '';
          }
          if (!line) {
            console.warn('Engine sent empty message:', e);
            return;
          }
          
          console.log('Engine:', line);
          
          // Detect version from id command response
          if (line.startsWith('id name')) {
            state.engineVersion = line.substring(8).trim();
            engineLabel = state.engineVersion;
          }
          
          if (line.startsWith('uciok')) {
            state.engineReady = true;
            console.log('Engine is ready, configuring options...');
            state.engine.postMessage('setoption name MultiPV value 3');
            state.engine.postMessage('setoption name Threads value 1');
            state.engine.postMessage('setoption name Ponder value false');
            state.engine.postMessage('isready');
            return;
          }

          if (line.startsWith('readyok')) {
            console.log('Engine confirmed ready');
            state.engineConfigured = true;
            setStatus('engStatus', `${engineLabel} ready`, 'ok');
            if (state.pendingAnalysis) {
              console.log('Running pending analysis...');
              analyzeCurrent();
            }
            return;
          }
          
          if (line.startsWith('info')) {
            handleInfo(line);
            return;
          }
          
          if (line.startsWith('bestmove')) {
            // Store the current position's evaluation in history
            if (state.ply > 0 && state.multiPv && state.multiPv.has(1)) {
              const bestMove = state.multiPv.get(1);
              const historyEntry = state.verboseHistory[state.ply - 1];
              if (bestMove && historyEntry) {
                const evalText = bestMove.eval && bestMove.eval.trim() ? bestMove.eval : formatEvalDisplay(bestMove);
                historyEntry.eval = evalText;
                historyEntry.evalCp = typeof bestMove.cp === 'number' ? bestMove.cp : null;
                historyEntry.evalMate = typeof bestMove.mate === 'number' ? bestMove.mate : null;
                const impact = computeMoveImpact(state.ply - 1, bestMove);
                if (impact) {
                  historyEntry.lossCp = impact.lossCp;
                  historyEntry.classification = impact.classification;
                } else {
                  historyEntry.lossCp = null;
                  historyEntry.classification = null;
                }
                renderMoves(); // Re-render to show the evaluation
                refreshBoardHighlights();
              }
            }
            setStatus('engStatus', `Analysis complete (${engineLabel})`);
          }
        };
        
        // Initialize UCI
        console.log('Sending UCI command to engine...');
        state.engine.postMessage('uci');
      }

      function handleInfo(line) {
        const multi = line.match(/\bmultipv (\d+)/);
        const pv = line.match(/\bpv ((?:[a-h][1-8]){2}[qrbn]?\b.*)/);
        const scoreMate = line.match(/\bscore mate (-?\d+)/);
        const scoreCp = line.match(/\bscore cp (-?\d+)/);
        if (!multi || !pv) return;
        const rank = parseInt(multi[1], 10);
        if (rank < 1 || rank > 3) return;
        const moves = pv[1].trim().split(/\s+/);
        let evalStr = '';
        let mateVal = null;
        let cpVal = null;
        if (scoreMate) {
          mateVal = parseInt(scoreMate[1], 10);
          evalStr = `#${mateVal}`;
          cpVal = mateToCp(mateVal);
        } else if (scoreCp) {
          cpVal = parseInt(scoreCp[1], 10);
          evalStr = `${cpVal >= 0 ? '+' : ''}${(cpVal / 100).toFixed(2)}`;
        }
        const entry = {
          rank,
          uci: moves[0],
          eval: evalStr,
          mate: mateVal,
          cp: cpVal
        };
        const baseFen = state.ply === 0 ? new Chess().fen() : state.verboseHistory[state.ply - 1].fen;
        entry.san = uciToSan(baseFen, entry.uci);
        state.multiPv = state.multiPv || new Map();
        state.multiPv.set(rank, entry);
        const list = [1, 2, 3].map(r => state.multiPv.get(r) || null);
        updatePVDisplay(list);
        drawArrows(list);
        setStatus('engStatus', `Analyzing… depth ${line.match(/\bdepth (\d+)/)?.[1] || ''}`);
      }

      function analyzeCurrent() {
        ensureEngine();
        if (!state.engineConfigured) {
          state.pendingAnalysis = true;
          setStatus('engStatus', 'Waiting for engine…');
          return;
        }

        state.pendingAnalysis = false;
        state.multiPv = new Map();
        drawArrows([]);
        updatePVDisplay([]);
        setStatus('engStatus', 'Analyzing…');

        const fen = getFenForPly(state.ply);

        // Stop any previous analysis
        state.engine.postMessage('stop');

        // Small delay to ensure stop is processed
        setTimeout(() => {
          state.engine.postMessage(`position fen ${fen}`);

          const depthVal = parseInt(byId('depth').value, 10);
          const timeVal = parseInt(byId('timeMs').value, 10) || 300;

          if (depthVal && depthVal > 0) {
            state.engine.postMessage(`go depth ${depthVal}`);
          } else {
            state.engine.postMessage(`go movetime ${timeVal}`);
          }
        }, 50);
      }

      function getUrlParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
      }

      function setUrlParam(name, value) {
        const url = new URL(window.location);
        if (value) {
          url.searchParams.set(name, value);
        } else {
          url.searchParams.delete(name);
        }
        window.history.replaceState({}, '', url);
      }

      function getInputType() {
        const select = byId('inputType');
        return select ? (select.value || INPUT_TYPES.PGN) : INPUT_TYPES.PGN;
      }

      function setInputType(type) {
        const select = byId('inputType');
        if (!select) return;
        const normalized = Object.values(INPUT_TYPES).includes(type) ? type : INPUT_TYPES.PGN;
        select.value = normalized;
        updateInputAppearance();
      }

      function getCurrentInputValue() {
        const textarea = byId('gameInput');
        return textarea ? textarea.value.trim() : '';
      }

      function setCurrentInputValue(value) {
        const textarea = byId('gameInput');
        if (textarea) textarea.value = value || '';
      }

      function updateInputAppearance() {
        const select = byId('inputType');
        const textarea = byId('gameInput');
        if (!select || !textarea) return;
        const type = select.value || INPUT_TYPES.PGN;
        textarea.classList.remove('compact');
        let placeholder = 'Paste a PGN';
        if (type === INPUT_TYPES.LICHESS) {
          placeholder = 'Paste a Lichess game URL or ID';
          textarea.classList.add('compact');
        } else if (type === INPUT_TYPES.FEN) {
          placeholder = 'Paste a FEN string';
          textarea.classList.add('compact');
        }
        textarea.placeholder = placeholder;
      }

      function updateQueryFromInput() {
        const type = getInputType();
        const value = getCurrentInputValue();
        const trimmedValue = value ? value.trim() : '';
        if (type === INPUT_TYPES.LICHESS) {
          const id = extractGameId(value);
          setUrlParam('game', id || null);
          setUrlParam('source', null);
        } else {
          setUrlParam('game', null);
          setUrlParam('source', trimmedValue ? trimmedValue : null);
        }
        setUrlParam('inputType', type === INPUT_TYPES.PGN ? null : type);
      }

      async function setupGameFromPgn(pgn, targetPly = null) {
        const raw = (pgn || '').trim();
        if (!raw) throw new Error('PGN data is empty.');
        const fullGame = new Chess();
        const loaded = fullGame.loadPgn(raw, { sloppy: true });
        if (!loaded) throw new Error('Invalid PGN data.');

        state.fullGame = fullGame;
        const headers = parseHeaders(raw);
        populateHeaders(headers);

        state.initialFen = determineInitialFen(headers);
        state.initialPositionKey = determineInitialPositionKey(state.initialFen);
        state.verboseHistory = buildHistory(fullGame, state.initialFen);
        state.bestEvalByPly = [];
        state.multiPv = new Map();
        state.ply = 0;
        state.lastHighlightedMove = null;
        resetCurrentGame();

        if (state.board) {
          state.board.position(state.initialPositionKey);
        }

        renderMoves();
        updateMaterialBalance();
        refreshBoardHighlights();
        updateEvalBar(null);

        if (state.engineReady) {
          state.engine.postMessage('ucinewgame');
        }

        const maxPly = state.verboseHistory.length;
        const desiredPly = typeof targetPly === 'number'
          ? Math.max(0, Math.min(maxPly, targetPly))
          : maxPly;
        goToPly(desiredPly);
      }

      function setupGameFromFen(fen) {
        const trimmed = (fen || '').trim();
        const temp = new Chess();
        if (!trimmed || !temp.load(trimmed)) {
          throw new Error('Invalid FEN string.');
        }

        const headers = {
          White: '—',
          Black: '—',
          Event: 'Custom Position',
          Site: '—',
          Date: new Date().toISOString().slice(0, 10),
          Result: '*',
          Opening: '—',
          FEN: trimmed,
          SetUp: '1'
        };
        populateHeaders(headers);

        state.fullGame = null;
        state.initialFen = trimmed;
        state.initialPositionKey = determineInitialPositionKey(trimmed);
        state.verboseHistory = [];
        state.bestEvalByPly = [];
        state.multiPv = new Map();
        state.ply = 0;
        state.lastHighlightedMove = null;
        resetCurrentGame();

        if (state.board) {
          state.board.position(state.initialPositionKey);
        }

        renderMoves();
        updateMaterialBalance();
        refreshBoardHighlights();
        updateEvalBar(null);

        if (state.engineReady) {
          state.engine.postMessage('ucinewgame');
        }

        goToPly(0);
      }

      async function loadFromSource(source, targetPly = null) {
        if (!source) return;
        const type = source.type || getInputType();
        const value = source.value ?? getCurrentInputValue();
        state.currentSource = { type, value };

        drawArrows([]);
        updatePVDisplay([]);
        clearRatingGuess();
        updateEloGuessDisplay();
        setUrlParam('ply', null);

        try {
          if (type === INPUT_TYPES.LICHESS) {
            const id = extractGameId(value);
            if (!id) {
              setStatus('loadStatus', 'Please provide a Lichess URL or game ID.', 'error');
              return;
            }
            setStatus('loadStatus', 'Fetching PGN…');
            const pgn = await fetchPGN(id);
            await setupGameFromPgn(pgn, targetPly);
            setUrlParam('game', id);
            setUrlParam('source', null);
            setStatus('loadStatus', 'Game ready.', 'ok');
          } else if (type === INPUT_TYPES.FEN) {
            if (!value || !value.trim()) {
              setStatus('loadStatus', 'Please paste a FEN string.', 'error');
              return;
            }
            setStatus('loadStatus', 'Loading position…');
            setupGameFromFen(value);
            setUrlParam('game', null);
            setUrlParam('source', value.trim());
            setStatus('loadStatus', 'Position ready.', 'ok');
          } else {
            if (!value || !value.trim()) {
              setStatus('loadStatus', 'Please paste a PGN.', 'error');
              return;
            }
            setStatus('loadStatus', 'Loading PGN…');
            await setupGameFromPgn(value, targetPly);
            setUrlParam('game', null);
            setUrlParam('source', value.trim());
            setStatus('loadStatus', 'Game ready.', 'ok');
          }
        } catch (err) {
          console.error(err);
          setStatus('loadStatus', err.message || 'Failed to load data.', 'error');
          throw err;
        }
      }

      function bindUi() {
        const loadButton = byId('loadBtn');
        if (loadButton) {
          loadButton.addEventListener('click', async () => {
            const type = getInputType();
            const value = getCurrentInputValue();
            if (!value) {
              const message = type === INPUT_TYPES.LICHESS
                ? 'Please paste a Lichess URL or ID.'
                : type === INPUT_TYPES.FEN
                  ? 'Please paste a FEN string.'
                  : 'Please paste a PGN.';
              setStatus('loadStatus', message, 'error');
              return;
            }
            await loadFromSource({ type, value });
          });
        }

        const input = byId('gameInput');
        if (input) {
          input.addEventListener('input', () => {
            updateQueryFromInput();
          });
        }

        const typeSelect = byId('inputType');
        if (typeSelect) {
          typeSelect.addEventListener('change', () => {
            updateInputAppearance();
            updateQueryFromInput();
          });
        }

        const guessButton = byId('guessEloBtn');
        if (guessButton) {
          guessButton.addEventListener('click', () => {
            guessPlayerRatings();
          });
        }

        byId('firstBtn').addEventListener('click', () => goToPly(0));
        byId('prevBtn').addEventListener('click', () => goToPly(state.ply - 1));
        byId('nextBtn').addEventListener('click', () => goToPly(state.ply + 1));
        byId('lastBtn').addEventListener('click', () => goToPly(state.verboseHistory.length));
        byId('flipBtn').addEventListener('click', () => {
          state.orientation = state.orientation === 'white' ? 'black' : 'white';
          state.board.flip();
          requestAnimationFrame(() => {
            drawArrows(state.multiPv ? [1, 2, 3].map(r => state.multiPv.get(r) || null) : []);
            refreshBoardHighlights();
          });
        });
        byId('timeMs').addEventListener('change', analyzeCurrent);
        byId('depth').addEventListener('change', analyzeCurrent);

        byId('themeToggle').addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
          setTheme(newTheme);
        });

        const arrowToggle = byId('toggleArrowRatings');
        if (arrowToggle) {
          arrowToggle.addEventListener('change', (event) => {
            state.settings.showArrowRatings = event.target.checked;
            saveSettings();
            requestAnimationFrame(() => drawArrows(state.multiPv ? [1, 2, 3].map(r => state.multiPv.get(r) || null) : []));
          });
        }

        applySettingsToUi();
        updateInputAppearance();
      }


      // Theme management
      function getSystemTheme() {
        return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }

      function getSavedTheme() {
        return localStorage.getItem('theme');
      }

      function setTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        updateThemeButton(theme);
      }

      function updateThemeButton(theme) {
        const button = byId('themeToggle');
        if (theme === 'dark') {
          button.textContent = '☀️ Light';
          button.title = 'Switch to light theme';
        } else {
          button.textContent = '🌙 Dark';
          button.title = 'Switch to dark theme';
        }
      }

      function initTheme() {
        const savedTheme = getSavedTheme();
        const systemTheme = getSystemTheme();
        const theme = savedTheme || systemTheme;
        setTheme(theme);

        // Listen for system theme changes
        if (window.matchMedia) {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!getSavedTheme()) {
              setTheme(e.matches ? 'dark' : 'light');
            }
          });
        }
      }

      function main() {
        if (typeof window.Chessboard === 'undefined') {
          setStatus('loadStatus', 'Failed to load chessboard.js', 'error');
          return;
        }
        if (typeof Chess === 'undefined') {
          setStatus('loadStatus', 'Failed to load chess.js', 'error');
          return;
        }

        loadSettings();
        initTheme();
        initBoard();
        bindUi();
        updateEvalBar(null); // Initialize evaluation bar to neutral
        updateMaterialBalance();
        updateEloGuessDisplay();
        setStatus('engStatus', 'Initializing engine…');
        ensureEngine();

        // Check for parameters in URL and auto-load
        const inputTypeParam = getUrlParam('inputType');
        const sourceParam = getUrlParam('source');
        const gameParam = getUrlParam('game');
        const plyParam = parseInt(getUrlParam('ply'), 10);
        const targetPly = Number.isFinite(plyParam) ? plyParam : null;

        let initialType = inputTypeParam && Object.values(INPUT_TYPES).includes(inputTypeParam)
          ? inputTypeParam
          : INPUT_TYPES.PGN;
        let initialValue = sourceParam || '';

        if (gameParam) {
          initialType = INPUT_TYPES.LICHESS;
          initialValue = gameParam;
        }

        setInputType(initialType);
        setCurrentInputValue(initialValue);
        updateInputAppearance();
        updateQueryFromInput();

        if ((initialType === INPUT_TYPES.LICHESS && initialValue) || (initialType !== INPUT_TYPES.LICHESS && initialValue)) {
          setTimeout(() => loadFromSource({ type: initialType, value: initialValue }, targetPly), 800);
        } else if (targetPly !== null) {
          setUrlParam('ply', null);
        }
      }

      window.addEventListener('load', main);
    })();
  </script>
</body>

</html>
